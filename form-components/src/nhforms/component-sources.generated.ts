/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * Generated by: scripts/generate-nhforms-sources.js
 * Generated at: 2026-02-13T06:27:32.099Z
 *
 * This file contains all NHForms component sources as strings for use
 * with Next.js/webpack builds that don't support Vite's import.meta.glob.
 *
 * To regenerate: node scripts/generate-nhforms-sources.js
 */

// Component source code (raw JSX strings)
export const componentModules: Record<string, string> = {
  './AliasIdList/index.jsx': `
const AliasIdList = ({
  label = "Alias Patient Identifiers",
  placeholder = "No alias patient identifiers in chart",
  id = "aliasIdentifiers",
  fieldId,
  sourceId,
  filterPred = (aid:any)=>true,
  isComplete,
  section,
  moisModule = null,
  required = false,
  labelProps = {},
}:Props) => {
  const { Label,Text,Stack } = Fluent
  fieldId = fieldId ?? id
  sourceId = sourceId ?? id

  const [fd, setFd] = useActiveData()
  const sd = useSourceData()
  section = MoisHooks.useSection(section)
  isComplete = isComplete ?? section.sectionComplete(sd,fd,section.sectionNum)

  const active = section.activeSelector(fd)?.[fieldId]

  useOnRefresh((sd,fd) => {
    const source = section.sourceSelector(sd)
    const data = section.activeSelector(fd)
    const initializing = fieldId && data[fieldId]===undefined
    const updating = sourceId && fieldId && !(isComplete ?? section.sectionComplete(sd,fd,section.sectionNum))
    if (initializing || updating) {
      setFd(produce(draft => {
        const newIds = source?.[sourceId]?.filter(filterPred)?.map( aid => ({
          aliasIdentifierId: aid.aliasIdentifierId,
          effectiveDate: aid.effectiveDate,
          idType: aid.identifierType.display,
          identifier: aid.identifier,
          comment: aid.comment,
        }))
        section.activeSelector(draft)[fieldId] = newIds
        }
      ))
    }
  })

  if (active?.length>0) {
    return (
      <>
      <MoisControl.LayoutItem {...{label,moisModule,required,labelProps}}>
        <>
          {active.map((item) => (
            <div key={item.aliasIdentifierId} style={{display: "flex"}}>
              <Text style={{minWidth: "150px"}}>{item.idType}:</Text>
              <Text style={{minWidth: "150px"}}>{item.identifier}</Text>
              <Text>{item.comment}</Text>
            </div>
          ))}
        </>
      </MoisControl.LayoutItem>
      </>
    )
  } else {
    return (
      <Stack horizontal>
        <Label required={required} {...labelProps}>{placeholder}</Label>
        {moisModule && <LinkToMois moisModule={moisModule} />}
      </Stack>
    )
  }
}

const AliasIdListFields = "aliasIdentifierId identifier comment effectiveDate identifierType { code display system }"
`,
  './Allergies/index.jsx': `
// Handle 2.25.12 case where Allergies is a predefined component
if (typeof Allergies==="undefined") {
  window.Allergies = null
}

/**
 * Display a list of allergy indications associated with the patient
 */
Allergies = ({
  id = "allergies",
  selectText = "Select allergies to include",
  selectionType = "none",
  ...props
}:Props) => {

  return (
    <ListSelection
      {...{columns: allergyColumns, id, selectionType, selectText}}
      {...props}
    />
  )

}

const allergyColumns: ColumnSelection = [
  {
    id: "allergyId",
    type: "key",
  },
  {
    title: "Onset",
    id: "startDate",
    type: "date",
  },
  {
    id: "stopDate",
    type: "hidden",
  },
  {
    title: "Agent",
    id: "substance",
    type: "string",
  },
  {
    title: "Reactions",
    id: "reactions",
    type: "string",
  },
]

const AllergiesFields = "allergyId startDate stopDate substance reactions"
`,
  './CommonSchemaDefn/index.jsx': `
const commonSchemaDefn = {

  coding: {
    type: "object",
    properties: {
      code:     { type: ["string", "null"] },
      display:  { type: ["string", "null"] },
      system:   { type: ["string", "null"] },
    },
  },
  codings: {
    type: "array",
    items: {
      type: "object",
      properties: {
        code:     { type: ["string", "null"] },
        display:  { type: ["string", "null"] },
        system:   { type: ["string", "null"] },
      },
    },
  },

  "date":         { "type": [ "string", "null" ] },

  selectedItems: {
    type: "array",
    items: {
      type: "object",
      properties: {},
    }
  },

  "ynu": {
    type: "object",
    properties: {
      code:     { type: ["string", "null"] },
      display:  { type: ["string", "null"] },
      system:   { type: ["string", "null"] },
    },
  },

}

const nameBlockSchema = {
  "basicDemographics": {
    "type": "object",
    "properties": {
      "patientId":    { "type": "number" },
      "chartNumber":  { "type": "number" },
      "name": {
        "type": "object",
        "properties": {
          "text":   { "type": ["string", "null"] },
          "first":  { "type": ["string", "null"] },
          "middle": { "type": ["string", "null"] },
          "family": { "type": ["string", "null"] },
        }
      },
      "birthDate":  { "$ref": "#/definitions/date" },
      "telecom": {
        "homePhone": { "type": ["string", "null"] },
        "workPhone": { "type": ["string", "null"] },
        "cellPhone": { "type": ["string", "null"] },
      },
      "preferredPhone":       { "$ref": "#/definitions/coding" },
      "administrativeGender": { "$ref": "#/definitions/coding" },
      "preferredGender":      { "$ref": "#/definitions/coding" },
      "insuranceNumber":      { "type": ["string", "null"] },
      "insuranceBy":          { "$ref": "#/definitions/coding" },
    },
    "required": [ "patientId", "chartNumber", "name", "birthDate", "administrativeGender" ],
    "additionalProperties": false
  },
}

const NameBlockFields = \`
patientId
chartNumber
name { text first middle family }
administrativeGender { code display system }
preferredGender { code display system }
maritalStatus { code display system }
insuranceBy { code display system }
birthDate
insuranceNumber
preferredPhone { code display system }
telecom { homePhone workPhone cellPhone }
\`

const formHistorySchema = {
  createdBy:      { type: "string" },
  createdAt:      { $ref: "#/definitions/coding" },
  dateCreated:    { $ref: "#/definitions/date" },
}

const selectAll = ()=>true
const startDateDesc = (a,b) => -a.startDate.localeCompare(b.startDate)

const ynuaOptions=[
  { order: 1, code: "Y", display: "Yes", system: "AIHS-YESNOUNKNOWN", hotKey: "Y" },
  { order: 2, code: "N", display: "No", system: "AIHS-YESNOUNKNOWN", hotKey: "N" },          
  { order: 3, code: "U", display: "Unknown / Not Asked", system: "AIHS-YESNOUNKNOWN", hotKey: "U" },
]

/** Returns a list of observation updates for text values. Assumes a single observation with the same code */
const makeTextObsUpdates = (
  sd: SourceDataType,
  fd: ActiveDataType,
  observationCode: string,
  testName: string,
  valueField: string = "See report",
  report: string,
  template: Observation = {},
  conditional: boolean = true,         // Observation should exist only if true
): Observation[] => {

  const active = fd.field.data
  const oldObs = sd.webform?.observations?.find(o=>o.observationCode===observationCode)
  const oldObsId = oldObs?.observationId ?? 0

  if (conditional) {                // There should be an observation

    const newDco = {
      observationId: oldObsId,
      collectedDate: active.dateCreated,
      collectedBy: active.createdBy ?? sd.userProfile?.identity?.fullName,
      orderedBy: active.createdBy ?? sd.userProfile?.identity?.fullName,
      observationCode,
      observationClass: "DCOBS",
      value: valueField,
      units: "",
      valueType: "TEXT",
      status: oldObsId ? "C" : "F",
      description: testName,
      report: report,
      ...template,
    }
    return [newDco]

  } else if (oldObsId) {        // Existing observation, but conditional is now false
    return [{ observationId: -oldObsId }] // Delete obsolete value
  }
}


/** Returns a list of observation updates for code values. Assumes a single observation with the same code */
const makeCodedObsUpdates = (
  sd: SourceDataType,
  fd: ActiveDataType,
  fieldId: string,
  observationCode: string,
  codingField: string = "code",
  template: Observation = {},
  conditional: boolean = true,         // Observation should exist only if true
): Observation[] => {

  const active = fd.field.data
  const oldObs = sd.webform?.observations?.find(o=>o.observationCode===observationCode)
  const oldObsId = oldObs?.observationId ?? 0

  if (conditional) {                // There should be an observation
    if (active?.[fieldId]?.code) {   // There is a code to set

      const newDco = {
        observationId: oldObsId,
        collectedDate: active.dateCreated,
        collectedBy: active.createdBy ?? sd.userProfile?.identity?.fullName,
        orderedBy: active.createdBy ?? sd.userProfile?.identity?.fullName,
        observationCode,
        observationClass: "DCOBS",
        value: active[fieldId][codingField],
        units: "",
        // Using "TEXT" and not "VALUESET" so that values are locked to form
        valueType: "TEXT",
        status: oldObsId ? "C" : "F",
        ...template,
      }
      return [newDco]
    } else if (oldObsId) {      // Existing observation, but no new one
      return [{ observationId: -oldObsId }] // Delete obsolete value
    }

  } else if (oldObsId) {        // Existing observation, but conditional is now false
    return [{ observationId: -oldObsId }] // Delete obsolete value
  }
}

const makeValueSetOptions = (
  sd: SourceDataType,
  vs: {
    observationCode: string,
    fbCodeDisplay: string,    // Note: always used since code lookup is not in 2.26
    fbSystem: string,
    fbOptions: any,
  }
) => {
  const valueSet = sd.optionLists["AIHS-LABCODEVALUESETS"]?.[vs.observationCode] ?? vs.fbSystem
  const options = {
    code: vs.observationCode,
    display: vs.fbCodeDisplay,
    codeSystem: valueSet,
    optionList: sd.optionLists[valueSet] ?? vs.fbOptions,
  }
  return options
}

const makeObsUpdatesFromVs = (
  sd: SourceDataType,
  fd: ActiveDataType,
  vs: any,              // Value set description
  report: string,       // Defaults to code display value
  conditional: boolean = true,         // Observation should exist only if true
) => {
  const vso = makeValueSetOptions(sd,vs)
  return makeCodedObsUpdates(
    sd,
    fd,
    vs.fieldId,
    vso.code,
    "code",
    { description: vso.display, report: report ?? fd.field.data[vs.fieldId]?.display ?? null },
    conditional
  )
}
`,
  './CompactBooleanField/index.jsx': `/**
 * CompactBooleanField - Yes/No button component with custom label support
 *
 * Features:
 * - Styled Yes/No toggle buttons
 * - Custom label support (e.g., "Normal"/"Abnormal", "Yes"/"No")
 * - Size variants (normal, small)
 * - Card container styling option
 * - Dark mode support via theme
 * - Integration with form data via useActiveData
 */

const { useMemo, useCallback } = React
const {
  Stack,
  Label,
  Text,
  Checkbox,
} = Fluent

// ================================================
// Type definitions (JSDoc for documentation)
// ================================================

/**
 * @typedef {Object} BooleanLabels
 * @property {string} on - Label for "yes" state (default: "Yes")
 * @property {string} off - Label for "no" state (default: "No")
 */

/**
 * @typedef {'normal' | 'small'} ButtonSize
 */

// ================================================
// Styles
// ================================================

const getButtonStyles = (isSelected, isDarkMode, size = 'normal') => {
  const sizeStyles = size === 'small'
    ? { padding: '2px 8px', fontSize: '11px' }
    : { padding: '4px 10px', fontSize: '12px' }

  return {
    ...sizeStyles,
    fontWeight: 600,
    borderRadius: '4px',
    border: 'none',
    cursor: 'pointer',
    transition: 'background-color 0.15s ease, color 0.15s ease',
    backgroundColor: isSelected
      ? '#0078d4'                              // Selected: Fluent blue
      : (isDarkMode ? '#333' : '#e0e0e0'),    // Unselected: gray
    color: isSelected
      ? '#fff'                                 // Selected: white text
      : (isDarkMode ? '#ccc' : '#666'),        // Unselected: gray text
  }
}

const getCardContainerStyles = (isDarkMode) => ({
  padding: '8px 12px',
  borderRadius: '6px',
  border: \`1px solid \${isDarkMode ? '#404040' : '#e0e0e0'}\`,
  backgroundColor: isDarkMode ? '#1a1a1a' : '#ffffff',
})

const getFieldContainerStyles = (isDarkMode, showCard) => {
  if (showCard) {
    return getCardContainerStyles(isDarkMode)
  }
  return {
    padding: '4px 0',
  }
}

// ================================================
// Helper Functions
// ================================================

/**
 * Decode PDF name hex encoding (#XX sequences) that may appear in labels.
 * PDF names encode special characters as #XX where XX is the hex ASCII code.
 * For example, "/" (ASCII 47 = 0x2F) is encoded as "#2F".
 * @param {string} value
 * @returns {string}
 */
const decodePDFHex = (value) => {
  if (!value || typeof value !== 'string') return value
  // Decode all #XX hex sequences (case-insensitive)
  let decoded = value
  let prevDecoded = ""
  while (prevDecoded !== decoded) {
    prevDecoded = decoded
    decoded = decoded.replace(/#([0-9A-Fa-f]{2})/gi, (_, hex) => {
      return String.fromCharCode(parseInt(hex, 16))
    })
  }
  return decoded
}

/**
 * Get boolean labels with defaults
 * @param {BooleanLabels} [labels]
 * @returns {{ yesLabel: string, noLabel: string }}
 */
const getBooleanLabels = (labels) => ({
  yesLabel: decodePDFHex(labels?.on || 'Yes'),
  noLabel: decodePDFHex(labels?.off || 'No'),
})

/**
 * Normalize a value to 'yes', 'no', or null
 * @param {any} value
 * @returns {'yes' | 'no' | null}
 */
const normalizeValue = (value) => {
  if (value === true || value === 'yes' || value === 'Y' || value === 1) {
    return 'yes'
  }
  if (value === false || value === 'no' || value === 'N' || value === 0) {
    return 'no'
  }
  return null
}

// ================================================
// Sub-components
// ================================================

/**
 * YesNoButtons - Reusable Yes/No button pair component
 *
 * @param {Object} props
 * @param {string} [props.yesLabel="Yes"] - Label for yes button
 * @param {string} [props.noLabel="No"] - Label for no button
 * @param {'yes' | 'no' | null} [props.value] - Current value
 * @param {(value: 'yes' | 'no' | null) => void} props.onChange - Change handler
 * @param {ButtonSize} [props.size="normal"] - Button size
 * @param {boolean} [props.disabled] - Disable buttons
 * @param {boolean} [props.isDarkMode] - Dark mode flag
 * @param {boolean} [props.allowDeselect=true] - Allow clicking selected option to deselect
 */
const YesNoButtons = ({
  yesLabel = 'Yes',
  noLabel = 'No',
  value,
  onChange,
  size = 'normal',
  disabled = false,
  isDarkMode = false,
  allowDeselect = true,
}) => {
  const normalized = normalizeValue(value)

  const handleYesClick = useCallback(() => {
    if (!disabled) {
      // If already selected and allowDeselect is true, deselect (set to null)
      if (normalized === 'yes' && allowDeselect) {
        onChange(null)
      } else {
        onChange('yes')
      }
    }
  }, [disabled, normalized, allowDeselect, onChange])

  const handleNoClick = useCallback(() => {
    if (!disabled) {
      // If already selected and allowDeselect is true, deselect (set to null)
      if (normalized === 'no' && allowDeselect) {
        onChange(null)
      } else {
        onChange('no')
      }
    }
  }, [disabled, normalized, allowDeselect, onChange])

  const yesButtonStyle = {
    ...getButtonStyles(normalized === 'yes', isDarkMode, size),
    opacity: disabled ? 0.5 : 1,
    cursor: disabled ? 'not-allowed' : 'pointer',
  }

  const noButtonStyle = {
    ...getButtonStyles(normalized === 'no', isDarkMode, size),
    opacity: disabled ? 0.5 : 1,
    cursor: disabled ? 'not-allowed' : 'pointer',
  }

  return (
    <Stack horizontal tokens={{ childrenGap: 4 }}>
      <button
        type="button"
        style={yesButtonStyle}
        onClick={handleYesClick}
        disabled={disabled}
        aria-pressed={normalized === 'yes'}
      >
        {yesLabel}
      </button>
      <button
        type="button"
        style={noButtonStyle}
        onClick={handleNoClick}
        disabled={disabled}
        aria-pressed={normalized === 'no'}
      >
        {noLabel}
      </button>
    </Stack>
  )
}

/**
 * CompactBooleanField - Full boolean field with label and Yes/No buttons
 *
 * @param {Object} props
 * @param {string} props.fieldId - Field ID for form data storage
 * @param {string} [props.label] - Field label
 * @param {BooleanLabels} [props.booleanLabels] - Custom button labels
 * @param {ButtonSize} [props.buttonSize="normal"] - Button size (normal or small)
 * @param {'full' | '1/2' | '1/3' | '2/3' | '1/4' | '3/4'} [props.size] - Field width for grid layout
 * @param {boolean} [props.showCard=false] - Show card container
 * @param {boolean} [props.disabled] - Disable field
 * @param {boolean} [props.required] - Mark as required
 * @param {'left' | 'top' | 'right'} [props.labelPosition="left"] - Label position
 * @param {string} [props.note] - Annotation/note text
 * @param {boolean} [props.allowDeselect=true] - Allow clicking selected option to deselect
 * @param {string} [props.sourceFieldId] - Original PDF field ID (for PDF sync highlighting when this is a controller)
 * @param {'buttons' | 'checkbox'} [props.displayStyle='buttons'] - Display style: 'buttons' (Yes/No buttons) or 'checkbox' (single checkbox)
 */
const CompactBooleanField = ({
  fieldId,
  label,
  booleanLabels,
  buttonSize = 'normal',
  size,
  showCard = false,
  disabled = false,
  required = false,
  labelPosition = 'left',
  note,
  allowDeselect = true,
  sourceFieldId,
  displayStyle = 'buttons',
  ...props
}) => {
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  const { yesLabel, noLabel } = getBooleanLabels(booleanLabels)

  // Get current value from form data
  const currentValue = fd?.field?.data?.[fieldId]
  const normalized = normalizeValue(currentValue)

  // Handle value change
  const handleChange = useCallback((newValue) => {
    if (!fd?.setFormData) return

    // Store as boolean or null (for deselected state)
    let storedValue
    if (newValue === null) {
      storedValue = null  // Deselected
    } else {
      storedValue = newValue === 'yes'  // true or false
    }

    fd.setFormData({
      ...fd,
      field: {
        ...fd.field,
        data: {
          ...fd.field?.data,
          [fieldId]: storedValue,
        },
      },
    })
  }, [fd, fieldId])

  // Styles
  const baseContainerStyle = getFieldContainerStyles(isDarkMode, showCard)

  // Add width styling for grid layout
  const getWidthStyle = (sizeValue) => {
    if (!sizeValue || sizeValue === 'full') return {}
    const widthMap = {
      '1/2': '50%',
      '1/3': '33.333%',
      '2/3': '66.666%',
      '1/4': '25%',
      '3/4': '75%',
    }
    return { width: widthMap[sizeValue] || '100%', flexShrink: 0 }
  }

  const containerStyle = { ...baseContainerStyle, ...getWidthStyle(size) }

  const themeLabelMinWidth = theme?.mois?.defaultCommonControlStyle?.minLabelWidth ?? 240
  const themeLabelMaxWidth = theme?.mois?.defaultCommonControlStyle?.maxLabelWidth ?? themeLabelMinWidth
  const isLeftLabel = labelPosition === 'left'
  const labelStyle = {
    root: {
      fontWeight: 600,
      marginRight: isLeftLabel ? '10px' : 0,
      marginBottom: labelPosition === 'top' ? '4px' : 0,
      minWidth: isLeftLabel ? themeLabelMinWidth : 'auto',
      maxWidth: isLeftLabel ? themeLabelMaxWidth : undefined,
      padding: isLeftLabel ? '5px 0px' : undefined,
      flex: isLeftLabel ? '0 0 auto' : undefined,
    },
  }

  const noteStyle = {
    fontSize: '11px',
    color: isDarkMode ? '#888' : '#666',
    marginTop: '4px',
  }

  const isHorizontal = labelPosition === 'left' || labelPosition === 'right'

  const handleCheckboxChange = useCallback((_ev, checked) => {
    handleChange(checked ? 'yes' : 'no')
  }, [handleChange])

  const fieldContent = displayStyle === 'checkbox' ? (
    <Checkbox
      label={label ? \`\${label}\${required ? ' *' : ''}\` : undefined}
      checked={normalized === 'yes'}
      onChange={handleCheckboxChange}
      disabled={disabled}
    />
  ) : (
    <>
      {label && labelPosition !== 'right' && (
        <Label styles={labelStyle}>
          {label}
          {required && <span style={{ color: '#d32f2f', marginLeft: '4px' }}>*</span>}
        </Label>
      )}
      <YesNoButtons
        yesLabel={yesLabel}
        noLabel={noLabel}
        value={normalized}
        onChange={handleChange}
        size={buttonSize}
        disabled={disabled}
        isDarkMode={isDarkMode}
        allowDeselect={allowDeselect}
      />
      {label && labelPosition === 'right' && (
        <Label styles={{ ...labelStyle, root: { ...labelStyle.root, marginLeft: '12px', marginRight: 0 } }}>
          {label}
          {required && <span style={{ color: '#d32f2f', marginLeft: '4px' }}>*</span>}
        </Label>
      )}
    </>
  )

  return (
    <div id={fieldId} style={containerStyle} data-field-id={fieldId} data-source-field-id={sourceFieldId || undefined}>
      {isHorizontal ? (
        <div style={{ display: 'flex', flexFlow: 'row wrap', alignItems: 'flex-start' }}>
          {fieldContent}
        </div>
      ) : (
        <Stack tokens={{ childrenGap: 4 }}>
          {fieldContent}
        </Stack>
      )}
      {note && (
        <div style={noteStyle}>{note}</div>
      )}
    </div>
  )
}

/**
 * CompactBooleanGroup - Group of boolean fields with shared styling
 *
 * @param {Object} props
 * @param {string} [props.title] - Group title
 * @param {boolean} [props.showCard=true] - Show card container for group
 * @param {React.ReactNode} props.children - CompactBooleanField children
 */
const CompactBooleanGroup = ({
  title,
  showCard = true,
  children,
  ...props
}) => {
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  const containerStyle = showCard
    ? {
        ...getCardContainerStyles(isDarkMode),
        padding: '12px 16px',
      }
    : {}

  const titleStyle = {
    fontWeight: 600,
    fontSize: '14px',
    marginBottom: '12px',
    color: isDarkMode ? '#e0e0e0' : '#333',
  }

  return (
    <div style={containerStyle}>
      {title && <div style={titleStyle}>{title}</div>}
      <Stack tokens={{ childrenGap: 8 }}>
        {children}
      </Stack>
    </div>
  )
}

/**
 * CompactBooleanChecklist - Multiple boolean fields rendered as a checklist
 *
 * @param {Object} props
 * @param {string} props.id - Base ID for field storage
 * @param {Array<{ id: string, label: string, booleanLabels?: BooleanLabels }>} props.fields - Field definitions
 * @param {string} [props.title] - Checklist title
 * @param {ButtonSize} [props.size="small"] - Button size for all fields
 * @param {boolean} [props.showCard=true] - Show card container
 * @param {BooleanLabels} [props.defaultLabels] - Default labels for all fields
 * @param {boolean} [props.allowDeselect=true] - Allow clicking selected option to deselect
 */
const CompactBooleanChecklist = ({
  id,
  fields = [],
  title,
  size = 'small',
  showCard = true,
  defaultLabels,
  allowDeselect = true,
  ...props
}) => {
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  // Get all values from form data
  const getValues = () => {
    try {
      const data = fd?.field?.data?.[id]
      if (data && typeof data === 'object') {
        return data
      }
    } catch (e) {
      console.log('Error getting values:', e)
    }
    return {}
  }

  const values = getValues()

  // Handle value change for a field
  const handleChange = useCallback((fieldId, newValue) => {
    if (!fd?.setFormData) return

    const currentData = fd?.field?.data?.[id] || {}

    // Store as boolean or null (for deselected state)
    let storedValue
    if (newValue === null) {
      storedValue = null  // Deselected
    } else {
      storedValue = newValue === 'yes'  // true or false
    }

    fd.setFormData({
      ...fd,
      field: {
        ...fd.field,
        data: {
          ...fd.field?.data,
          [id]: {
            ...currentData,
            [fieldId]: storedValue,
          },
        },
      },
    })
  }, [fd, id])

  const containerStyle = showCard
    ? {
        ...getCardContainerStyles(isDarkMode),
        padding: '12px 16px',
      }
    : {}

  const titleStyle = {
    fontWeight: 600,
    fontSize: '14px',
    marginBottom: '12px',
    color: isDarkMode ? '#e0e0e0' : '#333',
  }

  const rowStyle = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: '4px 0',
    borderBottom: \`1px solid \${isDarkMode ? '#333' : '#f0f0f0'}\`,
  }

  const lastRowStyle = {
    ...rowStyle,
    borderBottom: 'none',
  }

  const labelStyle = {
    fontSize: '13px',
    color: isDarkMode ? '#ccc' : '#333',
    flex: 1,
  }

  const { yesLabel: defaultYes, noLabel: defaultNo } = getBooleanLabels(defaultLabels)

  return (
    <div style={containerStyle}>
      {title && <div style={titleStyle}>{title}</div>}
      {fields.map((field, idx) => {
        const { yesLabel, noLabel } = field.booleanLabels
          ? getBooleanLabels(field.booleanLabels)
          : { yesLabel: defaultYes, noLabel: defaultNo }

        const isLast = idx === fields.length - 1

        return (
          <div key={field.id} style={isLast ? lastRowStyle : rowStyle}>
            <span style={labelStyle}>{field.label}</span>
            <YesNoButtons
              yesLabel={yesLabel}
              noLabel={noLabel}
              value={normalizeValue(values[field.id])}
              onChange={(val) => handleChange(field.id, val)}
              size={size}
              isDarkMode={isDarkMode}
              allowDeselect={allowDeselect}
            />
          </div>
        )
      })}
    </div>
  )
}

/**
 * Schema definition for CompactBooleanField data
 */
const CompactBooleanFieldSchema = {
  type: 'boolean',
}

/**
 * Schema definition for CompactBooleanChecklist data
 */
const CompactBooleanChecklistSchema = {
  type: 'object',
  additionalProperties: {
    type: 'boolean',
  },
}

/**
 * Pre-built boolean label sets
 */
const BooleanLabelPresets = {
  /** Standard Yes/No */
  yesNo: { on: 'Yes', off: 'No' },
  /** Normal/Abnormal for medical assessments */
  normalAbnormal: { on: 'Normal', off: 'Abnormal' },
  /** Abnormal/Normal (reversed) */
  abnormalNormal: { on: 'Abnormal', off: 'Normal' },
  /** Present/Absent */
  presentAbsent: { on: 'Present', off: 'Absent' },
  /** Positive/Negative */
  positiveNegative: { on: 'Positive', off: 'Negative' },
  /** True/False */
  trueFalse: { on: 'True', off: 'False' },
  /** Completed/Incomplete */
  completedIncomplete: { on: 'Completed', off: 'Incomplete' },
  /** Active/Inactive */
  activeInactive: { on: 'Active', off: 'Inactive' },
  /** Enabled/Disabled */
  enabledDisabled: { on: 'Enabled', off: 'Disabled' },
  /** Pass/Fail */
  passFail: { on: 'Pass', off: 'Fail' },
}

// ================================================
// CompactChoiceField - Multi-option button selection
// ================================================

/**
 * OptionButtons - Reusable multi-option button component
 *
 * @param {Object} props
 * @param {Array<{ key: string, text: string }>} props.options - Options to display
 * @param {string | string[] | null} props.value - Current selected value(s)
 * @param {(value: string | string[] | null) => void} props.onChange - Change handler
 * @param {'single' | 'multiple'} [props.selectionType='single'] - Selection mode
 * @param {ButtonSize} [props.size='normal'] - Button size
 * @param {boolean} [props.disabled] - Disable buttons
 * @param {boolean} [props.isDarkMode] - Dark mode flag
 * @param {boolean} [props.allowDeselect=true] - Allow deselection in single mode
 * @param {boolean} [props.wrap=true] - Allow buttons to wrap to next line
 */
const OptionButtons = ({
  options = [],
  value,
  onChange,
  selectionType = 'single',
  size = 'normal',
  disabled = false,
  isDarkMode = false,
  allowDeselect = true,
  wrap = true,
}) => {
  const isMultiple = selectionType === 'multiple'

  // Normalize value to array for consistent handling
  const selectedValues = useMemo(() => {
    if (value === null || value === undefined) return []
    if (Array.isArray(value)) return value
    return [value]
  }, [value])

  const isSelected = useCallback((optionKey) => {
    return selectedValues.includes(optionKey)
  }, [selectedValues])

  const handleClick = useCallback((optionKey) => {
    if (disabled) return

    if (isMultiple) {
      // Multi-select: toggle the option
      const newValues = isSelected(optionKey)
        ? selectedValues.filter(v => v !== optionKey)
        : [...selectedValues, optionKey]
      onChange(newValues.length > 0 ? newValues : null)
    } else {
      // Single-select: select or deselect
      if (isSelected(optionKey) && allowDeselect) {
        onChange(null)
      } else {
        onChange(optionKey)
      }
    }
  }, [disabled, isMultiple, isSelected, selectedValues, allowDeselect, onChange])

  const containerStyle = {
    display: 'flex',
    flexWrap: wrap ? 'wrap' : 'nowrap',
    gap: '4px',
  }

  return (
    <div style={containerStyle}>
      {options.map((option) => {
        const selected = isSelected(option.key)
        const buttonStyle = {
          ...getButtonStyles(selected, isDarkMode, size),
          opacity: disabled ? 0.5 : 1,
          cursor: disabled ? 'not-allowed' : 'pointer',
        }

        return (
          <button
            key={option.key}
            type="button"
            style={buttonStyle}
            onClick={() => handleClick(option.key)}
            disabled={disabled}
            aria-pressed={selected}
          >
            {option.text}
          </button>
        )
      })}
    </div>
  )
}

/**
 * CompactChoiceField - Multi-option field with button selection
 *
 * @param {Object} props
 * @param {string} props.fieldId - Field ID for form data storage
 * @param {string} [props.label] - Field label
 * @param {Array<{ key: string, text: string }>} [props.optionList] - Options to display
 * @param {'single' | 'multiple'} [props.selectionType='single'] - Selection mode
 * @param {ButtonSize} [props.size='normal'] - Button size
 * @param {boolean} [props.showCard=false] - Show card container
 * @param {boolean} [props.disabled] - Disable field
 * @param {boolean} [props.required] - Mark as required
 * @param {'left' | 'top' | 'right'} [props.labelPosition='top'] - Label position
 * @param {string} [props.note] - Annotation/note text
 * @param {boolean} [props.allowDeselect=true] - Allow deselection in single mode
 * @param {boolean} [props.wrap=true] - Allow buttons to wrap
 */
const CompactChoiceField = ({
  fieldId,
  label,
  optionList = [],
  selectionType = 'single',
  size = 'normal',
  showCard = false,
  disabled = false,
  required = false,
  labelPosition = 'top',
  note,
  allowDeselect = true,
  wrap = true,
  ...props
}) => {
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  // Get current value from form data
  const currentValue = fd?.field?.data?.[fieldId]

  // Handle value change
  const handleChange = useCallback((newValue) => {
    if (!fd?.setFormData) return

    fd.setFormData({
      ...fd,
      field: {
        ...fd.field,
        data: {
          ...fd.field?.data,
          [fieldId]: newValue,
        },
      },
    })
  }, [fd, fieldId])

  // Styles
  const containerStyle = getFieldContainerStyles(isDarkMode, showCard)

  const themeLabelMinWidth = theme?.mois?.defaultCommonControlStyle?.minLabelWidth ?? 240
  const themeLabelMaxWidth = theme?.mois?.defaultCommonControlStyle?.maxLabelWidth ?? themeLabelMinWidth
  const isLeftLabel = labelPosition === 'left'
  const labelStyle = {
    root: {
      fontWeight: 600,
      marginRight: isLeftLabel ? '10px' : 0,
      marginBottom: labelPosition === 'top' ? '4px' : 0,
      minWidth: isLeftLabel ? themeLabelMinWidth : 'auto',
      maxWidth: isLeftLabel ? themeLabelMaxWidth : undefined,
      padding: isLeftLabel ? '5px 0px' : undefined,
      flex: isLeftLabel ? '0 0 auto' : undefined,
    },
  }

  const noteStyle = {
    fontSize: '11px',
    color: isDarkMode ? '#888' : '#666',
    marginTop: '4px',
  }

  const isHorizontal = labelPosition === 'left' || labelPosition === 'right'

  const choiceContent = (
    <>
      {label && labelPosition !== 'right' && (
        <Label styles={labelStyle}>
          {label}
          {required && <span style={{ color: '#d32f2f', marginLeft: '4px' }}>*</span>}
        </Label>
      )}
      <OptionButtons
        options={optionList}
        value={currentValue}
        onChange={handleChange}
        selectionType={selectionType}
        size={size}
        disabled={disabled}
        isDarkMode={isDarkMode}
        allowDeselect={allowDeselect}
        wrap={wrap}
      />
      {label && labelPosition === 'right' && (
        <Label styles={{ ...labelStyle, root: { ...labelStyle.root, marginLeft: '12px', marginRight: 0 } }}>
          {label}
          {required && <span style={{ color: '#d32f2f', marginLeft: '4px' }}>*</span>}
        </Label>
      )}
    </>
  )

  return (
    <div id={fieldId} style={containerStyle} data-field-id={fieldId}>
      {isHorizontal ? (
        <div style={{ display: 'flex', flexFlow: 'row wrap', alignItems: 'flex-start' }}>
          {choiceContent}
        </div>
      ) : (
        <Stack tokens={{ childrenGap: 4 }}>
          {choiceContent}
        </Stack>
      )}
      {note && (
        <div style={noteStyle}>{note}</div>
      )}
    </div>
  )
}

/**
 * Schema definition for CompactChoiceField data (single select)
 */
const CompactChoiceFieldSchema = {
  type: ['string', 'null'],
}

/**
 * Schema definition for CompactChoiceField data (multi select)
 */
const CompactChoiceFieldMultiSchema = {
  type: ['array', 'null'],
  items: { type: 'string' },
}
`,
  './ConditionalGroup/index.jsx': `/**
 * ConditionalGroup - Logic Gate System for Conditional Field Visibility
 *
 * Features:
 * - Controller field-based visibility using CompactBooleanField
 * - Nested conditional groups up to 5 levels deep
 * - Field-level visibility modes (inherit, always, controller)
 * - Parent chain visibility checking (all parent gates must be satisfied)
 * - Customizable container and content styling via props
 * - Dark mode support
 *
 * Usage:
 * <ConditionalGroup
 *   id="headNeck"
 *   controllerLabel="Head/Neck Abnormal?"
 *   showWhen="yes"
 *   booleanLabels={{ on: "Abnormal", off: "Normal" }}
 * >
 *   <ConditionalField fieldId="details">
 *     <TextField label="Details" />
 *   </ConditionalField>
 *   <ConditionalGroup id="eyes" controllerLabel="Eye Issues?" showWhen="yes">
 *     <TextField label="Eye Details" />
 *   </ConditionalGroup>
 * </ConditionalGroup>
 */

const { useMemo, useCallback, useContext, createContext } = React
const {
  Stack,
  Label,
  Text,
} = Fluent

// ================================================
// Constants
// ================================================

/** Maximum nesting depth for conditional groups */
const MAX_SUBGROUP_DEPTH = 5

// ================================================
// Type definitions (JSDoc for documentation)
// ================================================

/**
 * @typedef {'yes' | 'no'} ShowWhenValue
 */

/**
 * @typedef {'inherit' | 'always' | 'controller'} FieldVisibilityMode
 */

/**
 * @typedef {Object} FieldVisibilityRule
 * @property {FieldVisibilityMode} mode - Visibility mode
 * @property {string} [controllerFieldId] - Controller field ID (if mode is 'controller')
 * @property {ShowWhenValue} [showWhen] - Show when value (if mode is 'controller')
 */

/**
 * @typedef {Object} BranchingRule
 * @property {string} controllerFieldId - The Yes/No field that controls visibility
 * @property {ShowWhenValue} showWhen - Show children when controller is 'yes' or 'no'
 * @property {Record<string, FieldVisibilityRule>} [fieldRules] - Per-field visibility overrides
 * @property {string} [inheritedFromParent] - Parent subgroup ID if cascaded
 */

/**
 * @typedef {Object} BooleanLabels
 * @property {string} on - Label for "yes" state
 * @property {string} off - Label for "no" state
 */

/**
 * @typedef {Object} LogicGateContextValue
 * @property {number} depth - Current nesting depth
 * @property {string[]} parentChain - Array of parent group IDs
 * @property {(groupId: string) => boolean} isGroupVisible - Check if a group is visible
 * @property {(groupId: string) => any} getControllerValue - Get controller value for a group
 * @property {Record<string, BranchingRule>} rules - All branching rules by group ID
 */

// ================================================
// Context
// ================================================

const LogicGateContext = createContext({
  depth: 0,
  parentChain: [],
  isGroupVisible: () => true,
  getControllerValue: () => null,
  rules: {},
})

// ================================================
// Helper Functions
// ================================================

/**
 * Normalize a value to 'yes', 'no', or null
 */
const normalizeValue = (value) => {
  if (value === true || value === 'yes' || value === 'Y' || value === 1) {
    return 'yes'
  }
  if (value === false || value === 'no' || value === 'N' || value === 0) {
    return 'no'
  }
  return null
}

/**
 * Check if controller value matches the showWhen condition
 */
const checkControllerMatch = (controllerValue, showWhen) => {
  const normalized = normalizeValue(controllerValue)
  if (normalized === null) return false // No value = not visible
  return normalized === showWhen
}

/**
 * Merge style objects, handling undefined values
 */
const mergeStyles = (...styles) => {
  return styles.reduce((acc, style) => {
    if (!style) return acc
    return { ...acc, ...style }
  }, {})
}

// ================================================
// Main Components
// ================================================

/**
 * LogicGateProvider - Root provider for the logic gate system
 *
 * Wrap your form with this to enable conditional visibility across all nested groups.
 *
 * @param {Object} props
 * @param {React.ReactNode} props.children
 */
const LogicGateProvider = ({ children }) => {
  const [fd] = useActiveData()

  // Get controller value for a group from form data
  const getControllerValue = useCallback((groupId) => {
    return fd?.field?.data?.[\`\${groupId}_controller\`]
  }, [fd])

  // Rules are stored in form data under _logicGateRules
  const rules = fd?.field?.data?._logicGateRules || {}

  // Check if a group is visible based on its parent chain
  const isGroupVisible = useCallback((groupId) => {
    const rule = rules[groupId]
    if (!rule) return true // No rule = always visible

    const controllerValue = getControllerValue(groupId)
    return checkControllerMatch(controllerValue, rule.showWhen)
  }, [rules, getControllerValue])

  const contextValue = useMemo(() => ({
    depth: 0,
    parentChain: [],
    isGroupVisible,
    getControllerValue,
    rules,
  }), [isGroupVisible, getControllerValue, rules])

  return (
    <LogicGateContext.Provider value={contextValue}>
      {children}
    </LogicGateContext.Provider>
  )
}

/**
 * ConditionalGroup - A group with conditional visibility based on a controller field
 *
 * Uses CompactBooleanField for the controller, ensuring consistent styling.
 *
 * @param {Object} props
 * @param {string} props.id - Unique group ID
 * @param {string} props.controllerLabel - Label for the controller Yes/No field
 * @param {ShowWhenValue} [props.showWhen="yes"] - Show children when controller is 'yes' or 'no'
 * @param {BooleanLabels} [props.booleanLabels] - Custom labels for Yes/No buttons
 * @param {'normal' | 'small'} [props.controllerSize="normal"] - Size of controller buttons
 * @param {boolean} [props.showCard=true] - Show card container
 * @param {boolean} [props.showController=true] - Show the controller header
 * @param {boolean} [props.required] - Mark controller as required
 * @param {string} [props.note] - Note text for controller
 * @param {string} [props.title] - Optional title for the group content
 * @param {Object} [props.containerProps] - Props to pass to the outer container
 * @param {Object} [props.containerStyle] - Style overrides for outer container
 * @param {Object} [props.contentProps] - Props to pass to the content container
 * @param {Object} [props.contentStyle] - Style overrides for content container
 * @param {Object} [props.controllerProps] - Props to pass to CompactBooleanField
 * @param {number} [props.childrenGap=8] - Gap between children (Stack tokens)
 * @param {string} [props.contentPadding] - Padding for content area
 * @param {boolean} [props.indentChildren=false] - Add left border indent for hierarchy
 * @param {boolean} [props.showHiddenIndicator=true] - Show indicator when content is hidden
 * @param {string} [props.sourceFieldId] - Original PDF field ID for PDF sync highlighting
 * @param {'buttons' | 'checkbox'} [props.displayStyle] - Display style for the controller field
 * @param {React.ReactNode} props.children - Child content (shown when condition is met)
 */
const ConditionalGroup = ({
  id,
  controllerLabel,
  showWhen = 'yes',
  booleanLabels,
  controllerSize = 'normal',
  showCard = true,
  showController = true,
  required = false,
  note,
  title,
  containerProps = {},
  containerStyle: containerStyleOverride,
  contentProps = {},
  contentStyle: contentStyleOverride,
  controllerProps = {},
  childrenGap = 8,
  contentPadding,
  indentChildren = false,
  showHiddenIndicator = false,
  sourceFieldId,
  displayStyle,
  children,
  ...props
}) => {
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false
  const parentContext = useContext(LogicGateContext)

  // Check nesting depth
  const currentDepth = parentContext.depth + 1
  if (currentDepth > MAX_SUBGROUP_DEPTH) {
    console.warn(\`ConditionalGroup: Maximum nesting depth (\${MAX_SUBGROUP_DEPTH}) exceeded for group "\${id}"\`)
    return null
  }

  // Check if all parent groups are visible
  const parentChain = [...parentContext.parentChain, id]
  const allParentsVisible = parentContext.parentChain.every(parentId => {
    return parentContext.isGroupVisible(parentId)
  })

  // If any parent is not visible, don't render this group at all
  if (!allParentsVisible) {
    return null
  }

  // Controller field ID
  const controllerFieldId = \`\${id}_controller\`

  // Get current controller value
  const controllerValue = fd?.field?.data?.[controllerFieldId]
  // For checkbox-style controllers, the initial null/undefined state is semantically
  // "unchecked" (i.e. false/"no"). Treat it as such so showWhen="no" gates open by default.
  // Button-style controllers keep null as "no selection made" (gate stays closed).
  const effectiveValue = displayStyle === 'checkbox' && (controllerValue === null || controllerValue === undefined)
    ? false
    : controllerValue
  const isVisible = checkControllerMatch(effectiveValue, showWhen)

  // Handle controller change
  const handleControllerChange = useCallback((newValue) => {
    if (!fd?.setFormData) return

    fd.setFormData({
      ...fd,
      field: {
        ...fd.field,
        data: {
          ...fd.field?.data,
          [controllerFieldId]: newValue,
        },
      },
    })
  }, [fd, controllerFieldId])

  // Create child context
  const childContext = useMemo(() => ({
    depth: currentDepth,
    parentChain,
    isGroupVisible: (groupId) => {
      // Check this group first
      if (groupId === id) {
        return isVisible
      }
      // Then check parent context
      return parentContext.isGroupVisible(groupId)
    },
    getControllerValue: (groupId) => {
      if (groupId === id) {
        return controllerValue
      }
      return parentContext.getControllerValue(groupId)
    },
    rules: parentContext.rules,
  }), [currentDepth, parentChain, id, isVisible, controllerValue, parentContext])

  // Styles
  const baseContainerStyle = showCard ? {
    border: \`1px solid \${isDarkMode ? '#404040' : '#e0e0e0'}\`,
    borderRadius: '6px',
    backgroundColor: isDarkMode ? '#1f1f1f' : '#ffffff',
    marginBottom: '12px',
    overflow: 'hidden',
  } : {
    marginBottom: '12px',
  }

  const containerStyle = mergeStyles(baseContainerStyle, containerStyleOverride)

  // Controller wrapper style
  const controllerWrapperStyle = {
    padding: '8px 12px',
    backgroundColor: isDarkMode ? '#252525' : '#f5f5f5',
    borderBottom: isVisible ? \`1px solid \${isDarkMode ? '#404040' : '#e0e0e0'}\` : 'none',
  }

  // Content area style
  const defaultPadding = showCard ? '12px 16px' : (indentChildren ? '8px 0 8px 16px' : '8px 0')
  const baseContentStyle = {
    padding: contentPadding || defaultPadding,
    borderLeft: indentChildren && !showCard ? \`3px solid \${isDarkMode ? '#0078d4' : '#0078d4'}\` : 'none',
    marginLeft: indentChildren && !showCard ? '8px' : 0,
    backgroundColor: showCard && isDarkMode ? '#1a1a1a' : 'transparent',
  }

  const contentStyle = mergeStyles(baseContentStyle, contentStyleOverride)

  const titleStyle = {
    fontWeight: 600,
    fontSize: '14px',
    color: isDarkMode ? '#e0e0e0' : '#333',
    marginBottom: '12px',
  }

  const hiddenIndicatorStyle = {
    padding: '8px 12px',
    fontSize: '12px',
    color: isDarkMode ? '#666' : '#999',
    fontStyle: 'italic',
    backgroundColor: isDarkMode ? '#1a1a1a' : '#fafafa',
  }

  // Depth indicator style (visual hierarchy)
  const depthIndicatorStyle = currentDepth > 1 ? {
    borderLeftWidth: '3px',
    borderLeftStyle: 'solid',
    borderLeftColor: isDarkMode
      ? \`hsl(\${210 + (currentDepth * 15)}, 60%, 40%)\`
      : \`hsl(\${210 + (currentDepth * 15)}, 70%, 50%)\`,
  } : {}

  return (
    <LogicGateContext.Provider value={childContext}>
      <div
        style={mergeStyles(containerStyle, showCard ? depthIndicatorStyle : {})}
        data-conditional-group={id}
        data-depth={currentDepth}
        {...containerProps}
      >
        {showController && (
          <div style={controllerWrapperStyle}>
            <CompactBooleanField
              fieldId={controllerFieldId}
              label={controllerLabel}
              booleanLabels={booleanLabels}
              size={controllerSize}
              showCard={false}
              required={required}
              note={note}
              labelPosition="left"
              sourceFieldId={sourceFieldId}
              displayStyle={displayStyle}
              {...controllerProps}
            />
          </div>
        )}

        {isVisible ? (
          <div style={contentStyle} {...contentProps}>
            {title && <div style={titleStyle}>{title}</div>}
            <Stack tokens={{ childrenGap }}>
              {children}
            </Stack>
          </div>
        ) : (
          showHiddenIndicator && effectiveValue !== undefined && effectiveValue !== null && (
            <div style={hiddenIndicatorStyle}>
              Content hidden (select "{showWhen === 'yes'
                ? (booleanLabels?.on || 'Yes')
                : (booleanLabels?.off || 'No')}" to show)
            </div>
          )
        )}
      </div>
    </LogicGateContext.Provider>
  )
}

/**
 * Check if a choice field value matches any of the specified option values
 * Handles both single values (string) and multi-select values (array)
 */
const checkChoiceMatch = (fieldValue, optionValues, invert = false) => {
  if (fieldValue === null || fieldValue === undefined) {
    return invert // If no value and inverted (not-selected), return true
  }

  // Handle array values (multi-select fields)
  if (Array.isArray(fieldValue)) {
    const hasMatch = optionValues.some(opt => fieldValue.includes(opt))
    return invert ? !hasMatch : hasMatch
  }

  // Handle single value
  const hasMatch = optionValues.includes(fieldValue)
  return invert ? !hasMatch : hasMatch
}

/**
 * ConditionalField - A field wrapper with visibility rules
 *
 * @param {Object} props
 * @param {string} props.fieldId - Field ID
 * @param {FieldVisibilityMode} [props.mode="inherit"] - Visibility mode
 * @param {string} [props.controllerFieldId] - Controller field ID (if mode is 'controller')
 * @param {ShowWhenValue} [props.showWhen] - Show when value (if mode is 'controller' for boolean)
 * @param {string[]} [props.optionValues] - Option values to match (for choice fields)
 * @param {boolean} [props.invertMatch=false] - Invert the match (show when NOT matching)
 * @param {boolean} [props.showWhenNull=false] - Show content when controller value is null/undefined (for hide rules)
 * @param {Object} [props.containerStyle] - Style overrides for wrapper
 * @param {Object} [props.containerProps] - Props to pass to wrapper
 * @param {React.ReactNode} props.children - Field content
 */
const ConditionalField = ({
  fieldId,
  mode = 'inherit',
  controllerFieldId,
  showWhen = 'yes',
  optionValues,
  invertMatch = false,
  showWhenNull = false,
  containerStyle,
  containerProps = {},
  children,
  ...props
}) => {
  const [fd] = useActiveData()
  const parentContext = useContext(LogicGateContext)

  // Determine visibility based on mode
  let isVisible = true

  if (mode === 'always') {
    // Always visible regardless of parent gates
    isVisible = true
  } else if (mode === 'controller' && controllerFieldId) {
    const controllerValue = fd?.field?.data?.[controllerFieldId]

    // DEBUG: Log ConditionalField controller evaluation
    console.log('[ConditionalField] mode=controller', { controllerFieldId, showWhen, controllerValue, optionValues, invertMatch, showWhenNull, fieldId, formDataKeys: Object.keys(fd?.field?.data || {}) })

    // If optionValues is provided, use choice matching instead of boolean matching
    if (optionValues && optionValues.length > 0) {
      isVisible = checkChoiceMatch(controllerValue, optionValues, invertMatch)
    } else {
      // Boolean matching (yes/no)
      // When controller is null/unset, field is hidden (both show and hide rules)
      isVisible = showWhenNull
        ? (normalizeValue(controllerValue) === null ? true : checkControllerMatch(controllerValue, showWhen))
        : checkControllerMatch(controllerValue, showWhen)
    }

    // DEBUG: Log visibility result
    console.log('[ConditionalField] isVisible:', isVisible)
  } else {
    // Inherit - check if all parent groups are visible
    isVisible = parentContext.parentChain.every(parentId => {
      return parentContext.isGroupVisible(parentId)
    })
  }

  if (!isVisible) {
    return null
  }

  if (containerStyle || Object.keys(containerProps).length > 0) {
    return (
      <div style={containerStyle} {...containerProps}>
        {children}
      </div>
    )
  }

  return <>{children}</>
}

/**
 * useLogicGate - Hook to access logic gate context
 *
 * @returns {LogicGateContextValue}
 */
const useLogicGate = () => {
  return useContext(LogicGateContext)
}

/**
 * useIsVisible - Hook to check if current context is visible
 *
 * @returns {boolean}
 */
const useIsVisible = () => {
  const context = useContext(LogicGateContext)
  return context.parentChain.every(parentId => context.isGroupVisible(parentId))
}

/**
 * useConditionalVisibility - Hook to check visibility for a specific condition
 *
 * @param {string} controllerFieldId - Controller field ID to check
 * @param {ShowWhenValue} showWhen - Show when value
 * @returns {boolean}
 */
const useConditionalVisibility = (controllerFieldId, showWhen = 'yes') => {
  const [fd] = useActiveData()
  const controllerValue = fd?.field?.data?.[controllerFieldId]
  return checkControllerMatch(controllerValue, showWhen)
}

// ================================================
// Schema & Utilities
// ================================================

/**
 * Schema for ConditionalGroup controller data
 */
const ConditionalGroupSchema = {
  type: 'object',
  properties: {
    _logicGateRules: {
      type: 'object',
      additionalProperties: {
        type: 'object',
        properties: {
          controllerFieldId: { type: 'string' },
          showWhen: { enum: ['yes', 'no'] },
          inheritedFromParent: { type: 'string' },
        },
      },
    },
  },
  additionalProperties: {
    type: 'boolean', // Controller values are stored as booleans
  },
}

/**
 * Helper to create a branching rule
 */
const createBranchingRule = (def) => ({
  controllerFieldId: def.controllerFieldId || \`\${def.groupId}_controller\`,
  showWhen: def.showWhen || 'yes',
  fieldRules: def.fieldRules || {},
  inheritedFromParent: def.inheritedFromParent,
})

/**
 * Helper to generate JSX code for a conditional group structure
 *
 * @param {Object} config - Group configuration
 * @returns {string} - JSX code string
 */
const generateConditionalGroupJSX = (config) => {
  const indent = (level) => '  '.repeat(level)

  const generateGroup = (group, level = 0) => {
    const props = [
      \`id="\${group.id}"\`,
      \`controllerLabel="\${group.controllerLabel}"\`,
    ]

    if (group.showWhen && group.showWhen !== 'yes') {
      props.push(\`showWhen="\${group.showWhen}"\`)
    }
    if (group.booleanLabels) {
      props.push(\`booleanLabels={{ on: "\${group.booleanLabels.on}", off: "\${group.booleanLabels.off}" }}\`)
    }
    if (group.showCard === false) {
      props.push(\`showCard={false}\`)
    }
    if (group.indentChildren) {
      props.push(\`indentChildren\`)
    }
    if (group.childrenGap && group.childrenGap !== 8) {
      props.push(\`childrenGap={\${group.childrenGap}}\`)
    }
    if (group.title) {
      props.push(\`title="\${group.title}"\`)
    }

    let jsx = \`\${indent(level)}<ConditionalGroup\\n\`
    jsx += props.map(p => \`\${indent(level + 1)}\${p}\`).join('\\n')
    jsx += \`\\n\${indent(level)}>\\n\`

    // Add fields
    if (group.fields) {
      for (const field of group.fields) {
        if (field.mode && field.mode !== 'inherit') {
          jsx += \`\${indent(level + 1)}<ConditionalField fieldId="\${field.id}" mode="\${field.mode}">\\n\`
          jsx += \`\${indent(level + 2)}<\${field.component || 'TextField'} fieldId="\${field.id}" label="\${field.label || field.id}" />\\n\`
          jsx += \`\${indent(level + 1)}</ConditionalField>\\n\`
        } else {
          jsx += \`\${indent(level + 1)}<\${field.component || 'TextField'} fieldId="\${field.id}" label="\${field.label || field.id}" />\\n\`
        }
      }
    }

    // Add nested groups
    if (group.children) {
      for (const child of group.children) {
        jsx += generateGroup(child, level + 1)
      }
    }

    jsx += \`\${indent(level)}</ConditionalGroup>\\n\`
    return jsx
  }

  let result = \`<LogicGateProvider>\\n\`
  result += generateGroup(config, 1)
  result += \`</LogicGateProvider>\`

  return result
}

/**
 * Pre-built controller label presets for common use cases
 * These match the BooleanLabelPresets from CompactBooleanField
 */
const ControllerLabelPresets = {
  /** Standard Yes/No */
  yesNo: { on: 'Yes', off: 'No' },
  /** Normal/Abnormal for medical assessments */
  normalAbnormal: { on: 'Normal', off: 'Abnormal' },
  /** Abnormal/Normal (reversed) */
  abnormalNormal: { on: 'Abnormal', off: 'Normal' },
  /** Present/Absent */
  presentAbsent: { on: 'Present', off: 'Absent' },
  /** Positive/Negative */
  positiveNegative: { on: 'Positive', off: 'Negative' },
  /** Applicable/Not Applicable */
  applicable: { on: 'Yes', off: 'N/A' },
  /** Completed/Pending */
  completed: { on: 'Done', off: 'Pending' },
  /** Checked/Unchecked */
  checked: { on: 'Checked', off: 'Not Checked' },
}
`,
  './Conditions/index.jsx': `
// Handle 2.25.12 case where Allergies is a predefined component
if (typeof Conditions==="undefined") {
  window.Conditions = null
}

/**
 * Display a list of health issues (conditions) experienced by the patient and
 * optionally allows selection.
 */
Conditions = ({
    selectText = "Select conditions",
    id = "conditions",
    selectionType = "none",
    filterPred = selectAll,
    ...props
}:Props) => {

  return (
    <ListSelection
      {...{id, selectionType, columns: conditionsColumns, selectText}}
      {...props}
    />
  )
}

const conditionsColumns: ColumnSelection = [
  {
    id: "conditionId",
    type: "key",
  },
  {
    title: "Date",
    id: "startDate",
    type: "date",
  },
  {
    id: "resolveDate",
    type: "hidden",
  },
  {
    title: "Condition",
    id: "condition",
    type: "code",
    size: "large",
  },
  {
    title: "Certainty",
    id: "certainty",
    type: "code",
  },
  {
    title: "Severity",
    id: "severity",
    type: "code",
  },
]

const ConditionsFields = \`
conditionId 
startDate 
resolveDate
condition { code display system } 
severity { code display system } 
certainty { code display system }
\`
`,
  './Connections/index.jsx': `/**
 * Shows a list of all the patients current connected resources,
 * such as their primary care provider, other care team members, and
 * associated care providers.
 */
const Connections = ({
  id = "connectedResources",
  label = "Patient Connections",
  selectText="Select connections",
  selectionType = "none",
  filterPred = SelectActiveConnections,
  ...props
}:ListSelectionProps) => {

  return (
    <ListSelection
      {...{id, label, selectText, selectionType, filterPred, columns: connectionsColumns}}
      {...props}
    />
  )
}

const connectionsColumns: ColumnSelection = [
  {
    id: "connectionId",
    type: "key",
  },
  {
    title: "Date",
    id: "startDate",
    type: "date"
  },
  {
    id: "stopDate",
    type: "hidden",
  },
  {
    title: "Role",
    id: "connectionType",
    type: "code",
  },
  {
    title: "Name",
    id: "name",
    type: "string",
  },
]

const SelectActiveConnections = cr => (!cr.stopDate)

const ConnectionsFields = "connectionId startDate stopDate connectionType {code display system} name"
`,
  './EditableTable/index.jsx': `
/**
 * EditableTable - A table component with add/delete row functionality
 *
 * Features:
 * - Progressive disclosure: Start with limited visible rows, add more as needed
 * - Empty row detection: Only allow deletion of empty rows
 * - Configurable columns with different field types
 * - Dark mode support via theme
 * - Maximum row limit support
 */

const { useState, useEffect } = React
const {
  Stack,
  Label,
  IconButton,
  DefaultButton,
  Text,
} = Fluent

// Handle case where EditableTable might already be defined
if (typeof EditableTable === "undefined") {
  window.EditableTable = null
}

EditableTable = ({
  id = "editableTable",
  columns = [],
  maxRows = 10,
  initialRows = 1,
  label = "",
  addButtonText = "+ Add Row",
  showRowNumbers = true,
  allowDeleteNonEmpty = false,
  showBackground = false,
  sourceFieldIds = {},  // Map of column ID to original PDF field ID for PDF sync
  sourceFieldIdsByRow = {},  // Map row index -> column ID -> original PDF field ID
  ...props
}) => {
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  // State for visible rows count
  const [visibleRows, setVisibleRows] = useState(initialRows)

  // Get rows data from form data
  const getRows = () => {
    try {
      const data = fd?.field?.data?.[id]
      if (Array.isArray(data) && data.length > 0) {
        return data
      }
    } catch (e) {
      console.log("Error getting rows:", e)
    }
    return null
  }

  const rows = getRows()

  // Initialize rows if they don't exist
  useEffect(() => {
    if (!rows && fd?.setFormData) {
      const initialData = []
      for (let i = 0; i < maxRows; i++) {
        const row = { _rowId: \`row_\${i}\` }
        columns.forEach(col => {
          row[col.id] = col.type === "checkbox" ? false : ""
        })
        initialData.push(row)
      }

      fd.setFormData({
        ...fd,
        field: {
          ...fd.field,
          data: {
            ...fd.field?.data,
            [id]: initialData,
          },
        },
      })
    }
  }, [id, rows, fd, maxRows, columns])

  // Check if a row is empty
  const isRowEmpty = (row) => {
    if (!row) return true
    return columns.every((col) => {
      const value = row[col.id]
      return value === undefined || value === null || value === "" || value === false
    })
  }

  // Remove the last visible row
  const removeRow = () => {
    if (visibleRows > 1) {
      setVisibleRows(visibleRows - 1)
    }
  }

  // Add a new visible row
  const addRow = () => {
    if (visibleRows < maxRows) {
      setVisibleRows(visibleRows + 1)
    }
  }

  // Update a cell value
  const updateCell = (rowIndex, columnId, value) => {
    if (!fd?.setFormData) return

    const currentRows = fd?.field?.data?.[id] || []
    const updatedRows = [...currentRows]

    if (!updatedRows[rowIndex]) {
      updatedRows[rowIndex] = { _rowId: \`row_\${rowIndex}\` }
    }
    updatedRows[rowIndex] = {
      ...updatedRows[rowIndex],
      [columnId]: value,
    }

    fd.setFormData({
      ...fd,
      field: {
        ...fd.field,
        data: {
          ...fd.field?.data,
          [id]: updatedRows,
        },
      },
    })
  }

  const remaining = maxRows - visibleRows

  const getSourceFieldId = (rowIndex, columnId) => {
    return sourceFieldIdsByRow?.[rowIndex]?.[columnId]
      || sourceFieldIds[columnId]
      || undefined
  }

  // Always create display rows based on visibleRows count
  // This ensures the table renders even before data is initialized
  const displayRows = []
  for (let i = 0; i < visibleRows; i++) {
    if (rows && rows[i]) {
      displayRows.push(rows[i])
    } else {
      // Create empty row placeholder
      const emptyRow = { _rowId: \`row_\${i}\` }
      columns.forEach(col => {
        emptyRow[col.id] = col.type === "checkbox" ? false : ""
      })
      displayRows.push(emptyRow)
    }
  }

  // Styles
  const containerStyle = showBackground ? {
    padding: "16px",
    border: \`1px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
    borderRadius: "8px",
    backgroundColor: isDarkMode ? "#1f1f1f" : "#fafafa",
  } : {}

  const tableContainerStyle = {
    overflowX: "auto",
    border: \`1px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
    borderRadius: "4px",
  }

  const tableStyle = {
    width: "100%",
    borderCollapse: "collapse",
    fontSize: "14px",
  }

  const headerRowStyle = {
    backgroundColor: isDarkMode ? "#2a2a2a" : "#f5f5f5",
  }

  const headerCellStyle = {
    padding: "12px",
    textAlign: "left",
    borderBottom: \`2px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
    fontWeight: 600,
  }

  const rowNumberHeaderStyle = {
    ...headerCellStyle,
    width: "60px",
    textAlign: "center",
  }

  const bodyCellStyle = {
    padding: "8px",
    borderBottom: \`1px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
    verticalAlign: "middle",
  }

  const rowNumberCellStyle = {
    padding: "12px",
    fontWeight: 500,
    backgroundColor: isDarkMode ? "#2a2a2a" : "#fafafa",
    textAlign: "center",
    borderBottom: \`1px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
    verticalAlign: "middle",
  }

  // Render cell input based on column type
  const renderCellInput = (row, rowIndex, column) => {
    const value = row?.[column.id]

    switch (column.type) {
      case "number":
        return (
          <Numeric
            inline
            buttonControls
            value={value?.toString() || "0"}
            onChange={(newValue) => updateCell(rowIndex, column.id, newValue ? parseFloat(newValue) : 0)}
            spinButtonProps={{
              min: column.min ?? 0,
              max: column.max ?? 999999,
              step: column.step ?? 1,
            }}
          />
        )

      case "date":
        return (
          <DateSelect
            inline
            value={value || ""}
            onChange={(newValue) => updateCell(rowIndex, column.id, newValue || "")}
            placeholder={column.placeholder || "Select date"}
          />
        )

      case "dropdown":
        return (
          <SimpleCodeSelect
            inline
            optionList={column.options || []}
            value={value ? { code: value, display: value } : undefined}
            onChange={(coding) => updateCell(rowIndex, column.id, coding?.code || "")}
            placeholder={column.placeholder || "Select..."}
          />
        )

      case "checkbox":
        return (
          <OptionChoice
            inline
            displayStyle="checkmark"
            value={value}
            onChange={(e, checked) => updateCell(rowIndex, column.id, !!checked)}
          />
        )

      case "text":
      default:
        return (
          <TextArea
            inline
            value={value || ""}
            onChange={(e, newValue) => updateCell(rowIndex, column.id, newValue || "")}
            placeholder={column.placeholder || ""}
          />
        )
    }
  }

  return (
    <div style={containerStyle}>
      {label && (
        <div style={{ marginBottom: "12px" }}>
          <Label styles={{ root: { fontSize: "16px", fontWeight: 600 } }}>
            {label}
          </Label>
        </div>
      )}

      <div style={tableContainerStyle}>
        <table style={tableStyle}>
          <thead>
            <tr style={headerRowStyle}>
              {showRowNumbers && (
                <th style={rowNumberHeaderStyle}>#</th>
              )}
              {columns.map((col) => (
                <th
                  key={col.id}
                  style={{
                    ...headerCellStyle,
                    minWidth: col.width || "auto",
                  }}
                  data-source-field-id={sourceFieldIds[col.id] || undefined}
                >
                  {col.title || col.id}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {displayRows.map((row, idx) => {
              const isEmpty = isRowEmpty(row)
              const canDelete = visibleRows > 1 && (allowDeleteNonEmpty || isEmpty)
              const isLastRow = idx === visibleRows - 1

              return (
                <tr key={row?._rowId || \`row_\${idx}\`}>
                  {showRowNumbers && (
                    <td style={rowNumberCellStyle}>
                      <Stack horizontal verticalAlign="center" horizontalAlign="center" tokens={{ childrenGap: 4 }}>
                        <Text>{idx + 1}</Text>
                        {isLastRow && canDelete && (
                          <IconButton
                            iconProps={{ iconName: "Delete" }}
                            title="Remove row"
                            onClick={removeRow}
                            styles={{
                              root: {
                                width: 24,
                                height: 24,
                                color: isDarkMode ? "#ff6b6b" : "#d32f2f",
                              },
                              icon: {
                                fontSize: 14,
                                color: isDarkMode ? "#ff6b6b" : "#d32f2f",
                              },
                            }}
                          />
                        )}
                      </Stack>
                    </td>
                  )}
                  {columns.map((col) => (
                    <td key={col.id} style={bodyCellStyle} data-source-field-id={getSourceFieldId(idx, col.id)}>
                      {renderCellInput(row, idx, col)}
                    </td>
                  ))}
                </tr>
              )
            })}
          </tbody>
        </table>
      </div>

      {remaining > 0 && (
        <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 12 }} style={{ marginTop: "12px" }}>
          <DefaultButton
            text={addButtonText}
            onClick={addRow}
            styles={{
              root: {
                border: "none",
                backgroundColor: "transparent",
                padding: "0 8px",
              },
              label: {
                fontWeight: 400,
              },
            }}
          />
          <Text style={{ fontSize: "14px", color: isDarkMode ? "#a0a0a0" : "#666666" }}>
            {remaining} more row{remaining !== 1 ? "s" : ""} available
          </Text>
        </Stack>
      )}
    </div>
  )
}

/**
 * Schema definition for EditableTable data
 */
const EditableTableSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      _rowId: { type: "string" },
    },
    additionalProperties: true,
  },
}

/**
 * Helper to create column definitions
 */
const createTableColumns = (columnDefs) => {
  return columnDefs.map((def) => ({
    id: def.id,
    title: def.title || def.id,
    type: def.type || "text",
    width: def.width,
    placeholder: def.placeholder,
    options: def.options,
    min: def.min,
    max: def.max,
    step: def.step,
  }))
}
`,
  './EducationHistory/index.jsx': `/**
 * Displays the patient's educational history as recorded in the chart.
 */
const EducationHistory = ({
  id = "educations",
  label = "Education history",
  selectionType = "none",
  selectText = "Select relevent education",
  ...props
}:ListSelectionProps) => {

  return (
    <ListSelection
      {...{id, label, selectText, selectionType, columns: educationHistorycolumns}}
      {...props}
    />
  )
}

const educationHistorycolumns: ColumnSelection = [
  {
    id: "educationId",
    type: "key",
  },
  {
    title: "Start",
    id: "startDate",
    type: "date",
  },
  {
    title: "Stop",
    id: "stopDate",
    type: "date",
  },
  {
    title: "Educational Institution",
    id: "educationalInstitution",
    type: "code",
    size: "medium",
  },
  {
    title: "Level of Education",
    id: "educationLevel",
    type: "code",
  },
]

const EducationHistoryFields = "educationId startDate stopDate educationalInstitution { code display system } educationLevel { code display system }"
`,
  './Ethnicity/index.jsx': `
const Ethnicity = props => {
  return (
    <SimpleCodeSelect
      fieldId='ethnicity'
      label='Ethnicity'
      readOnly
      codeSystem="CDC-RACE"
      optionList={firstNationsEthnicityReferenceSet}
      {...props}
    />
  )
}

const firstNationsEthnicityReferenceSet = [
  { code: "91", display: "First Nations" },
  { code: "92", display: "Inuit" },
  { code: "93", display: "Metis" },
]

const firstNationEthnicityCodes = firstNationsEthnicityReferenceSet.map(e=>e.code)
`,
  './FirstNationsStatus/index.jsx': `

const FirstNationsStatus = () => {

  const [fd] = useActiveData()
  const hasReserveName = !!fd.field.data.reserveName

  useOnRefresh((sd,fd) => {
    if (sd.webform?.isDraft!=="N") {

      // Reserve name is coded as a connected resource in MOIS
      const connections = sd.patient?.connectedResources ?? []
      const reserveConnection = connections.find(c => (c.connectionType.code==="FNRESERVE"))
      const reserveName = reserveConnection?.name || null

      // ethnicity is recorded in the raceN fields, we use the "SELF" race that
      // is a first nations CDC race code, If no self recorded, then the first mother or father race.
      const races = [sd.patient?.race3, sd.patient?.race2, sd.patient?.race1]
      let ethnicity = { code: null, display: null, system: "CDC-RACE"}
      let selfId = { code: "U", display: "Unknown", system: "AIHS-YESNOUNKNOWN"}
      for (const race of races) {
        if (!race) continue
        if (race.type==="SELF" && firstNationEthnicityCodes.includes(race.code)) {
          ethnicity = { code: race.code, display: race.display, system: race.system }
          if (race.isSelfIdentified!=null) {
            selfId = race.isSelfIdentified
              ? { code: "Y", display: "Yes", system: "AIHS-YESNOUNKNOWN"}
              : { code: "N", display: "No", system: "AIHS-YESNOUNKNOWN"}
          }
          break // Stop looking if self
        } else if (firstNationEthnicityCodes.includes(race.code)) {
          ethnicity = { code: race.code, display: race.display, system: race.system }
          if (race.isSelfIdentified!=null) {
            selfId = race.isSelfIdentified
              ? { code: "Y", display: "Yes", system: "AIHS-YESNOUNKNOWN"}
              : { code: "N", display: "No", system: "AIHS-YESNOUNKNOWN"}
          }
          continue // In case "self" is set
        }
      }

      fd.setFormData(produce(draft => {
        draft.field.data.firstNationStatus = sd.patient?.firstNationStatus
        draft.field.data.reserveName = reserveName
        draft.field.data.ethnicity = ethnicity
        draft.field.data.ethnicitySelfIDed = selfId
      }))
    }
  })

  return (
    <>
      <SimpleCodeSelect
        id='firstNationStatus'
        readOnly
        moisModule="DEMOGRAPHICS"
        label='First Nations Status'
        placeholder="No record in Demographics - Patient detail"
        conditionalCodes={["Status Indian","Non-status Indian"]}
      >
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          fieldId='ethnicitySelfIDed'
          label='Self identified'
          optionSize="small"
          readOnly
        />
        <Ethnicity />
      </SimpleCodeSelect>

      <SimpleCodeChecklist
        fieldId="livingOnReserve"
        label="Living on Reserve"
        codeSystem="AIHS-YESNOUNKNOWN"
        size="large"
        optionSize="small"
        optionList={[
          { key: "Y", text: "Predominantly lives on reserve"},
          { key: "N", text: "Predominantly lives off reserve"},
          { key: "U", text: "Unknown / Not Asked"},
        ]}
        conditionalCodes={["Y"]}
      >
        <TextArea
          fieldId="reserveName"
          label="Reserve Name"
          placeholder="Please enter a connection in MOIS as follows:"
          moisModule="DEMOGRAPHICS"
          readOnly
        />
        {!hasReserveName && 
          <Markdown source={\`
- Connection Role: **FNRESERVE**
- Connection Resource: **Organization (Ext)**
- Connection: **Reserve name**
          \`} />
        }
      </SimpleCodeChecklist>
    </>
  )
}

const firstNationsStatusPatientFields = \`
connectedResources {connectionId connectionType { code display system } name startDate stopDate}
firstNationStatus { code display system }
race1 {code display isSelfIdentified system type }
race2 {code display isSelfIdentified system type }
race3 {code display isSelfIdentified system type }
\`

const firstNationsStatusSchema = {
  firstNationStatus:  { $ref: "#/definitions/coding" },
  ethnicitySelfIDed:  { $ref: "#/definitions/ynu" },
  ethnicity:          { $ref: "#/definitions/coding" },
  livingOnReserve:    { $ref: "#/definitions/ynu" },
  reserveName:        { type: ["string","null"] },
}
`,
  './Goals/index.jsx': `
// Handle 2.25.12 case where Allergies is a predefined component
if (typeof Goals==="undefined") {
  window.Goals = null
}

/**
 * Display a list of patient goals for selection
 */
Goals = ({
  id = "goals",
  label,
  selectionType = "none",
  selectText="Select goals",
  ...props
}:ListSelectionProps) => {

  return (
    <ListSelection
      {...{id, label, selectText, selectionType, columns: goalColumns}}
      {...props}
    />
  )
}

const goalColumns: ColumnSelection = [
  {
    id: "goalId",
    type: "key",
  },
  {
    title: "Date",
    id: "startDate",
    type: "date",
  },
  {
    id: "endDate",
    type: "hidden",
  },
  {
    title: "Goal",
    id: "goal",
    type: "string",
  },
  {
    id: "expectedOutcome",
    type: "hidden",
  },
  {
    title: "Detail",
    id: "detail",
    type: "string",
    size: "large",
  },
]

const GoalsFields = "goalId startDate endDate goal expectedOutcome detail"
`,
  './HFC_PT_ASMT_PatientAssessment/index.jsx': `

const HFC_PT_ASMT_PatientAssessment = () => {

    const [phq9vis,setphq9vis] = React.useState(false)
    const [fd,setFd] = useActiveData();
    const sd = useSourceData();
    const [obsInFocus,setObsInFocus]=React.useState([]);

    /* const items = sourceItems?.filter(filterPred)?.map(finalSourceMap)?.sort(listCompare) ?? [] */
    const histcols = [
        {
            id:"observationId",
            type:"key"
        },
        {
            title:"Collected Date",
            id:"collectedDateTime",
            type:"string",
            onColumnMap:(item)=>item.collectedDateTime.replace("T"," "),
            size:"small"
        },
        {
            title:"Code",
            id:"observationCode",
            type:"string",
            size:"tiny"
            
        },
        {
            title:"Test name",
            id:"description",
            type:"string",
            size:"medium"
            
        },
        {
            title:"Value",
            id:"vwunits",
            type:"string",
            onColumnMap:(item)=>\`\${item.value??'-'} \${item.units}\`,
            size:"tiny"
        },
    
    ]

    const finalSourceMap = MoisFunction.mapSourceToActive(histcols)

    const _onupdate = (event,field) => {
        const inputValue = event.target.value;
        
        let formattedValue;
        let parts;
        
        if (field.includes("BP")){
            formattedValue = inputValue.replace(/[^0-9/]/g, '');
            parts = formattedValue.split('/').length;
        } else {
            formattedValue = inputValue.replace(/[^0-9.]/g, '');
            parts = formattedValue.split('.').length;
        }
    
        if (parts<=2) {
            
            const fieldData = {
                ...fd.field.data,
                [\`\${field}\`]:\`\${formattedValue}\`
            }

            handleChange(fieldData);
        }
    };
    
    
    
   /*  const _onupdate = (con,field) =>{
        const curvalue = con.target.value
        const newval =con.nativeEvent.data


        


        
        if (!isNaN(curvalue) || ((newval ==="." && !field.includes("BP"))&&!curvalue.includes("."))||((field.includes("BP") && newval==="/") &&!curvalue.includes("/"))) {
            


                const fieldData = {
                    ...fd.field.data,
                    [\`\${field}\`]:\`\${curvalue}\`
                }

                handleChange(fieldData);
            
        }
    } */

    const handleChange = (fieldData) =>{
       /* props.handleStateChange(fieldData); */
       setFd({
        ...fd,
        field: {
        ...fd.field,
        data: fieldData,
        }})
    }
    
    


    /* useOnLoad((sd,fd)=>{
        const fieldData = {
            ...fd.field.data,
            PHQ9Questionnaire:{...PHQ9Quest}
        }

        fd.field.data.PHQ9Questionnaire?
            null
        :
           handleChange(fieldData); 
    })
 */
    

    const PHQ9answers ={
        "0":"Not at all",
        "1":"Several Days",
        "2":"More than haf the days",
        "3":"Nearly Every Day"
    }
    



    const toggleSelect=(qindex,value) => {

        if (fd?.uiState?.sections?.[0]?.isComplete === false) {
            const questionairre = fd.field.data.PHQ9Questionnaire;

            let TotalVal9 = null;
            let TotalVal2 = null
            /* console.log(\`mapping something for \${qindex} with value \${value}\`); */

            questionairre.Questions[qindex].selectedAnswer.value = value;
            questionairre.Questions[qindex].selectedAnswer.description = value != null?PHQ9answers[\`\${qindex}\`]:null;
            questionairre.Questions[qindex].selectedAnswer.fieldId= value != null?\`PHQ9Q\${qindex+1}\${value}\`:null;

            const checkarr9 = questionairre.Questions.filter(obj=> obj.selectedAnswer.value === null);
            const checkarr2 = questionairre.Questions.filter(obj=> obj.questionIndex <= 2 && obj.selectedAnswer.value === null)

            if (checkarr2.length === 0){

                TotalVal2 = 0;

                questionairre.Questions.filter(obj=>obj.questionIndex <= 2).forEach(obj => TotalVal2 += parseInt(obj.selectedAnswer.value))
                
            }
                    
            if (checkarr9.length === 0 && TotalVal2 >= 3){

                TotalVal9 = 0;

                questionairre.Questions.forEach(obj => TotalVal9 += parseInt(obj.selectedAnswer.value))
                
            }
                    

            questionairre["PHQ9Score"]=TotalVal9;
            questionairre["PHQ2Score"]=TotalVal2;

            const fieldData = {
                ...fd.field.data,
                PHQ9Questionnaire:{...questionairre}
            }

            handleChange(fieldData)
        }
    }

    const symptomsTable =[
        {display:"Fatigue",loincCode:"28100-6", code:"21250",fieldId:"ptAsFatigue"},
        {display:"SOB/Dyspnea",loincCode:"45705-1", code:"45345",fieldId:"ptAsSOB"},
        {display:"PND",loincCode:null, code:"A12312",fieldId:"ptAsPND"},
        {display:"Orthopnea",loincCode:"82951-5", code:"X0104",fieldId:"ptAsOrthopnea"},
        {display:"Palpitations",loincCode:null, code:"A12314",fieldId:"ptAsPalpitations"},
        {display:"Light Headedness",loincCode:null, code:"A12315",fieldId:"ptAsLightHeadedness"},
        /* {display:"GI Complaints",loincCode:null, code:"X0105",fieldId:"ptAsGIComplaints"},
        {display:"Limits to ADL's",loincCode:null, code:"X0106",fieldId:"ptAsADLLimits"}, */
        {display:"Chest Pain/Angina",loincCode:"58529-3", code:"58250",fieldId:"ptAsChestPainAngina"},
    ]
    
    const swellingTable=[
        {display:"Legs",loincCode:"",code:"A12318",fieldId:"ptAsLegSwelling"},
        {display:"Abdomen",loincCode:"",code:"X0107",fieldId:"ptAsAbdomenSwelling"},
    ]
    
    const latestCollectedFirst = (a, b) => {
        const acol = a.collectedDateTime ? a.collectedDateTime : "2100-01-01"
        const bcol = b.collectedDateTime ? b.collectedDateTime : "2100-01-01"
        return -asciiCompare(acol, bcol)
      }
      
    const asciiCompare = (a, b) => (a > b ? 1 : a < b ? -1 : 0)
    
    return (
        <>
            <div className="showonprint">
                <NameBlock />
            </div>
            <Title>PATIENT ASSESSMENT</Title>
            <SubTitle label="Medication Reconciliation" />
            <SimpleCodeChecklist
                label="Medication Reconciliation Completed?"
                fieldId = "ptAsMedRec"
                codeSystem="MOIS-YESNO"
                labelPosition="left"
                optionSize="tiny"
                moisModule="LONG TERM MEDS"
            />
            <TextArea 
                fieldId="ptSumMedNotes"
                multiline
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                defaultValue="Completed with clients Pharmanet med list and clients medications brought into clinic"
            />

            <SubTitle label ="History: Since Last Visit (Check all that Apply)" />
            <SimpleCodeChecklist
                label = "Doctor visits outside of clinic?"
                fieldId="ptAsDocVisits"
                codeSystem="MOIS-YESNO"
                labelPosition="left"
                optionSize="tiny"
                conditionalCodes={["Y"]}
                >
                <TextArea
                    label = "# of visits"
                    fieldId="ptAsDocVisitsCount"
                    labelPosition="left"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    size="tiny"
                />
                <TextArea
                    label="Reason(s)"
                    labelPosition="left"
                    fieldId="ptAsDocVisitsReason"
                    multiline
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                />
            </SimpleCodeChecklist>
            <SimpleCodeChecklist
                label = "Emergency Room (ER) visits?"
                fieldId="ptAsERVisits"
                codeSystem="MOIS-YESNO"
                labelPosition="left"
                optionSize="tiny"
                conditionalCodes={["Y"]}
            >
                <TextArea
                    label = "# of visits"
                    fieldId="ptAsERVisitsCount"
                    labelPosition="left"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    size="tiny"
                />
                <TextArea
                    label="Reason(s)"
                    labelPosition="left"
                    fieldId="ptAsERVisitsReason"
                    multiline
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                />
            </SimpleCodeChecklist>
            
            <SimpleCodeChecklist
                label = "Hospitalizations?"
                fieldId="ptAsHospitalVisits"
                codeSystem="MOIS-YESNO"
                labelPosition="left"
                optionSize="tiny"
                conditionalCodes={["Y"]}
            >
                <TextArea
                    label ="# days in Hospital"
                    labelPosition="left"
                    fieldId="ptAsHospitalVisitsCount"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    size="tiny" 
                />
                <TextArea
                    label="Reason(s)"
                    labelPosition="left"
                    fieldId="ptAsHospitalVisitsReason"
                    multiline
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                />
            </SimpleCodeChecklist>
           
            <SubTitle label = "Cardiac Device"/>
            <SimpleCodeChecklist 
                    label="Type of Device"
                    fieldId="ptSumCDNotesChecklist"
                    optionList={[
                        {key:"None",text:"None"},
                        {key:"ICD",text:"ICD"},
                        {key:"CRT-D",text:"CRT-D"},
                        {key:"CRT-P",text:"CRT-P"},
                        {key:"Pacemaker",text:"Pacemaker"}
                    ]}
                    optionSize="small"
                />
            <SimpleCodeChecklist
                label="Shocks"
                labelPosition="left"
                codeSystem="MOIS-YESNO"
                fieldId="ptAsShocks" 
                optionSize="tiny"
                conditionalCodes={["Y"]}>
                    <TextArea
                        label = "# of Shocks?"
                        labelPosition="left"
                        labelProps={{style:{minWidth:"0px"}}}
                        fieldId="ptAsShocksCount"/>
            </SimpleCodeChecklist>
            
            <Heading label="Physical Exam" labelStyles={{style:{fontWeight:"600",borderBottom:"1px solid black", width:"100%"}}}>
                <div className="addapt"><Heading text="If you need to access measures in MOIS you can click here" moisModule="MEASUREMENTS" /></div>
                <TextArea
                    label="Heart Rate (/min)"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    fieldId="ptAsHR"
                    size="small"
                    textFieldProps={{suffix:"bpm"}}
                    onChange={(e)=>_onupdate(e,"ptAsHR")}
                />

                <TextArea
                    label="Home Heart Rate (/min)"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    fieldId="ptAsHomeHR"
                    size="small"
                    textFieldProps={{suffix:"bpm"}}
                    onChange={(e)=>_onupdate(e,"ptAsHomeHR")}
                />
                
                <TextArea
                    label="O2 SAT (%)"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    fieldId="ptAsO2"
                    size="small"
                    customStyles ={{style:{pageBreakInside:"avoid"}}}
                    textFieldProps={{suffix:"%"}}
                    onChange={(e)=>_onupdate(e,"ptAsO2")}
                />
                
                <TextArea
                    label="Jugular Veinous Pulse (JVP) (Cm):"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    fieldId="ptAsJVP"
                    size="small"
                    customStyles ={{style:{pageBreakInside:"avoid"}}}
                    textFieldProps={{suffix:"cm"}}
                    onChange={(e)=>_onupdate(e,"ptAsJVP")}
                />
               
                <TextArea
                    label="Waist (Cm):"
                    /* labelProps={{style:{minWidth:"0px"}}} */
                    fieldId="ptAsWaist"
                    size="small"
                    textFieldProps={{suffix:"cm"}}
                    onChange={(e)=>_onupdate(e,"ptAsWaist")}
                />
            {/* </Heading> */}
          {/*   <div style={{width:"100%",borderBottom:"1px solid black"}}>
                <Heading label="Vital Signs" labelStyles={{style:{fontWeight:"600"}}} moisModule="MEASUREMENTS" />
            </div> */}
{/*             <Heading label="Vital Signs" labelStyles={{style:{fontWeight:"600",borderBottom:"1px solid black", width:"100%"}}} moisModule="MEASUREMENTS" /> */}
            {/* <Heading> */}
                {/* <Mois.ObservationPanel.observations 
                    filterPred={Boolean(obsInFocus)?(item)=>item.observationCode === obsInFocus:()=>true} 
                    listCompare={latestCollectedFirst} 
                    detailsListProps={{listProps:{renderCount:Boolean(obsInFocus)?5:0}}} 
                    label="Past 5 Observations:"
                    
                /> */}
                <div className="hideonprint">
                    {obsInFocus.length>0?
                    
                        <ListSelection 
                            columns={histcols}
                            /* id="observations" */
                            /* items={sd.patient.observations} */
                            items={sd.patient.observations.filter(item=>obsInFocus.length===1? item.observationCode === obsInFocus[0] && item.comment !== "As taken at home": item.observationCode === obsInFocus[0] && item.comment === obsInFocus[1]).map(finalSourceMap)}
                            //filterPred={Boolean(obsInFocus)?(item)=>item.observationCode === obsInFocus:()=>true}
                            listCompare={latestCollectedFirst} 
                            detailsListProps={{listProps:{renderCount:obsInFocus.length > 0 ?5:0}}}
                            labelProps={{style:{maxWidth:"100%"}}}
                            label={\`Past 5 Observations of selected \${obsInFocus.length ===1? 'CLINIC':'HOME'} measure:\`}
                        
                        />
                    :
                        <span style={{fontWeight:"bold"}}>Please select a Weight or BP measure from below to see history</span>
                    }
                    {/* Filter predicate is not regenerating what items to filter to. Will check with Brian about this, but may need to do custom ListSelection where items used are passed back from a function. argh */}
                </div>
                <div style={{display:"flex",justifyContent:"space-between",borderBottom:"1px solid lightgray", borderTop:"1px solid lightgray",marginTop:"20px"}}>
                    <div style={{maxWidth:"40%",width:"40%"}}>
                        <div className="hideonprint">        
                            <TextArea
                                label ="Weight (Kg):"
                                fieldId="ptAsWeight"
                                labelProps={{style:{minWidth:"80px"}}}
                                textFieldProps={{suffix:"kg",onFocus:()=>setObsInFocus(["22732"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsWeight")}
                                
                            />
                            <TextArea
                                label ="BP Sitting:"
                                fieldId="ptAsBPSitting"
                                labelProps={{style:{minWidth:"80px"}}}
                                textFieldProps={{onFocus:()=>setObsInFocus(["61826"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsBPSitting")}
                            />
                            <TextArea
                                label ="BP Lying:"
                                fieldId="ptAsBPLying"
                                labelProps={{style:{minWidth:"80px"}}}
                                textFieldProps={{onFocus:()=>setObsInFocus(["61828"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsBPLying")}
                            />
                            <TextArea
                                label ="BP Standing:"
                                fieldId="ptAsBPStanding"
                                labelProps={{style:{minWidth:"80px"}}}
                                textFieldProps={{onFocus:()=>setObsInFocus(["61827"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsBPStanding")}
                            /> 
                        </div>
                        {/* <div className="showonprint">        
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="Weight (Kg):"
                                fieldId="ptAsWeight"
                                labelProps={{style:{minWidth:"80px"}}}
                                textFieldProps={{suffix:"kg"}}
                            />
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="BP Sitting:"
                                fieldId="ptAsBPSitting"
                                labelProps={{style:{minWidth:"80px"}}}
                            />
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="BP Lying:"
                                fieldId="ptAsBPLying"
                                labelProps={{style:{minWidth:"80px"}}}
                            />
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="BP Standing:"
                                fieldId="ptAsBPStanding"
                                labelProps={{style:{minWidth:"80px"}}}
                            /> 
                        </div> */}
                    </div>
                    <div style={{maxWidth:"40%",width:"40%"}}>
                        <div className="hideonprint">
                            <TextArea
                                label ="Home Weight (Kg):"
                                fieldId="ptAsHomeWeight"
                                labelProps={{style:{minWidth:"123px"}}}
                                textFieldProps={{suffix:"kg",onFocus:()=>setObsInFocus(["22732","As taken at home"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsHomeWeight")}
                            />
                            <TextArea
                                label ="Home BP Sitting:"
                                fieldId="ptAsHomeBPSitting"
                                labelProps={{style:{minWidth:"123px"}}}
                                textFieldProps={{onFocus:()=>setObsInFocus(["61826","As taken at home"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsHomeBPSitting")}
                                
                            />
                            <TextArea
                                label ="Home BP Lying:"
                                fieldId="ptAsHomeBPLying"
                                labelProps={{style:{minWidth:"123px"}}}
                                textFieldProps={{onFocus:()=>setObsInFocus(["61828","As taken at home"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsHomeBPLying")}

                            />
                            <TextArea
                                label ="Home BP Standing:"
                                fieldId="ptAsHomeBPStanding"
                                labelProps={{style:{minWidth:"123px"}}}
                                textFieldProps={{onFocus:()=>setObsInFocus(["61827","As taken at home"]), onBlur:()=>setObsInFocus([])}}
                                onChange={(e)=>_onupdate(e,"ptAsHomeBPStanding")}
                            />
                        </div>
                        {/* <div className="showonprint">
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="Home Weight (Kg):"
                                fieldId="ptAsHomeWeight"
                                labelProps={{style:{minWidth:"123px"}}}
                                textFieldProps={{suffix:"kg"}}
                            />
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="Home BP Sitting:"
                                fieldId="ptAsHomeBPSitting"
                                labelProps={{style:{minWidth:"123px"}}}
                            />
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="Home BP Lying:"
                                fieldId="ptAsHomeBPLying"
                                labelProps={{style:{minWidth:"123px"}}}
                            />
                            <TextArea
                                customStyles={{fieldGroup:{maxWidth:"40%"}}}
                                label ="Home BP Standing:"
                                fieldId="ptAsHomeBPStanding"
                                labelProps={{style:{minWidth:"123px"}}}
                            />
                        </div> */}
                    </div>
                </div>
                <TextArea
                    label="Lung Sounds:"
                    fieldId="ptAsLungs"
                    /* labelProps={{style:{minWidth:"0px"}}}                */
                />
                
                <div style={{display:"flex",flexDirection:"row",width:"100%"}}>
                <TextArea
                    label = "Daily Fluid Intake (best estimate):"
                    /* labelProps={{style:{minWidth:"0px"}}} */ 
                    fieldId="ptAsFluidIntake"
                    size="small"
                    onChange={(e)=>_onupdate(e,"ptAsFluidIntake")}
                />
                <SimpleCodeSelect
                    fieldId="ptAsFluidIntakeVol"
                    size="100px"
                    optionList={[
                        {key:"L",text:"Litres"},
                        {key:"mL",text:"Mililitres"},
                    ]}
                />
                </div>
                
                <SimpleCodeChecklist 
                    label="Drinks Alcohol?"
                    codeSystem ="MOIS-YESNO"
                    fieldId="ptAsAlcQuest"
                    conditionalCodes={["Y"]}
                    optionSize="tiny"
                >
                    <table>
                        <tr>
                            <td style={{fontSize: "14px", fontWeight: "600", width:"20%", minWidth:"200px"}}># of alcoholic drinks?</td>
                            <td style={{width:"5%"}}><TextArea fieldId="ptAsAlcoholCount" size="small" labelProps={{style:{minWidth:"0px"}}}/></td>
                            <td style={{width:"10%",textAlign:"center"}}>Per</td>
                            <td style={{width:"25%"}}><SimpleCodeSelect optionList={[
                                {key:"day",text:"Day"},
                                {key:"week",text:"Week"},
                                ]}
                                showOtherOption
                                fieldId="ptAsAlcoholFreq"
                            /></td>
                        </tr>
                    </table>
                </SimpleCodeChecklist>

                <SimpleCodeChecklist 
                    label="Smokes Cigarettes?"
                    codeSystem ="MOIS-YESNO"
                    fieldId="ptAsCigQuest"
                    conditionalCodes={["Y"]}
                    optionSize="tiny"
                >
                    <table>
                        <tr>
                            <td style={{fontSize: "14px", fontWeight: "600", width:"20%", minWidth:"210px"}}># of cigarettes smoked?</td>
                            <td style={{width:"5%"}}><TextArea fieldId="ptAsCigCount" size="tiny" labelProps={{style:{minWidth:"0px"}}}/></td>
                            <td style={{width:"5%", maxWidth:"100px"}}><SimpleCodeSelect optionList={[
                                {key:"single",text:"Individual"},
                                {key:"pack20",text:"Pack (20)"},
                                {key:"pack25",text:"Pack (25)"},
                                ]}
                                fieldId="ptAsCigType"
                                size={{width:"100px"}}
                                /></td>
                            <td style={{width:"10%", textAlign:"center"}}>Per</td>
                            <td style={{width:"25%"}}><SimpleCodeSelect optionList={[
                                {key:"day",text:"Day"},
                                {key:"week",text:"Week"},
                                ]}
                                showOtherOption
                                fieldId="ptAsCigFreq"
                            /></td>
                        </tr>
                    </table>
                </SimpleCodeChecklist>
               
                <SimpleCodeChecklist 
                    label="Smokes Marijuana?"
                    codeSystem ="MOIS-YESNO"
                    fieldId="ptAsMJQuest"
                    conditionalCodes={["Y"]}
                    optionSize="tiny"
                >
                    <TextArea 
                        fieldId="ptAsMJQuestComments"
                        label="Comments:"
                        multiline
                        textFieldProps={{autoAdjustHeight:true,resizable:false}}
                    />
                </SimpleCodeChecklist>

                <SimpleCodeChecklist 
                    label="Illicit Drug Use?"
                    codeSystem ="MOIS-YESNO"
                    fieldId="ptAsIDQuest"
                    conditionalCodes={["Y"]}
                    optionSize="tiny"
                >
                    <TextArea 
                        fieldId="ptAsIDQuestComments"
                        label="Comments:"
                        multiline
                        textFieldProps={{autoAdjustHeight:true,resizable:false}}
                    />
                </SimpleCodeChecklist>


                <TextArea 
                    label="Additional Physical Exam Comments:"
                    labelPosition="top"
                    multiline
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                    fieldId="ptASAdditonalPhysicalExamNotes"
                />
            </Heading> 

            <SubTitle label="Symptoms" />
            <table style={{width:"100%",border:"1px solid darkgrey", borderCollapse:"collapse",pageBreakInside:"avoid" }}>
                <thead style={border}>
                    <tr>
                        <th style={{textAlign:"center",width:"20%"}}>SYMPTOMS</th>
                        <th style={{textAlign:"center",width:"20%"}}>STATUS</th>
                        <th style={{textAlign:"center"}}>NOTES</th>
                    </tr>
                </thead>
                <tbody>
                    {symptomsTable.map((obs)=>{
                              return (
                                <TableMeasureRow label={obs.display} testId={obs.code} fieldId={obs.fieldId}/>
                              )
                            })
                    }
                
                    <tr style={{borderTop:"1px solid darkgrey"}}>
                        <td colSpan={3}>
                            <div style={{width:"100%",display:"flex", flexDirection:"row"}}>
                            <div style={{width:"40%", paddingLeft:"5px"}}>
                                <TextArea 
                                    label="# of pillows under the head normally:"
                                    labelPosition="left"
                                    labelProps={{style:{minWidth:"0px"}}}
                                    size="tiny"
                                    fieldId="ptAsNormPillowCount" 
                                />
                            </div>
                            <div style={{display:"table-cell", width:"30%", paddingLeft:"20px"}}>
                                <TextArea 
                                    label="Current:"
                                    labelPosition="left"
                                    labelProps={{style:{minWidth:"0px"}}} 
                                    fieldId="ptAsCurrPillowCount" 
                                    size="tiny"
                                />
                            </div>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td colSpan={3}>
                            <TextArea
                                fieldId="ptAsNormPillowCountNotes"
                                multiline
                                textFieldProps={{autoAdjustHeight:true,resizable:false,}}
                                placeholder="Notes"
                            />
                        </td>
                    </tr>
                </tbody>


            </table>
            
            <SubTitle label="Swelling"/>
            <table style={{width:"100%",border:"1px solid darkgrey", borderCollapse:"collapse",pageBreakInside:"avoid" }}>
                <thead style={border}>
                    <tr>
                        <th style={{textAlign:"center",width:"20%"}}>SWELLING</th>
                        <th style={{textAlign:"center",width:"20%"}}>STATUS</th>
                        <th style={{textAlign:"center"}}>NOTES</th>
                    </tr>
                </thead>
                <tbody>
                    {swellingTable.map((obs)=>{
                              return (
                                <TableMeasureRow label={obs.display} testId={obs.code} fieldId={obs.fieldId}/>
                              )
                            })
                    }
                    <tr style={{borderTop:"1px solid darkgrey"}}>
                        <td style={{paddingLeft:"5px"}}>
                            Extra Diuretics
                        </td>
                        <td>
                            <SimpleCodeChecklist
                                codeSystem="MOIS-YESNO"
                                fieldId="ptAsExtraDiuretics"
                                autoHotKey
                                size="small"
                                optionSize=""
                            />
                        </td>
                        <td>
                            <TextArea
                                multiline
                                fieldId="ptAsExtraDiureticsNotes"
                                textFieldProps={{autoAdjustHeight:true,resizable:false,}}
                                labelProps={{style:{minWidth:"0px"}}}
                                placeholder="Notes"
                            />
                        </td>
                    </tr>
                </tbody>
            </table>

            <SimpleCodeChecklist
                    label="Fluid Volume Status:"
                    optionList={[
                        {key:"DRY",text:"Dry"},
                        {key:"EUVO",text:"Euvolemic"},
                        {key:"OVER",text:"Overloaded"}
                    ]}
                    fieldId="ptAsFluidVolume"
                    optionSize={{paddingRight:"10px"}}
                />
            <TextArea 
                label="Activity"
                multiline
                fieldId="ptAsFluidVolumeNotes"
                textFieldProps={{autoAdjustHeight:true,resizable:false,}}
            />

             <TextArea
                label="Clinic Frailty Score"
                /* labelProps={{style:{minWidth:"0px"}}}  */
                fieldId="ptAsClinicFrailtyScore"
            />
            <div style={{pageBreakInside:"avoid"}}>
            <SimpleCodeSelect
                label="NYHA Class:"
                fieldId="ptAsNYHAClass"
                labelPosition="left"
                codeSystem="VALUESET:NYHA.NORMATIVE.ANSWER.LIST"
                size="medium"
            />
            </div>

            <TextArea
                    label="Kansas City Questionnaire:"
                    fieldId="ptAsKCCQ"
            />
            
            <TextArea 
                label="PHQ2:"
                value={fd.field?.data?.PHQ9Questionnaire?.PHQ2Score??\`Please complete the PHQ2 Questionnaire\`}
                readOnly
                borderless
                fieldId="ptAsPHQ2"
            />
            <SubTitle label="PHQ 2 Questionnaire">
                <div className="hideonprint"><Link href="https://www.hiv.uw.edu/page/mental-health-screening/phq-2" target="_blank">PHQ2 Questionnaire reference</Link></div>
                <br/>
                <table style={{borderCollapse:"collapse",border:"1px solid black", pageBreakInside:"avoid"}}>
                    <tr style={{borderBottom:"2px solid darkgrey", backgroundColor:"lightgray",pageBreakInside:"avoid"}}>
                        <th style={{textAlign:"left", width:"60%",borderCollapse:"collapse"}}>Over the last 2 weeks, how often have you been bothered by any of the following problems?</th>
                        <th style={{textAlign:"center", width:"10%",borderCollapse:"collapse"}}>Not at all</th>
                        <th style={{textAlign:"center", width:"10%",borderCollapse:"collapse"}}>Several Days</th>
                        <th style={{textAlign:"center", width:"15%",borderCollapse:"collapse"}}>More than half days</th>
                        <th style={{textAlign:"center", width:"15%",borderCollapse:"collapse"}}>Nearly everyday</th>
                    </tr>
                    {fd.field?.data?.PHQ9Questionnaire?.Questions.map((obj)=>{
                            
                            return obj.questionIndex<= 2 ?(
                                    <tr style={{backgroundColor:\`\${obj.questionIndex%2===1?null:'#eee'}\`,pageBreakInside:"avoid"}}>
                                        <td style={{padding:"5px 7px",pageBreakInside:"avoid"}}>{\`\${obj.questionIndex}. \${obj.questionText}\`}</td>
                                        <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}0\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}0\`?"phqans":""}\`} styles={PHQ9btnstyle} text="0" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}0\`?null:0)}/></td>
                                        <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}1\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}1\`?"phqans":""}\`} styles={PHQ9btnstyle} text="1" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}1\`?null:1)}/></td>
                                        <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}2\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}2\`?"phqans":""}\`} styles={PHQ9btnstyle} text="2" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}2\`?null:2)}/></td>
                                        <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}3\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}3\`?"phqans":""}\`} styles={PHQ9btnstyle} text="3" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}3\`?null:3)}/></td>
                                    </tr>
                                    
                            ):null
                            }
                        )}
                </table>
            </SubTitle>
            
            <div style={{display:\`\${fd.field?.data?.PHQ9Questionnaire?.PHQ2Score>=3?"block":"none"}\`}}>
                <p>As the PHQ2 Score is 3 or greater, then please capture the full PHQ-9</p>
                <TextArea
                    label="PHQ9:"
                    value={fd.field?.data?.PHQ9Questionnaire?.PHQ9Score??\`Please complete the PHQ9 Questionnaire\`}
                    readOnly
                    borderless
                    fieldId="ptAsPHQ9"
                />
                
                <SubTitle label="PHQ9 Questionnaire">
                    <div className="addapt"><Link href="https://www2.gov.bc.ca/assets/gov/health/practitioner-pro/bc-guidelines/depression_patient_health_questionnaire.pdf" target="_blank">PHQ9 Questionnaire reference</Link></div>
                    <br />
                    
                    <table style={{borderCollapse:"collapse",border:"1px solid black"}}>
                        <tr style={{borderBottom:"2px solid darkgrey", backgroundColor:"lightgray",pageBreakInside:"avoid"}}>
                            <th style={{textAlign:"left", width:"60%",borderCollapse:"collapse"}}>Over the last 2 weeks, how often have you been bothered by any of the following problems?</th>
                            <th style={{textAlign:"center", width:"10%",borderCollapse:"collapse"}}>Not at all</th>
                            <th style={{textAlign:"center", width:"10%",borderCollapse:"collapse"}}>Several Days</th>
                            <th style={{textAlign:"center", width:"15%",borderCollapse:"collapse"}}>More than half days</th>
                            <th style={{textAlign:"center", width:"15%",borderCollapse:"collapse"}}>Nearly everyday</th>
                        </tr>
                        {fd.field?.data?.PHQ9Questionnaire?.Questions.map((obj)=>{
                                
                                return (
                                        <tr style={{backgroundColor:\`\${obj.questionIndex%2===1?null:'#eee'}\`,pageBreakInside:"avoid"}}>
                                            <td style={{padding:"5px 7px",pageBreakInside:"avoid"}}>{\`\${obj.questionIndex}. \${obj.questionText}\`}</td>
                                            <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}0\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}0\`?"phqans":""}\`} styles={PHQ9btnstyle} text="0" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}0\`?null:0)}/></td>
                                            <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}1\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}1\`?"phqans":""}\`} styles={PHQ9btnstyle} text="1" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}1\`?null:1)}/></td>
                                            <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}2\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}2\`?"phqans":""}\`} styles={PHQ9btnstyle} text="2" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}2\`?null:2)}/></td>
                                            <td style={{height:"1px",pageBreakInside:"avoid"}}><DefaultButton toggle checked={obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}3\`} className={\`\${obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}3\`?"phqans":""}\`} styles={PHQ9btnstyle} text="3" onClick={()=>toggleSelect(obj.questionIndex-1,obj.selectedAnswer.fieldId === \`PHQ9Q\${obj.questionIndex}3\`?null:3)}/></td>
                                        </tr>
                                )
                                }
                            )}
                    </table>
                    
                    

                </SubTitle>
               
                {(fd.field?.data?.PHQ9Questionnaire?.PHQ9Score>9||(fd.field?.data?.PHQ9Questionnaire?.Questions?.[8]?.selectedAnswer?.value>0)) ?
                    <table style={{width:"100%",backgroundColor:"#ffb6c142",pageBreakInside:"avoid",marginLeft:"2em",maxWidth:"858px"}}>
                        <tr style={{pageBreakInside:"avoid"}}>
                            <td style={{width:"21%"}}><Heading text="Inform MD?"/></td>
                            <td style={{width:"15%"}}><SimpleCodeChecklist fieldId="ptAsPHQ9InformDoc" codeSystem="MOIS-YESNO" size="small" optionSize=""/></td>
                            <td style={{width:"60%"}}><TextArea placeholder="Additional Comments" fieldId="ptAsPHQ9InformDocNotes" multiline textFieldProps={{autoAdjustHeight:true,resizable:false}} labelProps={{style:{minWidth:"0px"}}}/></td>
                        </tr>    
                    </table>
                    :
                    null
                }


                {fd.field?.data?.PHQ9Questionnaire?
                <div style={{marginLeft:"2em",maxWidth:"858px"}}> 
                    <SimpleCodeChecklist
                    fieldId="Difficulties"
                    label="If you checked off any problems, how difficult have these problems made it for you to do your work, take care of things at home, or get along with other people? "
                    section={{activeSelector:(fd)=>fd.field.data.PHQ9Questionnaire}}
                    labelPosition="top"
                    optionList={[
                        {key:"0",text:"Not Difficult at all"},
                        {key:"1",text:"Somewhat Difficult"},
                        {key:"2",text:"Very Difficult"},
                        {key:"3",text:"Extremely Difficult"}
                    ]}
                /></div>:null}
                

            </div> 
            <TextArea 
                label="PHQ2/9 Comments"
                fieldId="ptAsPHQ29comments"
                multiline
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
            />
            <table>
                <tr style={{pageBreakInside:"avoid"}}>
                    <td style={{width:"25%",verticalAlign:"text-top"}}><Heading text="Group and/or 1:1 Heart Failure Education Complete?"/></td>
                    <td style={{width:"15%"}}><SimpleCodeChecklist fieldId="ptAsGrpHFEdComplete" codeSystem="MOIS-YESNO" size="small" optionSize=""/></td>
                    <td style={{width:"60%"}}><TextArea placeholder="Additional Comments" fieldId="ptAsGrpHFEdNotes" multiline textFieldProps={{autoAdjustHeight:true,resizable:false}} labelProps={{style:{minWidth:"0px"}}}/></td>
                </tr>    
            </table>


            <TextArea 
                label="MD/NP Assessment and Orders"
                fieldId="ptAsMDNPassessmentAndOrders"
                multiline
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
            />
            
            {/* <Grid placement={\`ptAsPHQ9InformDoc  ptAsPHQ9InformDocNotes  ptAsPHQ9InformDocNotes  ptAsPHQ9InformDocNotes\`}>

                            <SimpleCodeChecklist label="Inform MD?"
                                codeSystem = "MOIS-YESNO"
                                optionSize={{paddingRight:"10px"}} 
                                fieldId="ptAsPHQ9InformDoc"
                            />
                            
                            <TextArea multiline labelProps={{style:{minWidth:"0px"}}}  fieldId="ptAsPHQ9InformDocNotes"/>
                        
                        </Grid> */}
            
            {/* <SimpleCodeChecklist
                fieldId="ptAsGrpHFEdComplete"
                codeSystem="MOIS-YESNO"
                labelProps={{style:{minWidth:"0px"}}}
                optionSize="tiny"
                labelPosition="left"
                conditionalCodes={["Y","N",null]}
            >
                <TextArea 
                    label="Additional Comments:"
                    fieldId="ptAsGrpHFEdNotes"
                    multiline
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                />
            </SimpleCodeChecklist> */}
        </>
        
        
        
        
    )
}

const PHQ9btnstyle={
    root:{
        border:"none"
        ,width:"100%"
        ,height:"100%"
        ,backgroundColor:"inherit"
        ,borderRadius:"0px"
        ,padding:"0px"
    }
    ,rootChecked:{
        backgroundColor:"lightblue"}
    ,rootHovered:{
        backgroundColor:"gainsboro"
    }
}

const border ={border:"1px solid #AAAAAA"}
const tcell = {display:"table-cell", pageBreakInside:"avoid"}

const MeasureRow = ({label, testId, fieldId}) => {
    const [fd]=useActiveData()

    return (
        <div  style={{display:"table-row", pageBreakInside:"avoid"}}>

            <div style={{...tcell,paddingLeft:"5px"}}>{label}</div>
            <div style={tcell,{textAlign:"center !important"}}>
                <SimpleCodeSelect
                    size="small"
                    optionList={[
                        {key:"Better",text:"BETTER"},
                        {key:"Same",text:"SAME"},
                        {key:"Worse",text:"WORSE"},
                        {key:"Yes",text:"YES"},
                        {key:"No",text:"NO"},
                    ]}
                    codeSystem="VALUESET:BETTER.SAME.WORSE"
                    autoHotKey
                    fieldId={fieldId}   
                />
            </div>    
            <div style={{width:"60%",display:"table-cell"}}>
                                
                {/* <div style={fd.field?.data?.[\`\${fieldId}Notes\`]?.length >0?{border:"1px solid black",padding:"6px 8px"}:{}} className="showonprint">
                    {fd.field?.data?.[\`\${fieldId}Notes\`]}
                </div> */}
                <TextArea
                    multiline
                    fieldId={\`\${fieldId}Notes\`}
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                    placeholder="Notes"
                />
                
            </div>
        </div>
    )
}

const TableMeasureRow = ({label, testId, fieldId}) => {
    
    return (
        <tr style={{paddingTop:"5px", paddingBottom:"5px"}}>
            <td style={{paddingLeft:"5px",verticalAlign:"top"}}><span style={{margin:"8px 0px"}}>{label}</span></td>
            <td style={{textAlign:"center !important",verticalAlign:"top"}}>
                <SimpleCodeSelect
                    size="small"
                    optionList={[
                        {key:"Better",text:"BETTER"},
                        {key:"Same",text:"SAME"},
                        {key:"Worse",text:"WORSE"},
                        {key:"Yes",text:"YES"},
                        {key:"No",text:"NO"},
                    ]}
                    codeSystem="VALUESET:BETTER.SAME.WORSE"
                    autoHotKey
                    fieldId={fieldId}   
                />
            </td>
            <td>
                <TextArea
                    multiline
                    fieldId={\`\${fieldId}Notes\`}
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                    placeholder="Notes"
                />
            </td>

        </tr>
    )
}


/* const tempPanel =[
   
    {
        // Fatigue
        description: "FATIGUE",
        loincCode: "28100-6",
        observationClass: "DCOBS",
        observationCode: "21250",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
    valueType: "VALUESET",
    },
    {
        // SOB/DYSPNEA
        description: "SHORTNESS OF BREATH",
        loincCode: "45705-1",
        observationClass: "DCOBS",
        observationCode: "45345",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // PND
        description: "PND: PAROXYSMAL NOCTURNAL DYSPNEA",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "A12312",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // ORTHOPNEA
        description: "ORTHOPNEA",
        loincCode: "82951-5",
        observationClass: "DCOBS",
        observationCode: "X0104",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // Palpitations
        description: "PALPITATIONS",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "A12314",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // LIGHT-HEADEDNESS
        description: "LIGHT-HEADEDNESS",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "A12315",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // GI COMPLAINTS
        description: "GASTROINTESTINAL COMPLAINTS",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "X0105",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // LIMITS TO ADL
        description: "LIMITS TO ADL",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "X0106",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // CHEST PAIN/ANGINA
        description: "CHEST PAIN",
        loincCode: "58259-3",
        observationClass: "DCOBS",
        observationCode: "58250",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "VALUESET",
    },
    {
        // USUAL NUMBER OF PILLOWS HEAD ELEVATION
        description: "USUAL NUMBER OF PILLOWS HEAD ELEVATION",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "61833",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: null,
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "NUMERIC",
        value:null,
    },
    {
        // CURRENT NUMBER OF PILLOWS HEAD ELEVATION
        description: "CURRENT NUMBER OF PILLOWS HEAD ELEVATION",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "61832",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: null,
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
        valueType: "NUMERIC",
        value:null,
    },
    {
        // Legs Swelling
        description: "SWELLING IN LEGS",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "A12318",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
    valueType: "VALUESET",
    },
    {
        // Abdomen Swelling
        description: "ABDOMEN SWELLING",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "X0107",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "VALUESET:BETTER.SAME.WORSE",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
    valueType: "VALUESET",
    },
    {
        // EXTRA DIURETICS
        description: "EXTRA DIURETICS",
        loincCode: null,
        observationClass: "DCOBS",
        observationCode: "A12317",
        panelSequenceNumber: 1,
        observationId: 0,
        abnormalFlag: {
            code: null,
            display: null,
            system: "MOIS-ABNORMALFLAG",
        },
        codedValue: {
            code: null,
            display: null,
            system: "MOIS-YESNO",
        },
        collectedBy:null,
        collectedDateTime: null,
        comment: null,
        copyTo: null,
        performedBy: null,
        performedDateTime: null,
        placerReferenceNumber: null,
        rangeAbsurdHigh: null,
        rangeAbsurdLow: null,
        rangeNormalHigh: null,
        rangeNormalLow: null,
        rangeVeryHigh: null,
        rangeVeryLow: null,
        recordState: {
            code: "UNSIGNED",
            display: "Unsigned",
            system: "MOIS-RECORDSTATE",
        },
        referenceRangeText: null,
        report: null,
        reportedBy: null,
        reportedDate: null,
        status: "F",
        units: null,
    valueType: "VALUESET",
    },
] */
/* const PHQ2Quest=
    {"Questions":
        [{
            "questionIndex":1,
            "questionText":"Little interest or pleasure in doing things",
            "selectedAnswer":{
                    "value":null,
                    "description":null,
                    "fieldId":null
                }
            },
            {
            "questionIndex":2,
            "questionText":"Feeling down, depressed, or hopeless",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            }
        ],
        "TotalScore":null,
    } */



const PHQ9Quest=
    {"Questions":
        [{
            "questionIndex":1,
            "questionText":"Little interest or pleasure in doing things",
            "selectedAnswer":{
                    "value":null,
                    "description":null,
                    "fieldId":null
                }
            },
            {
            "questionIndex":2,
            "questionText":"Feeling down, depressed, or hopeless",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":3,
            "questionText":"Trouble falling or staying asleep, or sleeping too much",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":4,
            "questionText":"Feeling tired or having little energy",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":5,
            "questionText":"Poor appetite or overeating",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":6,
            "questionText":". Feeling bad about yourself - or that you are a failure or have let yourself or your family down",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":7,
            "questionText":"Trouble concentrating on things, such as reading the newspaper or watching television",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":8,
            "questionText":"Moving or speaking so slowly that other people could have noticed? Or the opposite  being so fidgety or restless that you have been moving around a lot more than usual",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
            {
            "questionIndex":9,
            "questionText":"Thoughts that you would be better off dead or of hurting yourself in some way",
            "selectedAnswer":{
                "value":null,
                "description":null,
                "fieldId":null
                }
            },
        ],
    "TotalScore":null,
    "PHQ9Score":null,
    "PHQ2Score":null,
    "Difficulties":{}
    }`,
  './HFC_PT_ASMT_PatientSummary/index.jsx': `
const HFC_PT_ASMT_PatientSummary = (props) => {
    const [fd,setFd]=useActiveData()
    const sd = useSourceData()
    
    /* const connectionMutation = props.mutations */
    const [hideSubForm, setHideSubForm] = React.useState(true)
    const { auth, errorDispatch } = sd

    const [connectionMutation] = useMutation(
        \`mutation updateConnection($patientId: Int!, $connection: ConnectionInput!) {
            changeConnection(patientId: $patientId, connection: $connection) {
              patientId
            }
        }\`,
        { auth },
        errorDispatch)

    

        
    const sortStartDateDesc = (a,b) => {

        if (!a.startDate) {
            // Change this values if you want to put \`null\` values at the end of the array
            return +1;
        }
    
        if (!b.startDate) {
            // Change this values if you want to put \`null\` values at the end of the array
            return -1;
        }
        
        return b.startDate.localeCompare(a.startDate); 
    }

    const EFHistory = sd.patient.observations.filter(item=> item.observationCode==="2455" && new Date((item.collectedDateTime??"1900-01-01T00:00:00").split("T")[0])<=new Date(fd.field.data.docDate)).sort(latestCollectedFirst);

    

    

    const EFcols =[ 
        {
            id:"observationId",
            type:"key"
        },
        {
            id:"checklatest",
            type:"string",
            size:"small",
            onColumnMap:(item)=>EFHistory.indexOf(item)==0?"Latest as of document date":null
        },
        {
            title:"Collected Date",
            id:"collectedDateTime",
            type:"string",
            onColumnMap:(item)=>item.collectedDateTime.replace("T"," "),
            size:"small"
        },
        {
            title:"Code",
            id:"observationCode",
            type:"string",
            size:"tiny"
            
        },
        /* {
            title:"Test name",
            id:"description",
            type:"string",
            size:"medium"
            
        }, */
        {
            title:"Measure",
            id:"vwunits",
            type:"string",
            onColumnMap:(item)=>\`\${item.value??'-'} \${item.units}\`,
            size:"tiny"
        }
    ]

    const finalSourceMap = MoisFunction.mapSourceToActive(EFcols);

    return (
        <>
            <TextArea 
                  label="Created By"
                  labelPosition="left"
                  fieldId="docCreatedBy"
                  value =  {fd.field?.data?.docCreatedBy}
                  defaultValue={fd.field?.data?.docCreatedBy??sd.userProfile.identity.fullName}  
                  readOnly 
                  size="medium"  
              />
                       
            {/* <TextArea
                label="Service Location"
                fieldId="encSvcLocation"
                value = {fd.field.data.encSvcLocation}
                defaultValue={sd.webform?.encounter?.location??null}
                readOnly
                size="medium"
            /> */}

            <DateSelect
                label="Date Created"
                labelPosition="left"
                fieldId="docDate"
                defaultValue={fd.field?.data?.docDate??getDateString(new Date(),"-")}
                value={fd.field.data.docDate}
                size="medium"
            />

        <SubTitle text="Client Demographics" />
                            
            <LayoutItem label="Current Status" fieldId="activelayout"  labelPosition="left">
                <TextArea
                    fieldId="active"
                    value ={fd.field?.data?.active}
                    defaultValue={sd.patient?.active?.display??null}
                    readOnly   
                />
            </LayoutItem>

            {/* <LayoutItem label="Current Status" fieldId="healthNumber"  actions={{onEdit:true}} labelPosition="left" moisModule="DEMOGRAPHICS">
                <TextArea
                    fieldId="active"
                    value ={fd.field?.data?.active}
                    defaultValue={sd.patient?.active?.display??null}
                    readOnly   
                />
            </LayoutItem> */}

            <Mois.Patient.healthNumber />
            <Mois.Patient.insurance />
            <Mois.Patient.address />
            <Mois.Patient.telecom />
            <Mois.Patient.preferredPhone />
       

        <SubTitle text="Service Request Details" />
        
            <ReferralSource />
            <ServiceRequests />
            <Heading label="Primary Care Provider(s)" moisModule="DEMOGRAPHICS">
                <ListSelection 
                        id="connections" 
                        columns={getListSelectionColumns(sd,fd,setHideSubForm,connectionMutation)} 
                        filterPred={(item)=>item.connectionType.code==="PRIMARY" && !Boolean(item.stopDate)} 
                        detailsListProps={{styles:{root: {maxHeight: "400px", overflowX:"hidden",overflowY:"auto"}}}}
                        listCompare={sortStartDateDesc}
                />
                
                <div>
                    <span style={{dispay:"flex", justifyContent:"center"}}>Add new provider connection</span>
                    <Action.Add onAdd={()=> handleEditConnection(fd, setHideSubForm, connectionTemplate)}/>
                </div>
            </Heading>
            {/*Insert connections table for Primary Providers only*/}

        <SubTitle text="Patient Summary" />
            
            <Heading label="Summary List of Health Issues" moisModule="HEALTH ISSUE"/>
            {sd.queryResult?.patient[0]?.conditions?.filter(item=> (item.resolveDate ==null && item.condition.display !== null)).length >0 ?
            
                <ListSelection
                    id="conditions"
                    selectionType="none"
                    columns={healthIssuesCols}
                    
                    detailsListProps={{styles:{root: {maxHeight: "400px", overflowX:"hidden",overflowY:"auto"}}}}
                    filterPred={(item)=>(item.resolveDate == null && item.condition.display !== null)}
                    
                    listCompare = {sortStartDateDesc}
                />
                
            :
                <span>No Health Issues found for this patient</span>}
            
            <TextArea
                label="Diagnosis:"
                fieldId="ptSumDiag"
               
                multiline
                labelPosition="left"
                
            />
            <DateSelect fieldId="ptSumDateDiag" label="Date of Diagnosis"/>
            
            <TextArea
                label="Cause of LV Dysfunction: "
                fieldId="ptSumLVdys"
                labelPosition="left"
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                multiline
            />
            <Heading label="Ejection Fraction History" labelStyles={{style:{fontWeight:"600"}}}>
                
                {EFHistory.length >0?                
                
                <Column height={300}>
                    <ListSelection 
                        items={EFHistory.map(finalSourceMap)}
                        filterPred={item=> item.observationCode==="2455" && new Date((item.collectedDateTime??"1900-01-01T00:00:00").split("T")[0])<=new Date(fd.field.data.docDate) && EFHistory.indexOf(item)>=0}
                        columns={EFcols}
                        listCompare={latestCollectedFirst}
                    /> 

                </Column>
                :
                <span style={{paddingBottom:"15px"}}>Ejection Fraction history not found for this patient</span>
                }
            
            </Heading> 



            <TextArea
                label="Initial Ejection Fraction (EF) at Diagnosis: "
                fieldId="ptSumInitialEF"
                labelPosition="left"
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                multiline
            /> 

            <TextArea
                label="Device Therapy: "
                fieldId="ptSumDeviceTherapy"
                labelPosition="left"
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                multiline
            />

            <Heading text="Cardiac Procedures:">
                <TestResult
                    fieldId="ptSumCABG"
                    label="CABG: "
                    type="measure"
                    testCode="X0102"
                    />

                <TestResult
                    fieldId="ptSumPCI"
                    label="PCI: "
                    type="measure"
                    testCode="80498"/>
                               
                <TestResult
                    fieldId="ptSumAngio"
                    label="Angio: "
                    type="procedure"
                    testCode="77343006"/>

                <TestResult
                    fieldId="ptSumValveSurgery"
                    label="Valve Surgeries/Procedures: "
                    type="YN"
                    />
                
                <TestResult
                    fieldId="ptSumHolter"
                    label="Holter: "
                    type="measure"
                    testCode="473"
                    />

                <TestResult
                    fieldId="ptSumECGQRS"
                    label="ECG (QRS Width): "
                    type="measure"
                    testCode="479"
                    />

                <TestResult
                    fieldId="ptSumEcho"
                    label="ECHO: "
                    type="measure"
                    testCode="10755"/>

                <TestResult
                    fieldId="ptSumMUGA"
                    label="MUGA: "
                    type="procedure"
                    testCode="404221001"
                    />

                <TestResult
                    fieldId="ptSumMIBI"
                    label="MIBI: "
                    type="procedure"
                    testCode="431511008"
                    />

                <TestResult
                    fieldId="ptSumEST"
                    label="EST: "
                    type="measure"
                    testCode="475"
                    />

                <TextArea
                    label="Notes: "
                    fieldId="ptSumCDNotes"
                    labelPosition="left"
                    labelProps={{style:{minWidth:"0px"}}} 
                    textFieldProps={{autoAdjustHeight:true,resizable:false}}
                    multiline
                />
                <SimpleCodeChecklist 
                    label="Cardiac Devices:"
                    fieldId="ptSumCDNotesChecklist"
                    optionList={[
                        {key:"None",text:"None"},
                        {key:"ICD",text:"ICD"},
                        {key:"CRT",text:"CRT"},
                        {key:"PPM",text:"PPM"}
                    ]}
                    optionSize="small"
                />
            </Heading>

            <DateSelect
                fieldId="ptSumFirstSeen"
                label="First time seen at the clinic: "
                labelPosition="left"
                />

            <TextArea 
                label="Significant PMH/Substance Use: "
                fieldId="ptSumSubstUse"
                multiline
                labelPosition="left"
                /* labelProps={{style:{minWidth:"0px"}}} */ 
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                />

            {/* <Heading label="Long Term Medications" moisModule="LONG TERM MEDS" />

            {sd.patient?.longTermMedications?.length >0 ?
                <Column height={400}>
                    <ListSelection
                        id="longTermMedications"
                        items={sd.patient?.longTermMedications}
                        columns={ltRXcols}
                        selectionType="none"
                        detailsListProps={{styles:{root: {maxHeight: "400px", overflowX:"hidden",overflowY:"auto"}}}}
                        listCompare ={sortStartDatethenEndDateDesc}
                    />
                </Column>
            :
                <span>No long term medications have been recorded for this patient.</span>
            } */}

            <Heading label="Reaction Risks" moisModule="REACTION_RISKS" />
            
                {sd.patient?.allergies?.length >0
                ? 
                    <ListSelection
                        items={sd.patient.allergies}
                        columns={allergiesCols}
                        selectionType="none"
                        detailsListProps={{styles:{root: {maxHeight: "400px", overflowX:"hidden",overflowY:"auto"}}}}
                    />
                  
                :<span>No reaction risks have been recorded for this patient.</span>}
            
            
            <span><strong>Medication Notes</strong> (for medication reconciliation, please complete in the Long Term Medications folder <LinkToMois moisModule="LONG TERM MEDS" />):</span>
            <TextArea 
                fieldId="ptSumMedNotes"
                multiline
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                />

        {!hideSubForm && (
        <ConnectionEditSubForm
          {...{hideSubForm, setHideSubForm,connectionMutation}}
          
        />
      )}
        </>
    )
}

function getLastRead(code){
    const sd= useSourceData();    
    const [fd] = useActiveData();

    /* var labs = sd.patient?.observations?.filter(lcode => lcode.observationCode === code)??Array(0); */
    var labs = sd.patient?.observations?.filter(lcode => lcode.observationCode === code && new Date((lcode.collectedDateTime??"1900-01-01T00:00:00").split("T")[0])<=new Date(fd.field.data.docDate))??Array(0);
    
    /* console.log(code);
    console.log(labs); */
    
    if (labs.length > 0) 
    {
        
        var val;
        var unit;
        var date;

        labs = labs.sort(latestCollectedFirst);

        val= labs[0].value;
        unit = labs[0].units;
        date = labs[0].collectedDateTime.split("T")[0];

        return \`(\${date}) \${val} \${unit??''}\`;   
    }
    else{
        return "No Measure Found"
    }
    
}

const handleCreateConnection = async (
    createConnection,
    patientId,
    sd,
    coninfo,
    setHideSubForm
  ) => {
    console.log(coninfo)   
    /* alert("This is what you're saving: ", coninfo) */
    const result = await createConnection({
      patientId: patientId,
      connection: coninfo,
    })
    console.log(result)
    if (result?.changeConnection) {
      setHideSubForm(true)
      refresh(sd)
    }
  }

  

const ConnectionEditSubForm = ({
    connectionMutation,
    hideSubForm,
    setHideSubForm,
    ...rest
}) => {
    const sd = useSourceData()
    const [fd, setFd] = useActiveData()
    const defaultProviderTypeLookup = sd.optionLists["MOIS-CONNECTIONTYPEDEFAULT"]
  
    // The following code is used to clear the selected provider details
    // when the provider type (aka: connection resource) is changed.
    // It does not fire on "initial mount" of the data, but rather when
    // the selection is changed in the UI.
    const isInitialMount = React.useRef(true)
    React.useEffect(() => {
      if (isInitialMount.current) {
        isInitialMount.current = false
      } else {
        fd.setFormData(
          produce((draft) => {
            draft.tempArea.connectionEdit.provider = {}
          })
        )
      }
    }, [fd.tempArea?.connectionEdit?.providerType?.code])
    // -- END clearing provider code
  
    // The following code watches changes to the connection type and updates the
    // associated provider type to the default option for it
    React.useEffect(() => {
      const connectionTypeCode = fd.tempArea?.connectionEdit?.connectionType?.code
      const defaultProviderType = defaultProviderTypeLookup[connectionTypeCode]
  
      // if the default provider type should be changed
      if (
        fd.tempArea?.connectionEdit?.providerType?.code !== defaultProviderType
      ) {
        fd.setFormData(
          produce((draft) => {
            draft.tempArea.connectionEdit.providerType = {
              code: defaultProviderType,
            }
          })
        )
      }
    }, [fd.tempArea?.connectionEdit?.connectionType?.code])
    // -- END updating the provider type
    
    /* const gridRows = fd.tempArea?.connectionEdit?.connectionId > 0??false */
         
    return (
      <SubForm
        hidden={hideSubForm}
        onCancel={() => setHideSubForm(true)}
        minWidth={700}
        tempArea="connectionEdit"
      >
          <Row>
              <SimpleCodeSelect
                  id="connectionType"
                  readOnly
                  codeSystem={defaultProviderTypeLookup}
                  defaultValue={{code:"PRIMARY",display:"Primary Provider", system:"MOIS-CONNECTIONTYPE"}}
                  label="Connection Role"
                  section={{activeSelector:(fd)=>fd.tempArea.connectionEdit}}
              />
  
              <SimpleCodeSelect 
                  id="providerType"
                  codeSystem="MOIS-CONNECTIONPROVIDERTYPE"
                  optionList={providerTypes}
                  readOnly={fd.tempArea?.connectionEdit?.connectionId > 0}
                  label="Connection Type"
              />
          </Row>
          <Row>
              <Mois.Connection.provider
                  mapCandidateSavedValue={savedValueMapper}
                  providerType={lookupSelectedProviderType(fd)}
                  />
          </Row>
          <Row>
              <Mois.Connection.startDate />
              <Mois.Connection.includeOnDemographics />
              <Mois.Connection.isCareTeamMember />
              
          </Row>
          <Row>
              <Mois.Connection.stopDate />
          </Row>
          {Boolean(fd.tempArea?.connectionEdit?.stopDate??null)?
              <>
                  <Row>
                      <Mois.Connection.stopReason />
                  </Row>
                  <Row>
                      <Mois.Connection.stopNote />
                  </Row>
              </>
          :null
          }
          
          <Row>
              <Mois.Connection.comment />
          </Row>
        
              
        <ButtonBar>
          <Fluent.PrimaryButton
            onClick={() =>
              handleCreateConnection(connectionMutation, sd.formParams.patientId, sd, fd.tempArea.connectionEdit ,setHideSubForm)
            }
            text={fd.tempArea?.connectionEdit?.connectionId > 0?"Save Changes":"Create"}
          />
          <Fluent.DefaultButton
            onClick={() => setHideSubForm(true)}
            text="Cancel"
          />
        </ButtonBar>
        <DebugView excluded={{uiState:"...",field:"..."}}/>
      </SubForm>
    )
}

const TestResult = ({fieldId,label,testCode,value,type,...props}) => {
    const sd = useSourceData();

        var disp;
        
        if (type==="measure"){
            disp = 
                <TextArea
                    label={label}
                    value={Boolean(testCode)?(getLastRead(testCode)):null}
                    labelPosition="left"
                    fieldId = {fieldId}
                    labelProps={{style:{minWidth:"0px"}}}
                    readOnly
                    borderless={true}
                />
        }
        else if (type==="procedure") {
            disp = 
                <>
                    <div style={{display:"flex",alignContent:"center"}}>
                        <span style={{padding:"5px 10px 5px 0px",fontFamily: "Segoe UI,Segoe UI Web (West European), Segoe UI, -apple-system, BlinkMacSystemFont, Roboto, Helvetica Neue, sans-serif",fontSize:"14px", fontWeight:"600"}}>{\`\${label}\`}<LinkToMois moisModule="PROCEDURES" styles={{root:{minHeight:"0px"}}}/></span>
                        <span style={{padding:"5px 0px",fontSize:"14px",display:"inline-flex",alignItems:"center"}}>Unable to display Procedure result. Please review in MOIS.</span> 
                    </div>
                </>
        }
        else{
            disp = 
            <SimpleCodeChecklist fieldId={fieldId} label={label} codeSystem="MOIS-YESNO" optionSize="tiny" labelProps={{style:{minWidth:"0px"}}}/>
        }

        return (
            <div style={{display:"flex",flexDirection:"row",justifyContent:"space-between",padding:"0px 5px", borderBottom:"1px solid lightgrey"}}>
                <div style={{width:"60%"}}>
                    {disp}
                </div>
                <div style={{width:"40%"}}>
                    <TextArea
                        /* value={fd.field?.data?.[\`\${fieldId}notes\`]} */
                        fieldId={\`\${fieldId}notes\`}
                        textFieldProps={{autoAdjustHeight:true,resizable:false,styles:{root:{minWidth:"350px"}}}}
                        placeholder="Notes"
                        multiline
                    />
                </div>
            </div>
        )
    

}


const handleEditConnection = async (fd, setHideSubForm,connection) => {
    fd.setFormData(
        produce((draft) => {
        // key and name are non-persistent, so destructure them from the edit-data
        let { key, name, ...editableConnection } = connection
        draft.tempArea.connectionEdit = editableConnection
        })
    )
    setHideSubForm(false)
}

const getListSelectionColumns = (
    sd,
    fd,
    setHideSubForm,
    connectionMutation
  ) => {
    return [
      {
        id: "connectionId",
        type: "key",
      },
      {
        title: "Start",
        id: "startDate",
        type: "date",
      },
      {
        title: "Role",
        id: "connectionType",
        type: "code",
      },
      {
        title: "Name",
        id: "name",
        type: "string",
      },
      {
        title: "Actions",
        id: "link",
        type: "action",
        size: "tiny",
        onRender: (connection) => {
          return (
            <Action.Bar
              /* onDelete={(e) => {
                currentConnection = connection
                setHideDialog(false)
              }} */
              onEdit={() => handleEditConnection(fd, setHideSubForm, connection)}
            />
          )
        },
      },
      {
        id: "comment",
        type: "hidden",
      },
      {
        id: "includeOnDemographics",
        type: "hidden",
      },
      {
        id: "isCareTeamMember",
        type: "hidden",
      },
      {
        id: "provider",
        type: "hidden",
      },
      {
        id: "providerType",
        type: "hidden",
      },
      {
        id: "stopDate",
        type: "hidden",
      },
      {
        id: "stopReason",
        type: "hidden",
      },
      {
        id: "stopNote",
        type: "hidden",
      },
    ]
  }
  
  
  
      const connectionTemplate = {
          connectionId: 0,
          includeOnDemographics: { code: "Y", display: "Yes", system: "MOIS-YESNO" },
          isCareTeamMember: { code: "N", display: "No", system: "MOIS-YESNO" },
      }
  
      let currentConnection = {
          connectionId: 0,
      }
  
     

    
      
      const lookupSelectedProviderType = (fd) => {
      const code = fd.tempArea?.connectionEdit?.providerType?.code
      return providerTypes.find((x) => x.code === code)?.type
      }
  
      const savedValueMapper = (provider) => {
      const result = {
          code: provider.code ? provider.code : null,
          name: provider.name ?? provider.display ?? null,
          source: provider.sourceId ? provider.source : "FREE TEXT",
          sourceId: provider.sourceId ?? null,
      }
      // handy for debugging
      // console.log("original:", provider)
      // console.log("after map:", result)
      return result
      }
  
      const providerTypes = [
          { code: "100", display: "PROVIDER (EXT)",type:"PROVIDER EXTERNAL" },
          { code: "110", display: "PROVIDER (INT)",type:"PROVIDER" },  
      ]

      const ltRXcols = [
        {
            id:"code",
            type: "key"    
        },
        {
            title:"Start",
            itemId:"startDate",
            type:"date",
            size:"tiny"
        },
        {
            title:"End",
            itemId:"endDate",
            type:"date",
            size:"tiny"
        },
        {
            title:"Medication",
            itemId:"medication",
            type:"string",
            size:"large"
        },
        {
            title:"Dose Frequency",
            itemId:"doseFrequency",
            type:"string",
            size:"small"
        }    
    ]

    const healthIssuesCols=[
        {
            id:"conditionId",
            type:"key"
        },
        {
            title:"Start Date",
            id:"startDate",
            type:"date",
            size:"tiny"
        },
        {
            title:"Condition",
            id:"condition",
            type:"code",
            size:"large"
        },
        {
            title:"Certainty",
            id:"certainty",
            type:"code"
        },
        {
            title:"Severity",
            id:"severity",
            type:"code"
        }
    ]

    const allergiesCols=[
        {
            id:"code",
            type:"key"
        },
        {
            title:"Type",
            itemId:"intoleranceType",
            type:"text",
            size:"small"
        },
        {
            title:"Start",
            itemId:"startDate",
            type:"date",
            size:"tiny"
        },
        {
            title:"End",
            itemId:"endDate",
            type:"date",
            size:"tiny"
        },
        {
            title:"Substance",
            itemId:"substance",
            type:"text",
            size:"large"
        },
        {
            title:"Reaction",
            itemId:"reations",
            type:"text",
            size:"medium"
        }

    ]

    const latestCollectedFirst = (a, b) => {
        const acol = a.collectedDateTime ? a.collectedDateTime : "2100-01-01"
        const bcol = b.collectedDateTime ? b.collectedDateTime : "2100-01-01"
        return asciiCompare(acol, bcol)
      }
    
      const ConditionsSortDesc = (a, b) => {
        const acol = a.startDate ? a.startDate : "2100-01-01"
        const bcol = b.startDate ? b.startDate : "2100-01-01"
        return -asciiCompare(a, b)
      }
      
    const asciiCompare = (a, b) => (a < b ? +1 : a > b ? -1 : 0)
    
    

`,
  './HFC_PT_ASMT_SnapShot/index.jsx': `const {Checkbox, ChoiceGroup} = Fluent



const HFC_PT_ASMT_SnapShot = (props) => {
    const [fd,setFd] = useActiveData()    
    const sd = useSourceData()
    
    const RadioSelectGroup=({optionList,fieldId,codeSystem,section,...props})=>{
        //An extension of the fluent ChoiceGroup that ensures data is sent to the ActiveData properly
                               
        const codesys = props.codeSystem != null? sd.optionLists[\`\${props.codeSystem}\`]:optionList;
        
        var optionList =[]
        
        if (codesys != null){
            codesys.forEach(obj => optionList.push({key:\`\${obj.key}\`,text:\`\${obj.value??obj.text??null}\`,id:\`\${fieldId}\`,codeSystem:\`\${codeSystem??null}\`}));

           /*  for (const [key,value] of Object.entries(codesys)){
                const newitem = {key:\`\${key}\`,text:\`\${value}\`};
                optionlist.push(newitem);
            } */
        }
               
        
        
        return (<>
            {codesys.length>0?
                <ChoiceGroup 
                        styles={props.styles}
                        options={optionList}
                        defaultSelectedKey={fd.field.data[\`\${fieldId}\`]?.code??null}
                        onChange={(opt,choice)=>_onChoiceChange(opt,choice)}
                />
            :
                null
            }
            </>
    
        )
    }

    const handleStateChange = (fieldData) =>{
       fd.setFormData({
       ...fd,
          field: {
        ...fd.field,
        data: fieldData,
      }})
    }

    function _onChoiceChange(opt,choice){
        console.log(opt)
        console.log(choice);;

        var fieldData = opt.target.type!="checkbox"
            ?   
                {
                ...fd.field.data,
                [choice.id]:{
                    "code":\`\${choice.key}\`,
                    "display":\`\${choice.text}\`,
                    "system":\`\${choice.codeSystem}\`
                    }
                }
            :
                {
                ...fd.field.data,
                [opt.target.id]:{
                    "ischecked":choice,
                    }
                }
        
    
        handleStateChange(fieldData);
    }
    
    const checkBoxStyles = {
        checkmark: {
          background: 'white',
          color:'black',
          fontWeight:'bold'
          },
        checkbox:{
          background:'white',
          borderColor:'black'
        }
      };


    const _handlecheckchange = (item,checked) =>{
        const fieldData = {
            ...fd.field.data,
            [item.target.id]:{
                "ischecked":checked,
            }
        }
    
        handleStateChange(fieldData);
        
       /*  setFd({
          ...fd,
          field: {
          ...fd.field,
          data: fieldData,
          }}) */
      }
    
    const _removeAppt=(index)=>{
        const appts = fd.field.data.FollowUpAppts

        appts.appointments.splice(index,1)
        appts.appointmentCount = appts.appointments.length

        const fieldData = {
            ...fd.field.data,
            FollowUpAppts:appts
        }

        handleStateChange(fieldData);
    }

    const _AddAppt=()=>{
        const appts = fd.field.data.FollowUpAppts

        const newAppt={
            "ptSnapFUDate": null,
            "ptSnapFUVisitType": {
                    "code": null,
                    "display": null
                },
            "ptSnapFUVisitModel": {
                "code": null,
                "display": null
            },
        }

        appts.appointments.push(newAppt);

        appts.appointmentCount=appts.length
        
        const fieldData = {
            ...fd.field.data,
            FollowUpAppts:appts
        }

        handleStateChange(fieldData);

    }
    
    const optlist=[
        {key:"BW",text:"Blood work to be completed"},
        {key:"ECG",text:"ECG"},
       /*  {key:"Holter",text:"Holter"},
        {key:"ECHO",text:"ECHO"},
        {key:"MUGA",text:"MUGA"},
        {key:"MIBI",text:"MIBI"}, */
        {key:"Other",text:"Other"}
    ]

    const followUpList=[
        {key:"Nurse",text:"Nurse"},
        {key:"NP",text:"Nurse Practitioner"},
        {key:"MD",text:"Medical Doctor (MD)"}
    ]

    const sortStartDatethenEndDateDesc = (a,b) =>{
        if (!a.startDate&!a.endDate){
            return +1;
        }
        
        if (!b.startDate&!b.endDate){
            return -1;
        }

        if (!a.startDate)
            return +1;
    
        if (!b.startDate){
            return -1;
        }

        if (a.startDate){
            if (!a.endDate){
                return -1;
            }
            else if (a.startDate>b.startDate && b.endDate){
                return -1;
            }
            else if (a.startDate === b.startDate){
                return 0;
            }
            else if (a.startDate<b.startDate && b.endDate){
                return +1;
            }
        }

        if (b.startDate){
            if (!b.endDate){
                return +1;
            }
            else if (b.startDate>a.startDate && a.endDate){
                return +1;
            }
            else if (a.startDate === b.startDate){
                return 0;
            }
            else if (b.startDate<a.startDate && a.endDate){
                return -1;
            }
        }

        /* if (b.startDate){
            if (!b.endDate){
                return +1;
            }
            else{
                return -1;
            }
        } */


        /* if (a.startDate && !a.endDate){
            return b.startDate.localeCompare(a.startDate);
        } */

        
        /* if (!a.startDate && !a.endDate){
            return +1;
        }
                
        if (a.startDate && !a.endDate){
            return -1;
        }

        if (b.startDate > a.startDate && !a.endDate) {
            return +1;
        }

        if (a.startDate > b.startDate && a.endDate) {
            return -1;
        } */
                                     
        /* if (!b.startDate) {
           // Change this values if you want to put \`null\` values at the end of the array
           return -1;
        } */



         
         /* const StartDatetoTop = b.startDate.localeCompare(a.startDate); */
         /* const EndDateToTop = b.endDate.localeCompare(a.endDate); */

         return 0;
         /* return StartDatetoTop; */
         /* return StartDatetoTop || EndDateToTop; */
    }

    const reminder = 
    \`- Restrict your fluid to 1.5-2L per day. This includes the fluid in your food.
                    
- Restrict sodium (salt) intake to 2300mg (or 1tsp) per day
        
- Check your blood pressure, pulse rate, and weight daily. If your weight increases by 4lbs in 2 days or 5lbs in 1 week call the clinic or see a doctor soon to have this assessed.

-Please contact your family doctor or go to the walk in clinic or Emergency room if you notice any worsening of your heart failure symptoms.\`
    
    const tableCellStyle = {display:"table-cell",border:"1px solid #AAAAAA"}
    const tableStyle={display:"table",border:"1px solid darkgrey", borderCollapse:"collapse",width:"100%"}

    const snapdate = new Date(fd?.field?.data?.snapDate?.replace(/-/g, "/"))

    return (
        <>
            <div className="showonprint">
                <NameBlock />
            </div>
            <div style={{width:"100%", textAlign:"center"}}><Title>SNAPSHOT OF YOUR VISIT</Title></div>    
            <br />
            <div className="hideonprint"><SubTitle label="Snapshot of your Visit" /></div>
            <DateTimeSelect 
                fieldId="snapDate"
                defaultValue ={getDateTimeString(new Date())}
                label="Date of Appointment:"
            />
            <TextArea 
                label="Medication Changes:"
                multiline 
                textFieldProps={{autoAdjustHeight:true,resizable:false}}
                fieldId="ptSnapMedChanges"
                
            />
            {/* <Heading label="Long Term Medications" moisModule="LONG TERM MEDS" />

            {sd.patient?.longTermMedications?.length >0 ?
                <Column height={400}>
                    <ListSelection
                        id="longTermMedications"
                        items={sd.patient?.longTermMedications}
                        columns={ltRXcols}
                        selectionType="none"
                        detailsListProps={{styles:{root: {maxHeight: "400px", overflowX:"hidden",overflowY:"auto"}}}}
                        listCompare ={sortStartDatethenEndDateDesc}
                    />
                </Column>
            :
                <span>No long term medications have been recorded for this patient.</span>
            } */}

            <Heading label="Test:">
            <div style={{width:"100%",display:"flex",flexDirection:"Column"}}>
                {optlist.map((obj)=>{
                    
                    return(
                        <>
                            <div style={{display:"flex",flexDirection:"row"}}>
                                <div style={{width:"25%"}}>
                                    <SimpleCodeChecklist 
                                        optionList={[
                                            {key:\`\${obj.key}\`,text:\`\${obj.text}\`}
                                        ]}
                                        fieldId={\`ptSnap\${obj.key}\`}
                                        selectionType="multiple"
                                        optionProps={{styles:{checkmark:{background:"white",color:"black",fontWeight:"bolder"},checkbox:{background:"white",borderColor:"black"}}}}
                                        
                                    />
                                </div>
                                <div style={{width:"75%"}}>
                                    <TextArea 
                                        multiline 
                                        textFieldProps={{autoAdjustHeight:true,resizable:false}}
                                        fieldId={\`ptSnap\${obj.key}Notes\`} 
                                    />
                                </div>
                            </div>

                        </>
                    
                    )
                    }
                )}         
            </div>
            </Heading>
            
            <SimpleCodeChecklist
                fieldId="ptSnapFUApptNeeded"
                selectionType="single"
                codeSystem="MOIS-YESNO"
                label="Follow-up Appointments needed"
                optionSize="tiny"
                conditionalCodes={["Y","N"]}

            >

            
            {fd.field.data.ptSnapFUApptNeeded?.code ==="Y"?
            
                <Heading label="Follow-up appointments:" labelStyles={{style:{fontWeight:"600"}}}>
                    
                    {fd?.uiState?.sections?.[0]?.isComplete === true?
                        null
                    :
                        <DefaultButton text="Add Appointment" iconProps={{iconName:'Add'}} onClick={_AddAppt} className="hideonprint" disabled={sd.webform?.recordState ==='SIGNED'} styles={{root:{width:"fit-content",pageBreakInside:"avoid"}}}/>
                    }

                    <div className={\`\${fd.field.data.FollowUpAppts.appointments.length === 0?"showonprint":""}\`} style={{display:"none"}}>
                        <span>No follow-up appointments scheduled</span>
                    </div>

                    <div style={tableStyle} className={\`\${fd.field.data.FollowUpAppts.appointments.length === 0?"hideonprint":""}\`}>
                        <div style={{display:"table-header-group", pageBreakInside:"avoid"}}>
                            <div style={{display:"table-row", pageBreakInside:"avoid",backgroundColor:"lightgrey"}}>
                                <div style={{display:"table-cell",width:"25%",textAlign:"center",fontSize:"16px",fontWeight:"bold",verticalAlign:"middle"}}>Date</div>
                                <div style={{display:"table-cell",width:"50%",textAlign:"center",fontSize:"16px",fontWeight:"bold"}}>Visit Type<br/>(Education, RN, NP, MD)</div>
                                <div style={{display:"table-cell",textAlign:"center",fontSize:"16px",fontWeight:"bold",verticalAlign:"middle"}}>Visit Mode</div>
                                <div style={{display:"table-cell",width:"10%",textAlign:"center",fontSize:"16px",fontWeight:"bold"}} className="hideonprint"></div>
                            </div>
                        </div>
                        <div style={{display:"table-row-group", pageBreakInside:"avoid"}}>
                            {fd.field.data.FollowUpAppts.appointments.length === 0?
                                <div style={{display:"table-row", pageBreakInside:"avoid"}}>
                                No follow-up appointments scheduled
                                </div>
                            :   
                            
                            fd.field.data.FollowUpAppts.appointments.map((obj,index)=>{
                                console.log(fd.field.data.FollowUpAppts.appointments[index]);
                                return( 
                                <div style={{display:"table-row", pageBreakInside:"avoid"}}>
                                    <div style={{maxWidth:"20%",...tableCellStyle}}>
                                        <div className="showonprint showapptonprint"> 
                                            {fd.field.data.FollowUpAppts.appointments[index].ptSnapFUDate?\`\${getDateString(new Date(fd.field.data.FollowUpAppts.appointments[index].ptSnapFUDate),"-")} \${getTimeString(new Date(fd.field.data.FollowUpAppts.appointments[index].ptSnapFUDate))}\`:null }
                                        </div>
                                        <div style={{width:"100%"}} className="hideonprint">
                                            <DateTimeSelect 
                                                fieldId="ptSnapFUDate" 
                                                size={{width:"100%"}}
                                                datePickerProps={{minDate: new Date(snapdate)}}
                                                section={{activeSelector:(fd)=>fd.field.data.FollowUpAppts.appointments[index]}}
                                            />
                                        </div>
                                        {/* <DateSelect 
                                            fieldId="ptSnapFUDate" 
                                            size={{width:"100%"}}
                                            datePickerProps={{minDate: new Date(snapdate)}}
                                            section={{activeSelector:(fd)=>fd.field.data.FollowUpAppts.appointments[index]}}
                                        /> */}
                                    </div>
                                    <div style={{maxWidth:"20%",...tableCellStyle}}>
                                        <div className="showonprint showapptonprint">
                                            {fd.field.data.FollowUpAppts.appointments[index].ptSnapFUVisitType.display}                                        
                                        </div>
                                        <div style={{width:"100%"}} className="hideonprint">
                                            <SimpleCodeSelect 
                                                fieldId="ptSnapFUVisitType" 
                                                size={{width:"100%"}}
                                                optionList={[
                                                    {key:"HFE",text:"Heart Failure Education"},
                                                    {key:"RN",text:"RN"},
                                                    {key:"NP",text:"NP"},
                                                    {key:"MD",text:"MD"},
                                                    {key:"blend",text:"Blended Heart Failure/Cardiac Risk Reduction Education"}
                                                ]}
                                                showOtherOption
                                                size={{width:"100%"}}
                                                section={{activeSelector:(fd)=>fd.field.data.FollowUpAppts.appointments[index]}}
                                            />
                                        </div>
                                    </div>
                                    <div style={{...tableCellStyle, textAlign:"center"}}>
                                        <div style={{maxWidth:"250px"}}>
                                            <div className="showonprint showapptonprint">
                                                {fd.field.data.FollowUpAppts.appointments[index].ptSnapFUVisitModel.display}
                                            </div>
                                            <div style={{width:"100%"}} className="hideonprint">
                                                <SimpleCodeSelect 
                                                    fieldId="ptSnapFUVisitModel"
                                                    optionList={[
                                                        {key:"Televisit",text:"Televisit"},
                                                        {key:"IP",text:"In Person"}
                                                    ]}
                                                    size={{width:"100%"}}
                                                    optionProps={{styles:{root:{padding:"0px 10px"}}}}
                                                    section={{activeSelector:(fd)=>fd.field.data.FollowUpAppts.appointments[index]}}
                                                />
                                            </div>
                                        </div>
                                        
                                    </div>
                                    <div style={{...tableCellStyle, minWidth:"100px",textAlign:"center"}} className="hideonprint">
                                        {fd?.uiState?.sections?.[0]?.isComplete === true?
                                            null
                                            :
                                            <DefaultButton text="Remove" onClick={()=>_removeAppt(index)} className="hideonprint" disabled={sd.webform?.recordState ==='SIGNED'} />
                                        }
                                    </div>
                                </div>
                                )}
                            )}
                        </div>
                    </div>
                           
                    <TextArea 
                        label="Reminders:"
                        labelPostion="top"
                        multiline
                        defaultValue={reminder}
                        textFieldProps={{autoAdjustHeight:true,resizable:false}}
                        fieldId="ptSnapFUReminderNotes"
                    />
                </Heading>
            :
                fd.field.data.ptSnapFUApptNeeded?.code === "N"?
                <Heading label="Program Complete. No further follow-up needs to be booked." labelStyles={{style:{fontWeight:"600"}}} />:null
                }
            </SimpleCodeChecklist>
        </>
    )
}



/* const RadioSelectGroup=({optionList,fieldId,codeSystem,section,...props})=>{
    //An extension of the fluent ChoiceGroup that ensures data is sent to the ActiveData properly
    const [fd,setFd] = useActiveData()
    const sd = useSourceData()
            
    const codesys = props.codeSystem != null? sd.optionLists[\`\${props.codeSystem}\`]:optionList;
    
    var optionlist = [];
    
    if (codesys != null){
        for (const [key,value] of Object.entries(codesys)){
            const newitem = {key:\`\${key}\`,text:\`\${value}\`};
        }
    }
           
    return (<>
        {optionlist.length>0?
            <ChoiceGroup 
                    styles={props.styles}
                    options={optionlist}
                    defaultSelectedKey={fd.field.data[\`\${fieldId}\`]?.code??null}
                    onChange={(opt,choice)=>_onChoiceChange(opt,choice,fieldId,props.codeSystem)}
            />
        :
            null
        }
        </>

    )
} */

/* function _onChoiceChange(opt,choice,fieldId,cs){
    const[fd] = useActiveData();
    
    console.dir(choice);

    const fieldData = {
        ...fd.field.data,
        [fieldId]:{
            "code":\`\${choice.key}\`,
            "display":\`\${choice.text}\`,
            "system":\`\${cs}\`
        }
    }

    props.handleStateChange(fieldData);

} */

/* const handleStateChange = (fieldData) =>{
   const [fd]
   
    fd.setFormData({
      ...fd,
      field: {
      ...fd.field,
      data: fieldData,
      }})
  } */

`,
  './HonosQuestion/index.jsx': `const  { useEffect } = React
const {
  Stack,
  ChoiceGroup,
  Label,
  Text,
  DefaultButton,
  Dropdown,
  StackItem,
  TooltipHost,
  Separator,
  ILabelStyles,
  IStackSlots,
  IChoiceGroupStyles,
} = Fluent

type HonosItem = {
  selectedKey: string
  selectedDropdownKey?: string
  value: number
}

type FormData = {
  [id:string]: HonosItem
}

// ================================================
// Styles definition
// ================================================

const QUESTION_NO_STACK_ITEM_STYLE: ILabelStyles = {
  root: {
    display: "flex",
    width: 18,
    margin: "0px 0px 0px 0px",
  },
}

const QUESTION_defaultLabelStyle = {
  root: {
    // display: "flex",
    margin: "0px 0px 0px 0px",
    width: 250,
  },
}

const CHOICE_FIELD_STYLE = {
  root: {
    padding: "0px 10px 5px 15px",
    width: 80,
    overlap: "hidden",
    textAlign: "center",
  },
}

const QUESTION_STACK_STYLE = {
  margin: "0px 0px 0px 0px",
}

const choiceGroupStyle: IChoiceGroupStyles = {
  flexContainer: {
    display: "flex",
    justifyContent: "space-between",
    width: "100%",
  },
}

// End of Styles definition
// ================================================

// ================================================
// Constant definition for the Choice Group
// ================================================

const SCALE_5_LEGENDS = [
  "No problem",
  "Minor not requiring action",
  "Mild but present",
  "Moderate",
  "Severe to very severe",
  "Unknown or not asked",
]

const SCALE_5_OPTIONS = [
  { key: "0", value: 0, text: "0", styles: CHOICE_FIELD_STYLE },
  { key: "1", value: 1, text: "1", styles: CHOICE_FIELD_STYLE },
  { key: "2", value: 2, text: "2", styles: CHOICE_FIELD_STYLE },
  { key: "3", value: 3, text: "3", styles: CHOICE_FIELD_STYLE },
  { key: "4", value: 4, text: "4", styles: CHOICE_FIELD_STYLE },
  { key: "9", value: 0, text: "9", styles: CHOICE_FIELD_STYLE },
]

const SCALE_10_LEGENDS = [
  "No problem",
  "Very low",
  "Low",
  "Mild",
  "Mild to moderate",
  "Moderate",
  "Moderate to high",
  "High",
  "Very high",
  "Severe",
  "Extreme",
]

const SCALE_10_OPTIONS = Array.from({ length: 11 }, (_, value) => ({
  key: String(value),
  value,
  text: String(value),
  styles: CHOICE_FIELD_STYLE,
}))

const SCALE_5_LEGEND_LOOKUP = {
  "0": SCALE_5_LEGENDS[0],
  "1": SCALE_5_LEGENDS[1],
  "2": SCALE_5_LEGENDS[2],
  "3": SCALE_5_LEGENDS[3],
  "4": SCALE_5_LEGENDS[4],
  "9": SCALE_5_LEGENDS[5],
}

const SCALE_10_LEGEND_LOOKUP = SCALE_10_OPTIONS.reduce((lookup, option) => {
  lookup[String(option.key)] = SCALE_10_LEGENDS[Number(option.key)] || option.text
  return lookup
}, {})

type ScaleChoiceOption = {
  key: string
  value: number
  text: string
  styles?: unknown
  description?: string
}

type ScaleChoiceInput = {
  key?: string | number
  value?: number | string
  rating?: number | string
  text?: string
  label?: string
  description?: string
}

const toFiniteNumber = (value: unknown): number | null => {
  const numeric = Number(value)
  if (!Number.isFinite(numeric)) return null
  return numeric
}

const normalizeScaleChoiceOptions = (options: unknown): ScaleChoiceOption[] => {
  if (!Array.isArray(options)) return []

  const normalized: ScaleChoiceOption[] = []
  const seenKeys = new Set<string>()

  for (const rawOption of options) {
    const option = rawOption as ScaleChoiceInput
    const keySource = option?.key ?? option?.value ?? option?.rating
    if (keySource == null) continue

    const key = String(keySource).trim()
    if (!key || seenKeys.has(key)) continue

    const numericValue = toFiniteNumber(option?.value ?? option?.rating ?? option?.key)
    if (numericValue == null) continue

    const text =
      typeof option?.text === "string" && option.text.trim()
        ? option.text.trim()
        : typeof option?.label === "string" && option.label.trim()
          ? option.label.trim()
          : key
    const description =
      typeof option?.description === "string" && option.description.trim()
        ? option.description.trim()
        : undefined

    normalized.push({
      key,
      value: numericValue,
      text,
      styles: CHOICE_FIELD_STYLE,
      description,
    })
    seenKeys.add(key)
  }

  return normalized
}

const buildLegendLookupFromOptions = (
  options: ScaleChoiceOption[],
  fallbackLookup: Record<string, string>
): Record<string, string> => {
  const lookup: Record<string, string> = { ...fallbackLookup }

  for (const option of options) {
    if (!option?.key) continue
    lookup[String(option.key)] = option.description || option.text || lookup[String(option.key)]
  }

  return lookup
}

// End of Constant Definition
// ================================================

// ================================================
// Control Definition
// ================================================

const Scale5QuestionList = props => {
  return (
    <div>
      {props.children}
    </div>
  )
}

const Scale5SubmitButton = props => {
  const [fd] = useActiveData()

  return (
    <Stack horizontal wrap tokens={{ childrenGap: "m" }}>
      <SubmitButton
        {...props}
      />
      <DefaultButton
        data-automation-id='fill'
        text='Fill all the unfilled questions with 9'
        onClick={e => {
          fillAllUnfilledQuestions(fd)
        }}
      />
    </Stack>
  )
}

const Scale5Legend = () => {
  return <ScaleLegend legends={SCALE_5_LEGENDS} />
}

const Scale10Legend = () => {
  return <ScaleLegend legends={SCALE_10_OPTIONS.map(option => option.text)} />
}

const ScaleLegend = ({ legends }) => {
  const legendRowStyle: IComponentStyles<IStackSlots> = {
    root: {
      justifyContent: "space-between",
      width: "100%",
    },
  }

  const legendStyle: React.CSSProperties = {
    padding: "5px 15px 0px 0px",
    width: 75,
    textAlign: "center",
  }

  return (
    <Stack horizontal wrap style={QUESTION_STACK_STYLE}>
      <StackItem disableShrink>
        <Label styles={QUESTION_NO_STACK_ITEM_STYLE}>
          &nbsp;
        </Label>
      </StackItem>
      <StackItem disableShrink>
        <Stack>
          <Label styles={QUESTION_defaultLabelStyle}>{/* <b>Questions</b> */}&nbsp;</Label>
        </Stack>
      </StackItem>
      <StackItem grow>
        <Stack horizontal styles={legendRowStyle} tokens={{ padding: 5 }}>
          {legends.map((legend, index) => {
            return (
              <Text key={index} style={legendStyle}>
                <b>{legend}</b>
              </Text>
            )
          })}
        </Stack>
      </StackItem>
    </Stack>
  )
}

type ScaleQuestionProps = {
  id?: string
  label?: JSX.Element | string
  dropdownOptions?: any
  tooltip?: { rating: number, description: string }[]
  showInlineLabels?: boolean
  showLegend?: boolean
  disableCount?: boolean
  question?: string
  scaleOptions?: ScaleChoiceInput[]
}

const createScaleQuestion = ({
  choiceOptions,
  fallbackLegendLookup,
  fallbackDescription,
}: {
  choiceOptions: ScaleChoiceOption[],
  fallbackLegendLookup: Record<string, string>,
  fallbackDescription: string
}) => {
  return ({
    id,
    label,
    dropdownOptions,
    tooltip,
    showInlineLabels = true,
    showLegend = false,
    disableCount,
    question,
    scaleOptions,
  }: ScaleQuestionProps) => {
    const [honosData,modHonosData]: [FormData,Setter] = useActiveData(fd=>fd.field.data)
    const [fd] = useActiveData()
    const theme = useTheme()

    let defaultHonosItem: HonosItem = { selectedKey: null, value: null, question, response: null }
    if (dropdownOptions) defaultHonosItem = { ...defaultHonosItem, selectedDropdownKey: null}
    const rawfditem = honosData[id]
    const fditem = rawfditem || defaultHonosItem

    useEffect(() => {
      if (rawfditem==null) {
        modHonosData({[id]:defaultHonosItem})
      }
    },[id,rawfditem,defaultHonosItem,modHonosData])

    const customChoiceOptions = normalizeScaleChoiceOptions(scaleOptions)
    const effectiveChoiceOptions = customChoiceOptions.length > 0 ? customChoiceOptions : choiceOptions
    const fallbackLookup = buildLegendLookupFromOptions(effectiveChoiceOptions, fallbackLegendLookup)
    const generatedTooltip =
      effectiveChoiceOptions.some((option) => typeof option.description === "string" && option.description.length > 0)
        ? effectiveChoiceOptions.map((option) => ({
            rating: option.value,
            description: option.description || option.text,
          }))
        : undefined
    const effectiveTooltip =
      Array.isArray(tooltip) && tooltip.length > 0
        ? tooltip
        : generatedTooltip
    const tooltipLookup = buildTooltipLookup(effectiveTooltip, fallbackLookup)
    const renderedChoiceOptions = showInlineLabels
      ? effectiveChoiceOptions
      : effectiveChoiceOptions.map((option) => ({
          ...option,
          text: "",
        }))

    let questionStyle = {
      backgroundColor: "#FBFBFB",
      padding: "5px 0px 5px 10px",
      marginBottom: "1px",
    }

    if (fditem.selectedKey && (!dropdownOptions || fditem.selectedDropdownKey)) {
      questionStyle.backgroundColor = theme.semanticColors.bodyBackground
    }

    const dropdownStyles = {
      dropdown: {
        width: 200,
        padding: "5px 0px 0px 0px",
      },
      title: {
        background: (!dropdownOptions || fditem.selectedDropdownKey)
          ? theme.semanticColors.bodyBackground
          : theme.aihs.requiredBackground
      },
    }
    
    return (
      <>
        {showLegend && <ScaleLegend legends={effectiveChoiceOptions.map((option) => option.text)} />}
        <div style={questionStyle}>
          <TooltipHost
            id={"tooltip_" + id}
            tooltipProps={
              effectiveTooltip && {
                onRenderContent: () => {
                  return <Scale5ToolTip tooltip={effectiveTooltip} />
                },
              }
            }
          >
            <Stack horizontal wrap style={QUESTION_STACK_STYLE}>
              <StackItem disableShrink>
                <Label styles={QUESTION_NO_STACK_ITEM_STYLE}>
                  {id + ". "}
                </Label>
              </StackItem>
              <StackItem disableShrink>
                <Stack>
                  <Label styles={QUESTION_defaultLabelStyle}>{label}</Label>
                  {dropdownOptions && (
                    <Stack horizontal>
                      <Dropdown
                        placeholder='Please Select'
                        options={dropdownOptions}
                        styles={dropdownStyles}
                        selectedKey={fditem.selectedDropdownKey}
                        onChange={(e, option, index) =>
                          handleDropdownChanged(option, id, honosData, modHonosData)
                        }
                      />
                    </Stack>
                  )}
                </Stack>
              </StackItem>
              <StackItem grow>
                <ChoiceGroup
                  id={"choiceGroup-" + id}
                  name={id}
                  key={id}
                  tabIndex={0}
                  options={renderedChoiceOptions}
                  styles={choiceGroupStyle}
                  selectedKey={fditem.selectedKey}
                  onKeyUp={e =>
                    handleKeyUp(
                      id,
                      e,
                      fditem,
                      fd,
                      dropdownOptions,
                      disableCount,
                      effectiveChoiceOptions,
                      tooltipLookup,
                      fallbackDescription
                    )
                  }
                  onChange={(e, option) =>
                    handleChoiceChanged(
                      id,
                      option,
                      fditem,
                      fd,
                      dropdownOptions,
                      disableCount,
                      tooltipLookup,
                      fallbackDescription
                    )
                  }
                />
              </StackItem>
            </Stack>
          </TooltipHost>
        </div>
      </>
    )
  }
}

const Scale5 = createScaleQuestion({
  choiceOptions: SCALE_5_OPTIONS,
  fallbackLegendLookup: SCALE_5_LEGEND_LOOKUP,
  fallbackDescription: "Unknown or not asked",
})

const Scale10 = createScaleQuestion({
  choiceOptions: SCALE_10_OPTIONS,
  fallbackLegendLookup: SCALE_10_LEGEND_LOOKUP,
  fallbackDescription: "No rating",
})

const Scale5ToolTip = props => {
  if (props.tooltip) {
    let i = 0
    const tooltipList = props.tooltip.map(item => {
      return (
        <Stack horizontal key={i++} styles={{ root: { paddingBottom: 5 } }}>
          <StackItem styles={{ root: { minWidth: 30 } }}>
            {item.rating}
          </StackItem>
          <StackItem>{item.description}</StackItem>
          <Separator />
        </Stack>
      )
    })
    return tooltipList
  } else {
    return null
  }
}

const HonosFinalScore = props => {
  const finalScoreStyle = {
    margin: "0px 0px 15px 0px",
  }

  return (
    <div style={finalScoreStyle}>
      <Text variant='xLarge'>
        <b>Final Score: {props.totalScore}</b>
      </Text>
    </div>
  )
}

// end of Control Definition
// ================================================

// ================================================
// Event Handler
// ================================================

const fillAllUnfilledQuestions = (fd: ActiveDataType) => {
  let forms: FormData = {}
  for (const id in fd.field.data) {
    if (/\\d+/.test(id)) {
      const question: HonosItem =  fd.field.data[id]

      if (!question?.selectedDropdownKey) {
        forms = {
          ...forms,
          [id]: {
            ...question,
            selectedDropdownKey: "J",
          },
        }
      }
      if (!question?.selectedKey) {
        forms = {
          ...forms,
          [id]: {
            ...question,
            selectedKey: "9",
            value: 0,
            response: "Unknown or not asked",
            detailResponse: "Unknown or not asked",
          },
        }
      }
    }
  }

  fd.setFormData({
    ...fd,
    field: {
      ...fd.field,
      data: {
        ...fd.field.data,
        ...forms,
      },
    },
  })

}

const buildTooltipLookup = (tooltip, fallbackLookup: Record<string, string> = {}) => {
  const lookup: Record<string, string> = { ...fallbackLookup }

  if (!Array.isArray(tooltip)) return lookup

  for (const item of tooltip) {
    const keySource = item?.rating ?? item?.value
    if (keySource == null) continue
    const key = String(keySource)
    const description =
      typeof item?.description === "string" && item.description.trim()
        ? item.description
        : undefined
    if (!description) continue
    lookup[key] = description
  }

  return lookup
}

const handleKeyUp = (
  id: string,
  e: React.KeyboardEvent,
  selectedQuestion: HonosItem,
  fd: ActiveDataType,
  hasDropdown: boolean,
  disableCount: boolean,
  choiceOptions: any[],
  tooltipLookup: Record<string, string>,
  fallbackDescription: string
) => {
  const selectedOptions = choiceOptions.filter(option => {
    return option.key === e.key
  })

  if (selectedOptions.length === 1) {
    const nextChoiceGroup = window.document.querySelector(
      "#choiceGroup-" + (parseInt(id) + 1)
    ) as HTMLElement

    if (nextChoiceGroup) {
      nextChoiceGroup.focus()
    }

    handleChoiceChanged(
      id,
      selectedOptions[0],
      selectedQuestion,
      fd,
      hasDropdown,
      disableCount,
      tooltipLookup,
      fallbackDescription
    )
  }
}

const handleDropdownChanged = (option, id: string, forms: FormData, modForms: Setter) => {
  const item = forms[id]

  const updatedValue: HonosItem = {
    ...item,
    selectedDropdownKey: option.key,
  }

  modForms({ [id]: updatedValue })
}

const handleChoiceChanged = (
  id: string,
  option,
  question,
  fd: ActiveDataType,
  hasDropdown: boolean,
  disableCount: boolean,
  tooltipLookup: Record<string, string>,
  fallbackDescription: string
) => {
  const item = fd.field.data[id]

  let value = Number(option?.value)
  if (!Number.isFinite(value)) {
    value = parseInt(String(option?.key ?? ""), 10)
  }
  if (!Number.isFinite(value)) {
    value = 0
  }
  if (
    disableCount ||
    (item &&
      ((hasDropdown && !item.selectedDropdownKey) ||
        item.selectedDropdownKey === "J")) ||
    (!item && hasDropdown)
  ) {
    value = 0
  }

  const updatedValue: HonosItem = {
    ...item,
    selectedKey: option.key,
    value,
    response: tooltipLookup[String(option.key)] ?? fallbackDescription,
    detailResponse: tooltipLookup[String(option.key)] ?? fallbackDescription,
  }

  UpdateContext(fd, id, updatedValue)
}

const UpdateContext = (fd, id, values) => {
  fd.setFormData({
    ...fd,
    field: {
      ...fd.field,
      data: {
        ...fd.field.data,
        [id]: values,
      },
    },
  })
}
`,
  './HotspotMapField/index.jsx': `/**
 * HotspotMapField
 *
 * Generic image/SVG map with selectable hotspot overlays.
 * - Supports imageUrl (including base64 data URLs) or inline imageSvg
 * - Stores selection state in fd.field.data[fieldId]
 * - Optional writeback fields for count and selected labels/ids
 * - Optional per-hotspot fieldId writebacks (boolean)
 * - Optional multi-counter summary using hotspot.group values
 *
 * Hotspot config shape:
 * {
 *   id: string,
 *   label?: string,
 *   shape?: "rect" | "circle" | "polygon",
 *   x: number, // percent
 *   y: number, // percent
 *   width?: number, // percent (rect)
 *   height?: number, // percent (rect)
 *   radius?: number, // percent (circle)
 *   points?: [{ x: number, y: number }], // percent (polygon)
 *   fieldId?: string,
 *   group?: string
 * }
 */

const { useMemo, useCallback, useState } = React
const { Label, Text, Stack, PrimaryButton, Dialog, DialogType, DialogFooter } = Fluent

const DEFAULT_MARKER_SIZE = 3
const DEFAULT_MARKER_RADIUS = 1.5
const DEFAULT_MAP_ZOOM_PERCENT = 100
const DEFAULT_MAP_WIDTH_PERCENT = 100
const DEFAULT_MAP_MAX_WIDTH = 560
const DEFAULT_MAP_MIN_HEIGHT = 220

const clampPercent = (value) => {
  const numeric = Number(value)
  if (!Number.isFinite(numeric)) return 0
  if (numeric < 0) return 0
  if (numeric > 100) return 100
  return numeric
}

const normalizeString = (value, fallback = "") => {
  if (typeof value !== "string") return fallback
  const trimmed = value.trim()
  return trimmed.length > 0 ? trimmed : fallback
}

const parseSvgNumber = (value) => {
  const raw = normalizeString(value, "")
  if (!raw) return null
  const match = raw.match(/-?\\d+(\\.\\d+)?/)
  if (!match) return null
  const parsed = Number(match[0])
  return Number.isFinite(parsed) ? parsed : null
}

const normalizeShape = (value) => {
  const normalized = normalizeString(value, "rect").toLowerCase()
  if (normalized === "polygon") return "polygon"
  if (normalized === "circle") return "circle"
  return "rect"
}

const centroidFromPoints = (points) => {
  if (!Array.isArray(points) || points.length === 0) {
    return { x: 0, y: 0 }
  }
  const total = points.reduce(
    (acc, point) => ({
      x: acc.x + point.x,
      y: acc.y + point.y,
    }),
    { x: 0, y: 0 }
  )
  return {
    x: total.x / points.length,
    y: total.y / points.length,
  }
}

const buildFallbackPolygon = (x, y, markerSize) => {
  const half = Math.max(0.5, markerSize / 2)
  return [
    { x: clampPercent(x - half), y: clampPercent(y - half) },
    { x: clampPercent(x + half), y: clampPercent(y - half) },
    { x: clampPercent(x + half), y: clampPercent(y + half) },
    { x: clampPercent(x - half), y: clampPercent(y + half) },
  ]
}

const normalizeHotspotPoints = (value) => {
  if (typeof value === "string") {
    if (!value.trim()) return []
    return value
      .trim()
      .split(/\\s+/)
      .map((entry) => {
        const parts = entry.split(",")
        if (parts.length < 2) return null
        const x = clampPercent(parts[0])
        const y = clampPercent(parts[1])
        return { x, y }
      })
      .filter(Boolean)
  }

  if (!Array.isArray(value)) return []
  return value
    .map((point) => {
      if (!point || typeof point !== "object") return null
      return {
        x: clampPercent(point.x),
        y: clampPercent(point.y),
      }
    })
    .filter(Boolean)
}

const pointsToSvgString = (points) =>
  (Array.isArray(points) ? points : [])
    .map((point) => \`\${point.x},\${point.y}\`)
    .join(" ")

const getHotspotLabelAnchor = (hotspot) => {
  if (hotspot.shape === "circle") {
    return { x: hotspot.x, y: hotspot.y }
  }
  if (hotspot.shape === "polygon" && Array.isArray(hotspot.points) && hotspot.points.length > 0) {
    return centroidFromPoints(hotspot.points)
  }
  return {
    x: hotspot.x + (hotspot.width || 0) / 2,
    y: hotspot.y + (hotspot.height || 0) / 2,
  }
}

const normalizeHotspots = (hotspots, markerSize = DEFAULT_MARKER_SIZE) => {
  if (!Array.isArray(hotspots)) return []
  const usedIds = new Set()

  return hotspots
    .map((hotspot, index) => {
      if (!hotspot || typeof hotspot !== "object") return null
      const rawId = normalizeString(hotspot.id, \`hotspot_\${index + 1}\`)
      let id = rawId
      let suffix = 2
      while (usedIds.has(id)) {
        id = \`\${rawId}_\${suffix}\`
        suffix += 1
      }
      usedIds.add(id)

      const shape = normalizeShape(hotspot.shape)
      const x = clampPercent(hotspot.x)
      const y = clampPercent(hotspot.y)

      const normalizedHotspot = {
        id,
        label: normalizeString(hotspot.label, id),
        shape,
        x,
        y,
        width: markerSize,
        height: markerSize,
        radius: Math.max(DEFAULT_MARKER_RADIUS, markerSize / 2),
        fieldId: normalizeString(hotspot.fieldId, ""),
        group: normalizeString(hotspot.group, ""),
      }

      if (shape === "circle") {
        const radius = clampPercent(
          hotspot.radius != null ? hotspot.radius : markerSize / 2 || DEFAULT_MARKER_RADIUS
        )
        normalizedHotspot.radius = radius > 0 ? radius : DEFAULT_MARKER_RADIUS
      } else if (shape === "polygon") {
        const parsedPoints = normalizeHotspotPoints(hotspot.points)
        const points = parsedPoints.length >= 3 ? parsedPoints : buildFallbackPolygon(x, y, markerSize)
        normalizedHotspot.points = points
        const centroid = centroidFromPoints(points)
        normalizedHotspot.x = centroid.x
        normalizedHotspot.y = centroid.y
      } else {
        const width = clampPercent(hotspot.width != null ? hotspot.width : markerSize)
        const height = clampPercent(hotspot.height != null ? hotspot.height : markerSize)
        normalizedHotspot.width = width > 0 ? width : markerSize
        normalizedHotspot.height = height > 0 ? height : markerSize
      }

      return normalizedHotspot
    })
    .filter(Boolean)
}

const ensureResponsiveSvg = (markup) => {
  const input = typeof markup === "string" ? markup.trim() : ""
  if (!input) return ""
  if (!/<svg[\\s>]/i.test(input)) return input

  // If the root <svg> already defines inline style, keep as-is.
  if (/<svg[^>]*style\\s*=/i.test(input)) return input

  return input.replace(
    /<svg\\b/i,
    '<svg style="width:100%;height:auto;display:block;max-width:100%;"'
  )
}

const buildCountsByGroup = (selectedIds, hotspotsById) => {
  const counts = {}
  selectedIds.forEach((id) => {
    const hotspot = hotspotsById.get(id)
    if (!hotspot) return
    const group = hotspot.group || "default"
    counts[group] = (counts[group] || 0) + 1
  })
  return counts
}

const buildMapValue = (selectedIds, hotspots, hotspotsById) => {
  const byHotspot = {}
  const selectedLabels = []
  hotspots.forEach((hotspot) => {
    const isSelected = selectedIds.has(hotspot.id)
    byHotspot[hotspot.id] = isSelected
    if (isSelected) {
      selectedLabels.push(hotspot.label || hotspot.id)
    }
  })

  return {
    selectedIds: hotspots.filter((hotspot) => selectedIds.has(hotspot.id)).map((hotspot) => hotspot.id),
    selectedLabels,
    selectedCount: selectedLabels.length,
    byHotspot,
    countsByGroup: buildCountsByGroup(selectedIds, hotspotsById),
    updatedAt: new Date().toISOString(),
  }
}

const createHotspotMapConfig = (config = {}) => ({
  imageUrl: normalizeString(config.imageUrl, ""),
  imageSvg: normalizeString(config.imageSvg, ""),
  imageAlt: normalizeString(config.imageAlt, "Map"),
  allowMultiSelect: config.allowMultiSelect !== false,
  showSummary: config.showSummary !== false,
  showSelectedLabels: config.showSelectedLabels === true,
  showHotspotLabels: config.showHotspotLabels === true,
  totalCountLabel: normalizeString(config.totalCountLabel, "Selected"),
  openInModal: config.openInModal === true,
  modalButtonText: normalizeString(config.modalButtonText, "Open Map"),
  modalTitle: normalizeString(config.modalTitle, ""),
  modalMinWidth:
    Number.isFinite(Number(config.modalMinWidth)) && Number(config.modalMinWidth) > 0
      ? Math.max(360, Number(config.modalMinWidth))
      : 760,
  mapZoomPercent:
    Number.isFinite(Number(config.mapZoomPercent)) && Number(config.mapZoomPercent) > 0
      ? Math.max(25, Math.min(300, Number(config.mapZoomPercent)))
      : DEFAULT_MAP_ZOOM_PERCENT,
  mapWidthPercent:
    Number.isFinite(Number(config.mapWidthPercent)) && Number(config.mapWidthPercent) > 0
      ? Math.max(20, Math.min(100, Number(config.mapWidthPercent)))
      : DEFAULT_MAP_WIDTH_PERCENT,
  mapMaxWidth:
    Number.isFinite(Number(config.mapMaxWidth)) && Number(config.mapMaxWidth) > 0
      ? Math.max(220, Number(config.mapMaxWidth))
      : DEFAULT_MAP_MAX_WIDTH,
  mapMinHeight:
    Number.isFinite(Number(config.mapMinHeight)) && Number(config.mapMinHeight) > 0
      ? Math.max(120, Number(config.mapMinHeight))
      : DEFAULT_MAP_MIN_HEIGHT,
  markerSize:
    Number.isFinite(Number(config.markerSize)) && Number(config.markerSize) > 0
      ? Number(config.markerSize)
      : DEFAULT_MARKER_SIZE,
  hotspots: normalizeHotspots(config.hotspots, config.markerSize ?? DEFAULT_MARKER_SIZE),
})

const importSvgHotspots = (svgMarkup) => {
  if (!svgMarkup || typeof svgMarkup !== "string") return []
  if (typeof DOMParser === "undefined") return []

  try {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgMarkup, "image/svg+xml")
    const svg = doc.querySelector("svg")
    if (!svg) return []

    const viewBoxRaw = normalizeString(svg.getAttribute("viewBox"), "")
    const viewBoxParts = viewBoxRaw.split(/\\s+/).map((part) => Number(part))
    const vbWidth = Number.isFinite(viewBoxParts[2]) ? viewBoxParts[2] : null
    const vbHeight = Number.isFinite(viewBoxParts[3]) ? viewBoxParts[3] : null

    const widthAttr = parseSvgNumber(svg.getAttribute("width"))
    const heightAttr = parseSvgNumber(svg.getAttribute("height"))
    const sourceWidth = Number.isFinite(widthAttr) && widthAttr > 0 ? widthAttr : vbWidth || 100
    const sourceHeight = Number.isFinite(heightAttr) && heightAttr > 0 ? heightAttr : vbHeight || 100

    const toXPercent = (value) => clampPercent((Number(value) / sourceWidth) * 100)
    const toYPercent = (value) => clampPercent((Number(value) / sourceHeight) * 100)

    const elements = Array.from(
      svg.querySelectorAll("rect[data-hotspot-id], rect[id], circle[data-hotspot-id], circle[id], ellipse[data-hotspot-id], ellipse[id], polygon[data-hotspot-id], polygon[id], polyline[data-hotspot-id], polyline[id]")
    )

    return elements
      .map((element, index) => {
        const rawId = normalizeString(
          element.getAttribute("data-hotspot-id"),
          normalizeString(element.getAttribute("id"), \`hotspot_\${index + 1}\`)
        )
        const rawLabel = normalizeString(element.getAttribute("data-hotspot-label"), rawId)
        const tagName = element.tagName.toLowerCase()

        if (tagName === "polygon" || tagName === "polyline") {
          const pointsAttr = normalizeString(element.getAttribute("points"), "")
          const points = pointsAttr
            .split(/\\s+/)
            .map((entry) => {
              const pair = entry.split(",")
              if (pair.length < 2) return null
              return {
                x: toXPercent(pair[0]),
                y: toYPercent(pair[1]),
              }
            })
            .filter(Boolean)
          if (points.length < 3) return null
          const centroid = centroidFromPoints(points)
          return {
            id: rawId,
            label: rawLabel,
            shape: "polygon",
            x: centroid.x,
            y: centroid.y,
            points,
          }
        }

        if (tagName === "rect") {
          const x = toXPercent(element.getAttribute("x") || 0)
          const y = toYPercent(element.getAttribute("y") || 0)
          const width = toXPercent(element.getAttribute("width") || 0)
          const height = toYPercent(element.getAttribute("height") || 0)
          return {
            id: rawId,
            label: rawLabel,
            shape: "rect",
            x,
            y,
            width: width > 0 ? width : DEFAULT_MARKER_SIZE,
            height: height > 0 ? height : DEFAULT_MARKER_SIZE,
          }
        }

        const cx = toXPercent(element.getAttribute("cx") || 0)
        const cy = toYPercent(element.getAttribute("cy") || 0)
        const r = tagName === "ellipse"
          ? (toXPercent(element.getAttribute("rx") || 0) + toYPercent(element.getAttribute("ry") || 0)) / 2
          : toXPercent(element.getAttribute("r") || 0)

        return {
          id: rawId,
          label: rawLabel,
          shape: "circle",
          x: cx,
          y: cy,
          radius: r > 0 ? r : DEFAULT_MARKER_RADIUS,
        }
      })
      .filter(Boolean)
  } catch (error) {
    return []
  }
}

const HotspotMapField = ({
  fieldId,
  label,
  imageUrl = "",
  imageSvg = "",
  imageAlt = "Map",
  hotspots = [],
  allowMultiSelect = true,
  showSummary = true,
  showSelectedLabels = false,
  showHotspotLabels = false,
  totalCountLabel = "Selected",
  openInModal = false,
  modalButtonText = "Open Map",
  modalTitle = "",
  modalMinWidth = 760,
  mapZoomPercent = DEFAULT_MAP_ZOOM_PERCENT,
  mapWidthPercent = DEFAULT_MAP_WIDTH_PERCENT,
  mapMaxWidth = DEFAULT_MAP_MAX_WIDTH,
  mapMinHeight = DEFAULT_MAP_MIN_HEIGHT,
  markerSize = DEFAULT_MARKER_SIZE,
  totalCountFieldId,
  selectedIdsFieldId,
  selectedLabelsFieldId,
  required = false,
  readOnly = false,
}) => {
  const [fd] = useActiveData()
  const [isModalOpen, setIsModalOpen] = useState(false)
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  const normalizedHotspots = useMemo(
    () => normalizeHotspots(hotspots, markerSize),
    [hotspots, markerSize]
  )
  const hotspotsById = useMemo(() => {
    const map = new Map()
    normalizedHotspots.forEach((hotspot) => map.set(hotspot.id, hotspot))
    return map
  }, [normalizedHotspots])

  const mapValue = fd?.field?.data?.[fieldId]
  const selectedIds = useMemo(() => {
    if (!Array.isArray(mapValue?.selectedIds)) return new Set()
    return new Set(
      mapValue.selectedIds
        .map((value) => normalizeString(value, ""))
        .filter((value) => value.length > 0)
    )
  }, [mapValue])

  const commitSelection = useCallback((nextSelectedIds) => {
    if (!fieldId || !fd?.setFormData) return

    const value = buildMapValue(nextSelectedIds, normalizedHotspots, hotspotsById)
    const hasSelections = value.selectedCount > 0
    const selectedIdsCsv = value.selectedIds.join(",")
    const selectedLabelsCsv = value.selectedLabels.join(", ")

    fd.setFormData(
      produce((draft) => {
        if (!draft.field) draft.field = { data: {}, status: {}, history: [] }
        if (!draft.field.data) draft.field.data = {}
        draft.field.data[fieldId] = hasSelections ? value : null

        if (totalCountFieldId) {
          draft.field.data[totalCountFieldId] = value.selectedCount
        }
        if (selectedIdsFieldId) {
          draft.field.data[selectedIdsFieldId] = selectedIdsCsv
        }
        if (selectedLabelsFieldId) {
          draft.field.data[selectedLabelsFieldId] = selectedLabelsCsv
        }

        normalizedHotspots.forEach((hotspot) => {
          if (!hotspot.fieldId) return
          draft.field.data[hotspot.fieldId] = value.byHotspot[hotspot.id] === true
        })
      })
    )
  }, [
    fd,
    fieldId,
    normalizedHotspots,
    hotspotsById,
    selectedIdsFieldId,
    selectedLabelsFieldId,
    totalCountFieldId,
  ])

  const handleToggleHotspot = useCallback((hotspotId) => {
    if (readOnly) return
    const next = new Set(selectedIds)

    if (allowMultiSelect) {
      if (next.has(hotspotId)) {
        next.delete(hotspotId)
      } else {
        next.add(hotspotId)
      }
    } else if (next.has(hotspotId)) {
      next.clear()
    } else {
      next.clear()
      next.add(hotspotId)
    }

    commitSelection(next)
  }, [allowMultiSelect, commitSelection, readOnly, selectedIds])

  const handleHotspotKeyDown = useCallback((event, hotspotId) => {
    if (readOnly) return
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault()
      handleToggleHotspot(hotspotId)
    }
  }, [handleToggleHotspot, readOnly])

  const responsiveSvg = useMemo(() => ensureResponsiveSvg(imageSvg), [imageSvg])
  const selectedLabels = Array.isArray(mapValue?.selectedLabels) ? mapValue.selectedLabels : []
  const selectedCount = Number.isFinite(mapValue?.selectedCount) ? mapValue.selectedCount : selectedIds.size
  const countsByGroup = useMemo(() => {
    if (mapValue?.countsByGroup && typeof mapValue.countsByGroup === "object") {
      return mapValue.countsByGroup
    }
    return buildCountsByGroup(selectedIds, hotspotsById)
  }, [hotspotsById, mapValue?.countsByGroup, selectedIds])
  const summaryGroups = useMemo(() => {
    const names = new Set()
    normalizedHotspots.forEach((hotspot) => {
      const group = normalizeString(hotspot.group, "")
      if (group) names.add(group)
    })
    return Array.from(names).sort((a, b) => a.localeCompare(b))
  }, [normalizedHotspots])
  const resolvedMapZoomPercent = Math.max(25, Math.min(300, Number(mapZoomPercent) || DEFAULT_MAP_ZOOM_PERCENT))
  const zoomFactor = resolvedMapZoomPercent / 100
  const resolvedMapWidthPercent = Math.max(20, Math.min(100, Number(mapWidthPercent) || DEFAULT_MAP_WIDTH_PERCENT))
  const resolvedMapMaxWidth = Math.max(220, Number(mapMaxWidth) || DEFAULT_MAP_MAX_WIDTH)
  const resolvedMapMinHeight = Math.max(120, Number(mapMinHeight) || DEFAULT_MAP_MIN_HEIGHT)
  const resolvedModalMinWidth = Math.max(360, Number(modalMinWidth) || 760)

  const panelStyle = {
    border: \`1px solid \${isDarkMode ? "#404040" : "#d0d7de"}\`,
    borderRadius: "8px",
    backgroundColor: isDarkMode ? "#1f1f1f" : "#ffffff",
    padding: "10px",
  }

  const mapFrameStyle = {
    position: "relative",
    width: \`\${resolvedMapWidthPercent}%\`,
    maxWidth: \`\${resolvedMapMaxWidth * zoomFactor}px\`,
    minHeight: \`\${resolvedMapMinHeight * zoomFactor}px\`,
    margin: "0 auto",
    borderRadius: "6px",
    overflow: "hidden",
    border: \`1px solid \${isDarkMode ? "#333333" : "#e0e0e0"}\`,
    backgroundColor: isDarkMode ? "#171717" : "#fafafa",
  }

  const overlayStyle = {
    position: "absolute",
    inset: 0,
  }

  const renderMapFrame = () => (
    <div style={mapFrameStyle}>
      {responsiveSvg ? (
        <div
          style={{ width: "100%", lineHeight: 0, pointerEvents: "none" }}
          dangerouslySetInnerHTML={{ __html: responsiveSvg }}
        />
      ) : imageUrl ? (
        <img
          src={imageUrl}
          alt={imageAlt}
          style={{ display: "block", width: "100%", height: "auto", pointerEvents: "none" }}
        />
      ) : (
        <div
          style={{
            minHeight: \`\${resolvedMapMinHeight}px\`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: isDarkMode ? "#9ca3af" : "#6b7280",
            fontSize: "12px",
          }}
        >
          Configure imageUrl or imageSvg to render the map.
        </div>
      )}

      <div style={overlayStyle}>
        <svg
          viewBox="0 0 100 100"
          preserveAspectRatio="none"
          style={{ width: "100%", height: "100%", display: "block" }}
        >
          {normalizedHotspots.map((hotspot) => {
            const isSelected = selectedIds.has(hotspot.id)
            const stroke = isSelected ? "#1d4ed8" : "#374151"
            const fill = isSelected ? "rgba(37, 99, 235, 0.4)" : "rgba(255, 255, 255, 0.2)"
            const labelAnchor = getHotspotLabelAnchor(hotspot)

            return (
              <g
                key={hotspot.id}
                role="button"
                tabIndex={readOnly ? -1 : 0}
                aria-pressed={isSelected}
                onMouseDown={(event) => event.preventDefault()}
                onClick={() => handleToggleHotspot(hotspot.id)}
                onKeyDown={(event) => handleHotspotKeyDown(event, hotspot.id)}
                style={{
                  cursor: readOnly ? "default" : "pointer",
                  outline: "none",
                }}
              >
                <title>{hotspot.label || hotspot.id}</title>
                {hotspot.shape === "circle" ? (
                  <circle
                    cx={hotspot.x}
                    cy={hotspot.y}
                    r={Math.max(0.5, hotspot.radius)}
                    fill={fill}
                    stroke={stroke}
                    strokeWidth={0.5}
                  />
                ) : hotspot.shape === "polygon" ? (
                  <polygon
                    points={pointsToSvgString(hotspot.points)}
                    fill={fill}
                    stroke={stroke}
                    strokeWidth={0.5}
                  />
                ) : (
                  <rect
                    x={hotspot.x}
                    y={hotspot.y}
                    width={Math.max(0.5, hotspot.width)}
                    height={Math.max(0.5, hotspot.height)}
                    rx={0.5}
                    fill={fill}
                    stroke={stroke}
                    strokeWidth={0.5}
                  />
                )}
                {showHotspotLabels ? (
                  <text
                    x={labelAnchor.x}
                    y={labelAnchor.y}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    style={{
                      fontSize: "2.2px",
                      fontWeight: 700,
                      fill: isSelected ? "#0f172a" : "#1f2937",
                      pointerEvents: "none",
                      userSelect: "none",
                    }}
                  >
                    {hotspot.label || hotspot.id}
                  </text>
                ) : null}
              </g>
            )
          })}
        </svg>
      </div>
    </div>
  )

  const renderSummary = () => {
    if (!showSummary) return null
    return (
      <Stack tokens={{ childrenGap: 4 }}>
        <Text variant="small">
          {totalCountLabel || "Selected"}: <strong>{selectedCount}</strong>
        </Text>
        {summaryGroups.map((groupName) => (
          <Text
            key={groupName}
            variant="small"
            styles={{ root: { fontSize: "11px", color: isDarkMode ? "#d1d5db" : "#4b5563" } }}
          >
            {groupName}: <strong>{Number(countsByGroup[groupName] || 0)}</strong>
          </Text>
        ))}
        {showSelectedLabels && selectedLabels.length > 0 && (
          <Text variant="small" styles={{ root: { fontSize: "11px", color: isDarkMode ? "#d1d5db" : "#4b5563" } }}>
            {selectedLabels.join(", ")}
          </Text>
        )}
      </Stack>
    )
  }

  return (
    <Stack tokens={{ childrenGap: 8 }} style={panelStyle}>
      {label && (
        <Label required={required} styles={{ root: { marginBottom: 0 } }}>
          {label}
        </Label>
      )}
      {openInModal ? (
        <>
          <PrimaryButton
            text={modalButtonText || "Open Map"}
            onClick={() => setIsModalOpen(true)}
            disabled={readOnly && normalizedHotspots.length === 0}
          />
          {renderSummary()}
          <Dialog
            hidden={!isModalOpen}
            onDismiss={() => setIsModalOpen(false)}
            dialogContentProps={{
              type: DialogType.largeHeader,
              title: modalTitle || label || "Map Selection",
            }}
            modalProps={{
              isBlocking: false,
              styles: {
                main: {
                  minWidth: \`\${resolvedModalMinWidth}px\`,
                  maxWidth: "92vw",
                },
              },
            }}
          >
            <Stack tokens={{ childrenGap: 10 }}>
              {renderMapFrame()}
              {renderSummary()}
            </Stack>
            <DialogFooter>
              <PrimaryButton text="Done" onClick={() => setIsModalOpen(false)} />
            </DialogFooter>
          </Dialog>
        </>
      ) : (
        <>
          {renderMapFrame()}
          {renderSummary()}
        </>
      )}
    </Stack>
  )
}

HotspotMapField.createConfig = createHotspotMapConfig
HotspotMapField.importSvgHotspots = importSvgHotspots
HotspotMapField.normalizeHotspots = normalizeHotspots
`,
  './LongTermMedications/index.jsx': `/**
 * Display a list of long term medication orders for this patient.
 */
const LongTermMedications = ({
  id = "longTermMedicationOrders",
  label = "Long term medications",
  selectText = "Select relevant medications",
  selectionType = "none",
  listSelectionProps,
  ...props
}:Props) => {

  return (
    <ListSelection
      {...{id, label, selectText, selectionType, columns: longTermMedicationColumns}}
      {...props}
    />
  )
}

const longTermMedicationColumns: ColumnSelection = [
  {
    id: "longTermMedicationOrderId",
    type: "key",
  },
  {
    title: "Start",
    id: "startDate",
    type: "date",
  },
  {
    title: "End",
    id: "endDate",
    type: "date",
  },
  {
    title: "Medication",
    id: "medication",
    type: "string",
  },
  {
    title: "Dose Frequency",
    id: "doseFrequency",
    type: "string",
  },
]

const LongTermMedicationsFields = "longTermMedicationOrderId startDate endDate medication doseFrequency"
`,
  './MoisPatientReviewLink/index.jsx': `/**
 * MoisPatientReviewLink
 * Displays a hyperlink and confirmation checkbox for patient handouts/information sheets.
 */

const { Stack, Checkbox, Link, Text } = Fluent

const normalizeChecked = (value) => {
  if (value === true || value === 1) return true
  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase()
    return normalized === 'true' || normalized === 'yes' || normalized === 'y' || normalized === '1'
  }
  return false
}

const MoisPatientReviewLink = ({
  fieldId = 'reviewedAndGivenToPatient',
  section,
  href = '',
  linkText = 'Open patient handout',
  linkAriaLabel,
  confirmEnabled = true,
  label = 'I confirm this was reviewed and given to the patient',
  required = false,
  disabled = false,
  openInNewTab = true,
  rel = 'noopener noreferrer',
  showLink = true,
  linkBeforeCheckbox = true,
  note,
  onChange,
  stackTokens = { childrenGap: 8 },
  linkStyles,
  checkboxProps = {},
}) => {
  section = MoisHooks.useSection(section)
  const [fd] = useActiveData()
  const active = section.activeSelector(fd) || {}
  const checked = normalizeChecked(active[fieldId])

  const handleCheckedChange = (_event, isChecked) => {
    const nextValue = !!isChecked

    if (fd?.setFormData) {
      fd.setFormData((draft) => {
        const draftActive = section.activeSelector(draft)
        if (draftActive) {
          draftActive[fieldId] = nextValue
        }
      })
    }

    if (typeof onChange === 'function') {
      onChange(nextValue)
    }
  }

  const linkElement = showLink && href ? (
    <Link
      href={href}
      target={openInNewTab ? '_blank' : undefined}
      rel={openInNewTab ? rel : undefined}
      aria-label={linkAriaLabel || linkText}
      styles={linkStyles}
    >
      {linkText}
    </Link>
  ) : null

  return (
    <div id={fieldId} data-field-id={fieldId}>
      <Stack tokens={stackTokens}>
        {linkBeforeCheckbox ? linkElement : null}
        {confirmEnabled ? (
          <Checkbox
            {...checkboxProps}
            label={label}
            required={required}
            checked={checked}
            disabled={disabled}
            onChange={handleCheckedChange}
          />
        ) : null}
        {linkBeforeCheckbox ? null : linkElement}
        {note ? <Text variant="small">{note}</Text> : null}
      </Stack>
    </div>
  )
}
`,
  './MseAbc/index.jsx': `
const MseAbc = () => (<>

  <SimpleCodeChecklist
    fieldId='dress'
    label='Dress'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-DRESS"
    optionList={[
      { key: "Cleanliness appropriate", text: "Cleanliness appropriate" },
      { key: "Neat", text: "Neat" },
      { key: "Garments appropriate", text: "Garments appropriate" },
      { key: "Condition of clothing - Good", text: "Condition of clothing - Good" },
      { key: "Condition of clothing - Poor", text: "Condition of clothing - Poor" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='grooming'
    label='Grooming'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-GROOMING"
    optionList={[
      { key: "Clean", text: "Clean" },
      { key: "Neat", text: "Neat" },
      { key: "Dirty", text: "Dirty" },
      { key: "Overly meticulous", text: "Overly meticulous" },
      { key: "Disheveled", text: "Disheveled" },
      { key: "Unkempt", text: "Unkempt" },
      { key: "Hair styled", text: "Hair styled" },
      { key: "Unshaven", text: "Unshaven" },
      { key: "Make-up", text: "Make-up" },
      { key: "Malodorous", text: "Malodorous" },
    ]}
  />
  <SimpleCodeChecklist
    codeSystem="AIHS-YESNO"
    autoHotKey
    optionSize="small"
    fieldId="ableToFocus"
    label="Able to focus on questions"
  />
  <SimpleCodeChecklist
    fieldId='manners'
    label='Manners'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-MANNERS"
    optionList={[
      { key: "Pleasant", text: "Pleasant" },
      { key: "Cooperative", text: "Cooperative" },
      { key: "Guarded", text: "Guarded" },
      { key: "Friendly", text: "Friendly" },
      { key: "Suspicious", text: "Suspicious" },
      { key: "Glib", text: "Glib" },
      { key: "Angry", text: "Angry" },
      { key: "Seductive", text: "Seductive" },
      { key: "Evasive", text: "Evasive" },
      { key: "Hostile", text: "Hostile" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='attentiveness'
    label='Attentiveness to Examiner'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-ATTENTIVENESS"
    optionList={[
      { key: "Apathetic", text: "Apathetic" },
      { key: "Attentive", text: "Attentive" },
      { key: "Bored", text: "Bored" },
      { key: "Disinterested", text: "Disinterested" },
      { key: "Distractible", text: "Distractible" },
      { key: "Drowsy", text: "Drowsy" },
      { key: "Internally preoccupied", text: "Internally preoccupied" },
      { key: "Withdrawn", text: "Withdrawn" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='position'
    label='Position during assessment'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-POSITION"
    optionList={[
      { key: "Appropriate to context", text: "Appropriate to context" },
      { key: "Lying", text: "Lying" },
      { key: "Sitting", text: "Sitting" },
      { key: "Standing", text: "Standing" },
      { key: "Kneeling", text: "Kneeling" },
      { key: "Restlessness", text: "Restlessness" },
      { key: "Tense", text: "Tense" },
      { key: "Bizarre/Unusual position", text: "Bizarre/Unusual position" },
      { key: "Constantly changing", text: "Constantly changing" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='cooperation'
    label='Cooperation'
    codeSystem="MSE-COOPERATION"
    optionList={[
      { key: "Cooperative", text: "Cooperative" },
      { key: "Uncooperative", text: "Uncooperative" },
      { key: "Friendly", text: "Friendly" },
      { key: "Hostile", text: "Hostile" },
      { key: "Defensive", text: "Defensive" },
      { key: "Antagonistic", text: "Antagonistic" },
      { key: "Sullen", text: "Sullen" },
      { key: "Withdrawn", text: "Withdrawn" },
      { key: "Seductive", text: "Seductive" },
      { key: "Evasive", text: "Evasive" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='eyeContact'
    label='Eye Contact'
    showOtherOption
    codeSystem="MSE-EYECONTACT"
    optionList={[
      { key: "Appropriate", text: "Appropriate" },
      { key: "Avoids eye contact", text: "Avoids eye contact" },
      { key: "Stares", text: "Stares" },
      { key: "Eyes closed", text: "Eyes closed" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='catatonia'
    label='Catatonia'
    showOtherOption
    size="large"
    codeSystem="MSE-CATATONIA"
    optionList={[
      { key: "None", text: "None" },
      { key: "Excitement", text: "Excitement" },
      { key: "Stupor", text: "Stupor" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='unusualMovements'
    label='Unusual movements'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-UNUSUALMOVEMENTS"
    optionList={[
      { key: "None", text: "None" },
      { key: "Grimaces", text: "Grimaces" },
      { key: "Lip smacking", text: "Lip smacking" },
      { key: "Mannerisms", text: "Mannerisms" },
      { key: "Tics", text: "Tics" },
      { key: "Tongue thrust", text: "Tongue thrust" },
      { key: "Tremor", text: "Tremor" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='gait'
    label='Gait'
    selectionType="multiple"
    showOtherOption
    size="large"
    codeSystem="MSE-GAIT"
    optionList={[
      { key: "Normal", text: "Normal" },
      { key: "Broad-based", text: "Broad-based" },
      { key: "Hesitation", text: "Hesitation" },
      { key: "Limping", text: "Limping" },
      { key: "Shuffling", text: "Shuffling" },
      { key: "Stumbling", text: "Stumbling" },
    ]}
  />
  <SimpleCodeChecklist
    fieldId='posture'
    label='Posture'
    showOtherOption
    size="large"
    conditionalCodes={['Agitation']}
    codeSystem="MSE-POSTURE"
    optionList={[
      { key: "Comfortable", text: "Comfortable" },
      { key: "Agitation", text: "Psychomotor agitation" },
      { key: "Retardation", text: "Psychomotor retardation" },
      { key: "Rigid", text: "Rigid" },
      { key: "Slouched", text: "Slouched" },
      { key: "Slumped", text: "Slumped" },
      { key: "Threatening", text: "Threatening" },
    ]}
  >
    <SimpleCodeChecklist
      fieldId='agitation'
      label='Psychomotor agitation'
      selectionType="multiple"
      showOtherOption
      size="large"
      codeSystem="MSE-AGITATION"
      optionList={[
        { key: "Compulsive", text: "Compulsive" },
        { key: "Excessive", text: "Excessive movement" },
        { key: "Pacing", text: "Pacing" },
        { key: "Picking", text: "Picking at skin/clothing" },
        { key: "Rocking", text: "Rocking" },
        { key: "Unable to sit still", text: "Unable to sit still" },
        { key: "Wringing hands", text: "Wringing hands" },
      ]}
    />
  </SimpleCodeChecklist>

</>)

const MseAbcSchema = {
  dress:                    { $ref: "#/definitions/codings" },
  grooming:                 { $ref: "#/definitions/codings" },
  ableToFocus:              { $ref: "#/definitions/ynu" },
  manners:                  { $ref: "#/definitions/codings" },
  attentiveness:            { $ref: "#/definitions/codings" },
  position:                 { $ref: "#/definitions/codings" },
  cooperation:              { $ref: "#/definitions/coding" },
  eyeContact:               { $ref: "#/definitions/coding" },
  catatonia:                { $ref: "#/definitions/coding" },
  unusualMovements:         { $ref: "#/definitions/codings" },
  gait:                     { $ref: "#/definitions/codings" },
  posture:                  { $ref: "#/definitions/coding" },
  agitation:                { $ref: "#/definitions/codings" },
}

const mseAbcPrompts = {
  dress:                    "Dress",
  grooming:                 "Grooming",
  ableToFocus:              "Able to focus on questions",
  manners:                  "Manners",
  attentiveness:            "Attentiveness to Examiner",
  position:                 "Position during assessment",
  cooperation:              "Cooperation",
  eyeContact:               "Eye Contact",
  catatonia:                "Catatonia",
  unusualMovements:         "Unusual Movements",
  gait:                     "Gait",
  posture:                  "Posture",
  agitation:                "Psychomotor agitation",
}

`,
  './MseEr/index.jsx': `
const MseEr = () => (<>
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='suicidalIdeation'
          label='Suicidal ideations'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='safetyPlanAvailable'
          label='Safety plan available'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='suicideAttemptHistory'
          label='Suicide attempts in the past'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='suicideAttempt24hrs'
          label='Suicide attempts or significant intentional self-harm in 24 hours of admission'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='homicidalIdeation'
          label='Homicidal Ideations'
        />
        <SimpleCodeChecklist
          fieldId='selfHarm'
          label='Self-Harm'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-SELFHARM"
          optionList={[
            { key: "None", text: "None" },
            { key: "Burning", text: "Burning" },
            { key: "Cutting", text: "Cutting" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='congruentInfo'
          label='Subjective and objective information congruent'
        />

        <SubTitle text="Risk Assessments" />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='fallRisk'
          label='Falls risk assessment'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='substanceUseRisk'
          label='Substance use risk assessment'
        />
        <Fluent.Text>
          <i>* Ensure to document in the "Histories" tab under "Social"</i>
        </Fluent.Text>
        
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='suicideRisk'
          label='Suicide risk assessment'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='violentBehaviourRisk'
          label='Violent behaviour risk assessment'
        />
</>)

const MseErSchema = {
  'suicidalIdeation':       { $ref: "#/definitions/ynu" },
  'safetyPlanAvailable':    { $ref: "#/definitions/ynu" },
  'suicideAttemptHistory':  { $ref: "#/definitions/ynu" },
  'suicideAttempt24hrs':    { $ref: "#/definitions/ynu" },
  'homicidalIdeation':      { $ref: "#/definitions/ynu" },
  'selfHarm':               { $ref: "#/definitions/codings" },
  'congruentInfo':          { $ref: "#/definitions/ynu" },
  'fallRisk':               { $ref: "#/definitions/ynu" },
  'substanceUseRisk':       { $ref: "#/definitions/ynu" },
  'suicideRisk':            { $ref: "#/definitions/ynu" },
  'violentBehaviourRisk':   { $ref: "#/definitions/ynu" },
}

const mseErPrompts = {
  'suicidalIdeation':       "Suicidal ideation",
  'safetyPlanAvailable':    "Safety plan available",
  'suicideAttemptHistory':  "Suicide attempts in the past",
  'suicideAttempt24hrs':    "Suicide attempts or significant intentional self-harm in 24 hours of admission",
  'homicidalIdeation':      "Homicidal ideations",
  'selfHarm':               "Self-Harm",
  'congruentInfo':          "Subjective and objective information congruent",
  'fallRisk':               "Falls risk assessment",
  'substanceUseRisk':       "Substance use risk assessment",
  'suicideRisk':            "Suicide risk assessment",
  'violentBehaviourRisk':   "Violent Behaviour risk assessment",
}
`,
  './MseLick/index.jsx': `
const MseLick = () => (<>

        <SimpleCodeChecklist
          fieldId='alertness'
          label='Alertness'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-ALERTNESS"
          optionList={[
            {
              key: "Conscious - Orientated to person",
              text: "Conscious - Orientated to person",
            },
            {
              key: "Conscious - Orientated to place",
              text: "Conscious - Orientated to place",
            },
            {
              key: "Conscious - Orientated to time",
              text: "Conscious - Orientated to time",
            },
            {
              key: "Conscious - Aware of why they are here",
              text: "Conscious - Aware of why they are here",
            },
            {
              key: "Not-Conscious - Easily aroused",
              text: "Not-Conscious - Easily aroused",
            },
            {
              key: "Not-Conscious - Arouses to verbal stimuli",
              text: "Not-Conscious - Arouses to verbal stimuli",
            },
            {
              key: "Not-Conscious - Arouses to tactile stimuli",
              text: "Not-Conscious - Arouses to tactile stimuli",
            },
            {
              key: "Not-Conscious - Arouses to pain stimuli",
              text: "Not-Conscious - Arouses to pain stimuli",
            },
            { key: "Unable to arouse", text: "Unable to arouse" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='cognitiveIssues'
          label='Cognitive issues'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-COGNITIVE"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Confused", text: "Confused" },
            { key: "Daydreaming", text: "Daydreaming" },
            { key: "Lack of abstract thought", text: "Lack of abstract thought" },
            { key: "Poor attention span", text: "Poor attention span" },
            { key: "Poor concentration", text: "Poor concentration" },
            { key: "Poor memory", text: "Poor memory" },
            { key: "Unable to generate ideas", text: "Unable to generate ideas" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='memoryIssues'
          label='Memory issues'
          selectionType="multiple"
          optionSize="small"
          codeSystem="MSE-MEMORY"
          optionList={[
            { key: "None", text: "None" },
            { key: "Short term", text: "Short term" },
            { key: "Long term", text: "Long term" },
          ]}
        />
        <TextArea
          fieldId='memoryIssueDuration'
          label='Length of duration of memory issues'
          size="medium"
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='awarenessOfIllness'
          label='Awareness of illness'
        />
        <SimpleCodeChecklist
          fieldId='selfConcept'
          label='Self-Concept'
          optionSize="small"
          codeSystem="MSE-SELFCONCEPT"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Overly self critical", text: "Overly self critical" },
            { key: "Poor self image", text: "Poor self image" },
          ]}
        />
</>)

const MseLickSchema = {
  'alertness':            { $ref: "#/definitions/codings" },
  'cognitiveIssues':      { $ref: "#/definitions/codings" },
  'memoryIssues':         { $ref: "#/definitions/codings" },
  'memoryIssueDuration':  { type: "string" },
  'awarenessOfIllness':   { $ref: "#/definitions/ynu" },
  'selfConcept':          { $ref: "#/definitions/coding" },
}

const mseLickPrompts = {
  'alertness':            "Alertness",
  'cognitiveIssues':      "Cognitive issues",
  'memoryIssues':         "Memory issues",
  'memoryIssueDuration':  "Memory issue duration",  // Note: text
  'awarenessOfIllness':   "Awareness of illness",
  'selfConcept':          "Self-Concept",
}
`,
  './MseStamp/index.jsx': `
const MseSpeech = () => (<>

        <SimpleCodeChecklist
          fieldId='speechRate'
          label='Rate'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-SPEECHRATE"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Hesitant", text: "Hesitant" },
            { key: "Long pauses before answering questions", text: "Long pauses before answering questions" },
            { key: "Pressured", text: "Pressured" },
            { key: "Rapid", text: "Rapid" },
            { key: "Slowed", text: "Slowed" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='speechRhythm'
          label='Rhythm'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-SPEECHRHYTHM"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Monotonous", text: "Monotonous" },
            { key: "Stuttering", text: "Stuttering" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='speechVolume'
          label='Volume'
          codeSystem="MSE-SPEECHVOLUME"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Loud", text: "Loud" },
            { key: "Soft", text: "Soft" },
            { key: "Whispered", text: "Whispered" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='speechSpontaneity'
          label='Spontaneity'
        />
        <SimpleCodeChecklist
          fieldId='speechAmount'
          label='Amount'
          codeSystem="MSE-SPEECHAMOUNT"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Hyper-talkative", text: "Hyper-talkative" },
            { key: "Monosyllabic", text: "Monosyllabic" },
            { key: "Mute", text: "Mute" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='articulation'
          label='Articulation'
          codeSystem="MSE-ARTICULATION"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Clear", text: "Clear" },
            { key: "Mumbled", text: "Mumbled" },
            { key: "Slurred", text: "Slurred" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='abilityToStop'
          label='Ability to stop when asked'
        />

</>)

const MseThought = () => (<>

        <SimpleCodeChecklist
          fieldId='delusions'
          label='Delusions'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-DELUSIONS"
          optionList={[
            { key: "None", text: "None" },
            { key: "Delusions of grandeur", text: "Delusions of grandeur" },
            { key: "Delusions of persecution", text: "Delusions of persecution" },
            { key: "Delusions of reference", text: "Delusions of reference" },
            { key: "Paranoia/suspiciousness", text: "Paranoia/suspiciousness" },
            { key: "Special abilities", text: "Special abilities" },
            { key: "Unusual thought content", text: "Unusual thought content" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='obsessions'
          label='Obsessions'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-OBSESSIONS"
          optionList={[
            { key: "None", text: "None" },
            { key: "Persistent", text: "Persistent" },
            { key: "Recurring thought", text: "Recurring thought" },
            { key: "Unwanted", text: "Unwanted" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='phobias'
          label='Phobias'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-PHOBIAS"
          optionList={[
            { key: "None", text: "None" },
            { key: "Fear of object/situation", text: "Fear of object/situation" },
            { key: "Persistent", text: "Persistent" },
            { key: "Strong", text: "Strong" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='logic'
          label='Logic'
          codeSystem="MSE-LOGIC"
          optionList={[
            { key: "Y", text: "Logical" },
            { key: "N", text: "Illogical" },
            { key: "U", text: "Unknown" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='coherence'
          label='Coherence'
          codeSystem="MSE-LOGIC"
          optionList={[
            { key: "Y", text: "Coherent" },
            { key: "N", text: "Incoherent" },
            { key: "U", text: "Unknown" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='thoughtStream'
          label='Stream'
          codeSystem="MSE-THOUGHTSTREAM"
          optionList={[
            { key: "Goal-directed", text: "Goal-directed" },
            { key: "Circumstantial", text: "Circumstantial" },
            { key: "Flight of ideas", text: "Flight of ideas" },
            { key: "Loose associations", text: "Loose associations" },
            { key: "Rambling", text: "Rambling" },
            { key: "Tangential", text: "Tangential" },
            { key: "World salad", text: "World salad" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='perseveration'
          label='Perseveration'
          codeSystem="MSE-PERSERVATION"
          optionList={[
            { key: "None observed", text: "None observed" },
            { key: "Pathological repetition of sentence", text: "Pathological repetition of sentence" },
            { key: "Pathological repetition of word", text: "Pathological repetition of word" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='depressiveCognition'
          label='Depressive cognition'
          size="large"
          selectionType="multiple"
          showOtherOption
          codeSystem="MSE-DEPRESSIVECOGNITION"
          optionList={[
            { key: "None", text: "None" },
            { key: "Guilt", text: "Guilt" },
            { key: "Hopelessness", text: "Hopelessness" },
            { key: "Worthlessness", text: "Worthlessness" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='magicalIdeation'
          label='Magical ideation'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='unwelcomeThoughts'
          label='Intrusive/Unwelcome Thoughts'
        />
       <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='overvaluedIdeas'
          label='Overvalued ideas'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='blocking'
          label='Blocking'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='neologism'
          label='Neologism'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='ruminations'
          label='Ruminations'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='fixation'
          label='Fixation'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='thoughtBroadcasting'
          label='Thought broadcasting'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='thoughtInsertion'
          label='Thought insertion'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='ideasOfReference'
          label='Ideas of reference'
        />
</>)

const MseAffect = () => (<>

        <SimpleCodeChecklist
          fieldId='affect'
          label='Affect'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-AFFECT"
          optionList={[
            { key: "Agitated", text: "Agitated" },
            { key: "Alert", text: "Alert" },
            { key: "Angry", text: "Angry" },
            { key: "Animated", text: "Animated" },
            { key: "Anxious/anxiety", text: "Anxious/anxiety" },
            { key: "Apathetic", text: "Apathetic" },
            { key: "Appears depressed", text: "Appears depressed" },
            { key: "Avoidant", text: "Avoidant" },
            { key: "Bored", text: "Bored" },
            { key: "Bright", text: "Bright" },
            { key: "Calm", text: "Calm" },
            { key: "Depressed", text: "Depressed" },
            { key: "Elated", text: "Elated" },
            { key: "Euphoric", text: "Euphoric" },
            { key: "Euthymic", text: "Euthymic" },
            { key: "Excitable", text: "Excitable" },
            { key: "Excited", text: "Excited" },
            { key: "Expresses loneliness", text: "Expresses loneliness" },
            { key: "Fearful", text: "Fearful" },
            { key: "Flat", text: "Flat" },
            { key: "Frightened", text: "Frightened" },
            { key: "Guilty", text: "Guilty" },
            { key: "Happy", text: "Happy" },
            { key: "Hostile", text: "Hostile" },
            { key: "Hyperactive", text: "Hyperactive" },
            { key: "Inappropriate", text: "Inappropriate" },
            { key: "Irritable", text: "Irritable" },
            { key: "Labile", text: "Labile" },
            { key: "Needy", text: "Needy" },
            { key: "Nervous", text: "Nervous" },
            { key: "Neutral", text: "Neutral" },
            { key: "Pleasant", text: "Pleasant" },
            { key: "Relaxed", text: "Relaxed" },
            { key: "Restless", text: "Restless" },
            { key: "Sad", text: "Sad" },
            { key: "Sad/unhappy", text: "Sad/unhappy" },
            { key: "Shallow", text: "Shallow" },
            { key: "Stressed", text: "Stressed" },
            { key: "Tense", text: "Tense" },
            { key: "Worrying", text: "Worrying" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='appropriateness'
          label='Appropriateness'
          codeSystem="MSE-APPROPRIATENESS"
          optionList={[
            {
              key: "Appropriate to situation and mood",
              text: "Appropriate to situation and mood",
            },
            {
              key: "Inappropriate to situation and mood",
              text: "Inappropriate to situation and mood",
            },
            {
              key: "Congruent with thought content",
              text: "Congruent with thought content",
            },
            {
              key: "Incongruent with thought content",
              text: "Incongruent with thought content",
            },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='affectRange'
          label='Range'
          codeSystem="MSE-AFFECTRANGE"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Full", text: "Full" },
            { key: "Restricted", text: "Restricted" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='affectStability'
          label='Stability'
          codeSystem="MSE-AFFECTSTABILITY"
          optionList={[
            { key: "Even", text: "Even" },
            { key: "Fixed", text: "Fixed" },
            { key: "Labile", text: "Labile" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='affectIntensity'
          label='Intensity'
          codeSystem="MSE-AFFECTINTENSITY"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Blunted", text: "Blunted" },
            { key: "Exaggerated", text: "Exaggerated" },
            { key: "Flat", text: "Flat" },
          ]}
        />
        <SubTitle text="Mood" />
        <SimpleCodeChecklist
          fieldId='mood'
          label='Mood'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-MOOD"
          optionList={[
            { key: "Appropriate", text: "Appropriate" },
            { key: "Lack of control over emotions and mood", text: "Lack of control over emotions and mood" },
            { key: "Matches non-verbal", text: "Matches non-verbal" },
            { key: "Depressed", text: "Depressed" },
            { key: "Anxious", text: "Anxious" },
            { key: "Irritable", text: "Irritable" },
            { key: "Angry", text: "Angry" },
            { key: "Elated", text: "Elated" },
          ]}
        />
        <SimpleCodeChecklist
          fieldId='moodRating'
          label='Mood rated'
          size="max"
          optionSize="min"
          codeSystem="MSE-MOODRATING"
          optionList={[
            { code: "1", display: "1", hotKey: "1", order: 1 },
            { code: "2", display: "2", hotKey: "2", order: 2 },
            { code: "3", display: "3", hotKey: "3", order: 3 },
            { code: "4", display: "4", hotKey: "4", order: 4 },
            { code: "5", display: "5", hotKey: "5", order: 5 },
            { code: "6", display: "6", hotKey: "6", order: 6 },
            { code: "7", display: "7", hotKey: "7", order: 7 },
            { code: "8", display: "8", hotKey: "8", order: 8 },
            { code: "9", display: "9", hotKey: "9", order: 9 },
            { code: "10", display: "10", hotKey: "0", order: 10 },
          ]}
        />
</>)

const MsePerception = () => (<>
        <SimpleCodeChecklist
          fieldId='hallucinations'
          label='Hallucinations'
          selectionType="multiple"
          showOtherOption
          size="large"
          codeSystem="MSE-HALLUCINATIONS"
          optionList={[
            { key: "None", text: "None" },
            { key: "Auditory", text: "Auditory" },
            { key: "Gustatory (taste)", text: "Gustatory (taste)" },
            { key: "Olfactory (smelling)", text: "Olfactory (smelling)" },
            { key: "Tactile", text: "Tactile" },
            { key: "Visual", text: "Visual" },
          ]}
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='illusions'
          label='Illusions'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='depersonalization'
          label='Depersonalization'
        />
        <SimpleCodeChecklist
          codeSystem="AIHS-YESNOUNKNOWN"
          autoHotKey
          optionSize="small"
          fieldId='dejavu'
          label='Dj vu/Jamais vu'
        />
</>)


const MseStamp = () => (<>

  <SubTitle text="Speech" />
  <MseSpeech />

  <SubTitle text="Thought Form, Content and Process" />
  <MseThought />

  <SubTitle text="Affect" />
  <MseAffect />

  <SubTitle text="Perception" />
  <MsePerception />

</>)

const MseStampSchema = {
  'speechRate':             { $ref: "#/definitions/codings" },
  'speechRhythm':           { $ref: "#/definitions/codings" },
  'speechVolume':           { $ref: "#/definitions/coding" },
  'speechSpontaneity':      { $ref: "#/definitions/ynu" },
  'speechAmount':           { $ref: "#/definitions/coding" },
  'articulation':           { $ref: "#/definitions/coding" },
  'abilityToStop':          { $ref: "#/definitions/ynu" },
  'delusions':              { $ref: "#/definitions/codings" },
  'obsessions':             { $ref: "#/definitions/codings" },
  'phobias':                { $ref: "#/definitions/codings" },
  'logic':                  { $ref: "#/definitions/coding" },
  'coherence':              { $ref: "#/definitions/coding" },
  'thoughtStream':          { $ref: "#/definitions/coding" },
  'perseveration':          { $ref: "#/definitions/coding" },
  'depressiveCognition':    { $ref: "#/definitions/codings" },
  'magicalIdeation':        { $ref: "#/definitions/ynu" },
  'unwelcomeThoughts':      { $ref: "#/definitions/ynu" },
  'overvaluedIdeas':        { $ref: "#/definitions/ynu" },
  'blocking':               { $ref: "#/definitions/ynu" },
  'neologism':              { $ref: "#/definitions/ynu" },
  'ruminations':            { $ref: "#/definitions/ynu" },
  'fixation':               { $ref: "#/definitions/ynu" },
  'thoughtBroadcasting':    { $ref: "#/definitions/ynu" },
  'thoughtInsertion':       { $ref: "#/definitions/ynu" },
  'ideasOfReference':       { $ref: "#/definitions/ynu" },
  'affect':                 { $ref: "#/definitions/codings" },
  'affectAppropriateness':  { $ref: "#/definitions/coding" },
  'affectRange':            { $ref: "#/definitions/coding" },
  'affectStability':        { $ref: "#/definitions/coding" },
  'affectIntensity':        { $ref: "#/definitions/coding" },
  'mood':                   { $ref: "#/definitions/codings" },
  'moodRated':              { $ref: "#/definitions/coding" },
  'hallucinations':         { $ref: "#/definitions/codings" },
  'illusions':              { $ref: "#/definitions/ynu" },
  'depersonalization':      { $ref: "#/definitions/ynu" },
  'dejavu':                 { $ref: "#/definitions/ynu" },
}

const mseStampSectionPrompts = {
  'Speech':                 "Speech",
  'Thought':                "Thought Form, Content and Process",
  'Affect':                 "Affect",
  'Mood':                   "Mood",
  'Perception':             "Perception",
}

const mseStampSpeechPrompts = {
  'speechRate':             "Rate",
  'speechRhythm':           "Rhythm",
  'speechVolume':           "Volume",
  'speechSpontaneity':      "Spontaneity",
  'speechAmount':           "Amount",
  'articulation':           "Articulation",
  'abilityToStop':          "Ability to stop",
}

const mseStampThoughtPrompts = {
  'delusions':              "Delusions",
  'obsessions':             "Obsessions",
  'phobias':                "Phobias",
  'logic':                  "Logic",
  'coherence':              "Coherence",
  'thoughtStream':          "Thought stream",
  'perseveration':          "Perseveration",
  'depressiveCognition':    "Depressive cognition",
  'magicalIdeation':        "Magical ideation",
  'unwelcomeThoughts':      "Unwelcome thoughts",
  'overvaluedIdeas':        "Overvalued ideas",
  'blocking':               "Blocking",
  'neologism':              "Neologism",
  'ruminations':            "Ruminations",
  'fixation':               "Fixation",
  'thoughtBroadcasting':    "Thought broadcasting",
  'thoughtInsertion':       "Thought insertion",
  'ideasOfReference':       "Ideas of reference",
}

const mseStampAffectPrompts = {
  'affect':                 "Affect",
  'affectAppropriateness':  "Appropriateness",
  'affectRange':            "Range",
  'affectStability':        "Stability",
  'affectIntensity':        "Intensity",
}

const mseStampMoodPrompts = {
  'mood':                   "Mood",
  'moodRated':              "Mood rated",
}

const mseStampPerceptionPrompts = {
  'hallucinations':         "Hallucinations",
  'illusions':              "Illusions",
  'depersonalization':      "Depersonalization",
  'dejavu':                 "Dj vu/Jamais vu",
}
`,
  './NewTextArea/index.jsx': `const NewTextArea = (props) => {

    const sourceData = useSourceData()
    const [fd,setFd] = useActiveData(useSection().activeSelector)

    const hideonprint = Fluent.mergeStyles({
        '@media print':{
            display:'none !important;'
        }
    })

    const showonprint = Fluent.mergeStyles({
        '@media print':{
            display:'block !important;'
        },
        display:'none'
    })

    return(
        <div>
            <div class={showonprint}>
                <div style={{display:"flex",flexDirection:\`\${props.labelPosition ==="top"?"column":"row"}\`, marginTop:"8px", marginBottom:"8px" }}>
                    {props.label?.length >0 ?
                        <Fluent.Label styles={{root:{flexGrow:"1", maxWidth:"240px",marginRight:"10px"}}}>{props.label}</Fluent.Label>
                    : null}
                    <div style={{padding:"6px 8px", border:"1px solid black", whiteSpace:"pre-wrap",flexGrow:"2",minHeight:\`\${props.multiline?"60px":null}\`}}>{fd[props.fieldId]}</div>
                </div>
            </div>

            <div class={hideonprint}>
                <TextArea
                    {...props}
                />
            </div>
        </div>
    )
}
`,
  './Occupations/index.jsx': `/**
 * Display a list of patient's employers and occupations. By default, it will
 * display all occupations in the patient chart and then allows selection of
 * which items to display.
 */
const Occupations = ({
  id = "occupations",
  label = "Employment History",
  selectText = "Select specific employment",
  selectionType = "none",
}) => {

  return (
    <ListSelection
      {...{id, label, selectText, selectionType, columns: occupationColumns}}
    />
  )
}

const occupationColumns: ColumnSelection = [
  {
    id: "occupationId",
    type: "key",
  },
  {
    title: "Start",
    id: "startDate",
    type: "date",
  },
  {
    title: "End",
    id: "endDate",
    type: "date",
  },
  {
    title: "Description",
    id: "classification",
    type: "code",
    size: "medium",
  },
  {
    title: "Employer",
    id: "employer",
    type: "string",
    size: "small",
  },
  {
    title: "Hours/week",
    id: "hoursPerWeek",
    type: "number",
    size: "tiny",
  },
]

const OccupationsFields = \`
occupationId 
startDate
endDate
employer
classification { code display system }
hoursPerWeek
\`
`,
  './PdfRegenerator/index.jsx': `/**
 * PdfRegenerator
 *
 * Runtime-only client-side button that regenerates an AcroForm PDF from
 * current form data. This component is self-contained JSX and does not rely
 * on host-side MOIS-native helper components.
 */

const { useMemo, useState, useCallback } = React
const { Stack, Text, DefaultButton } = Fluent

const PDF_LIB_URL = "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"
let _pdfLibPromise = null

const _isNonEmptyString = (value) => typeof value === "string" && value.trim().length > 0

const _decodePdfHex = (value) => {
  if (!_isNonEmptyString(value)) return ""
  const withoutSlash = value.startsWith("/") ? value.slice(1) : value
  return withoutSlash.replace(/#([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
}

const _normalizeToken = (value) => _decodePdfHex(String(value || "")).trim().toLowerCase()

const _resolveValueByPath = (root, path) => {
  if (!root || !_isNonEmptyString(path)) return undefined
  const segments = path.split(".").map((segment) => segment.trim()).filter(Boolean)
  let current = root
  for (const segment of segments) {
    if (!current || typeof current !== "object") return undefined
    current = current[segment]
  }
  return current
}

const _toText = (value) => {
  if (value === null || value === undefined) return null
  if (typeof value === "string") {
    const trimmed = value.trim()
    return trimmed ? trimmed : null
  }
  if (typeof value === "number" || typeof value === "boolean") return String(value)
  if (Array.isArray(value)) {
    const parts = value.map(_toText).filter(Boolean)
    return parts.length ? parts.join(", ") : null
  }
  if (typeof value === "object") {
    if (typeof value.dataUrl === "string") return null

    const maybeDate = _toText(value.date)
    const maybeTime = _toText(value.time)
    if (maybeDate || maybeTime) {
      return [maybeDate, maybeTime].filter(Boolean).join(" ")
    }

    const selectedCount = value.selectedCount
    if (typeof selectedCount === "number" && Number.isFinite(selectedCount)) {
      return String(selectedCount)
    }

    const candidateKeys = ["display", "text", "label", "value", "code", "key", "id", "name"]
    for (const key of candidateKeys) {
      const candidate = _toText(value[key])
      if (candidate) return candidate
    }
  }
  return null
}

const _toBooleanLike = (value) => {
  if (typeof value === "boolean") return value
  if (typeof value === "number" && Number.isFinite(value)) return value !== 0
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase()
    if (!normalized) return undefined
    if (["true", "t", "yes", "y", "on", "1", "checked"].includes(normalized)) return true
    if (["false", "f", "no", "n", "off", "0", "unchecked"].includes(normalized)) return false
    return undefined
  }
  if (Array.isArray(value)) return value.length > 0
  if (value && typeof value === "object") {
    if (typeof value.isEmpty === "boolean") return !value.isEmpty
    if (typeof value.checked === "boolean") return value.checked
    if (typeof value.selectedCount === "number" && Number.isFinite(value.selectedCount)) {
      return value.selectedCount > 0
    }
    return _toBooleanLike(value.value ?? value.code ?? value.key ?? value.text ?? value.display)
  }
  return undefined
}

const _collectCandidates = (value, out) => {
  const text = _toText(value)
  if (text) out.add(text)

  if (Array.isArray(value)) {
    value.forEach((item) => _collectCandidates(item, out))
    return
  }
  if (!value || typeof value !== "object") return

  const candidateKeys = ["code", "key", "value", "text", "display", "label", "id", "name"]
  candidateKeys.forEach((key) => {
    const maybe = _toText(value[key])
    if (maybe) out.add(maybe)
  })

  if (Array.isArray(value.selectedIds)) {
    value.selectedIds.forEach((item) => _collectCandidates(item, out))
  }
  if (Array.isArray(value.selectedLabels)) {
    value.selectedLabels.forEach((item) => _collectCandidates(item, out))
  }
}

const _toCandidateList = (value) => {
  const set = new Set()
  _collectCandidates(value, set)
  return Array.from(set)
}

const _matchSingleOption = (rawValue, options) => {
  if (!Array.isArray(options) || options.length === 0) return null

  const normalizedOptionMap = new Map()
  options.forEach((option) => {
    normalizedOptionMap.set(_normalizeToken(option), option)
  })

  const candidates = _toCandidateList(rawValue)

  for (const candidate of candidates) {
    const direct = normalizedOptionMap.get(_normalizeToken(candidate))
    if (direct) return direct
  }

  for (const candidate of candidates) {
    const normalizedCandidate = _normalizeToken(candidate)
    const fuzzy = options.find((option) => {
      const normalizedOption = _normalizeToken(option)
      return normalizedOption.includes(normalizedCandidate) || normalizedCandidate.includes(normalizedOption)
    })
    if (fuzzy) return fuzzy
  }

  return null
}

const _matchMultipleOptions = (rawValue, options) => {
  if (!Array.isArray(rawValue)) {
    const single = _matchSingleOption(rawValue, options)
    return single ? [single] : []
  }

  const selected = new Set()
  rawValue.forEach((item) => {
    const match = _matchSingleOption(item, options)
    if (match) selected.add(match)
  })
  return Array.from(selected)
}

const _normalizeFieldMap = (fieldMap, formData) => {
  const mapped = new Map()
  if (!fieldMap || typeof fieldMap !== "object") return mapped

  const formKeys = new Set(Object.keys(formData || {}))

  Object.entries(fieldMap).forEach(([leftRaw, rightRaw]) => {
    const left = String(leftRaw || "").trim()
    const right = String(rightRaw || "").trim()
    if (!left || !right) return

    const leftIsFormId = formKeys.has(left)
    const rightIsFormId = formKeys.has(right)

    if (leftIsFormId && !rightIsFormId) {
      mapped.set(right, left)
      return
    }
    if (rightIsFormId && !leftIsFormId) {
      mapped.set(left, right)
      return
    }

    // Default assumption for ambiguous mappings: formId -> pdfFieldName
    mapped.set(right, left)
  })

  return mapped
}

const _base64ToBytes = (value) => {
  const trimmed = String(value || "").trim()
  const payload = trimmed.includes("base64,") ? trimmed.slice(trimmed.indexOf("base64,") + 7) : trimmed
  const clean = payload.replace(/\\s+/g, "")
  if (!clean) {
    throw new Error("Source PDF payload is empty")
  }

  if (typeof atob === "function") {
    const binary = atob(clean)
    const bytes = new Uint8Array(binary.length)
    for (let i = 0; i < binary.length; i += 1) {
      bytes[i] = binary.charCodeAt(i)
    }
    return bytes
  }

  throw new Error("Base64 decode is unavailable in this runtime")
}

const _downloadBytes = (bytes, fileName) => {
  const blob = new Blob([bytes], { type: "application/pdf" })
  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.download = fileName
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  setTimeout(() => URL.revokeObjectURL(url), 1000)
}

const _loadPdfLib = () => {
  if (typeof window === "undefined" || typeof document === "undefined") {
    return Promise.reject(new Error("PDF regeneration is only available in browser runtime."))
  }

  if (window.PDFLib) {
    return Promise.resolve(window.PDFLib)
  }

  if (_pdfLibPromise) {
    return _pdfLibPromise
  }

  _pdfLibPromise = new Promise((resolve, reject) => {
    const existing = document.querySelector(\`script[data-pdf-lib=\\"\${PDF_LIB_URL}\\"]\`)
    if (existing) {
      existing.addEventListener("load", () => {
        if (window.PDFLib) resolve(window.PDFLib)
        else reject(new Error("pdf-lib script loaded but global object was not found."))
      })
      existing.addEventListener("error", () => reject(new Error("Failed to load pdf-lib script.")))
      return
    }

    const script = document.createElement("script")
    script.src = PDF_LIB_URL
    script.async = true
    script.dataset.pdfLib = PDF_LIB_URL
    script.onload = () => {
      if (window.PDFLib) resolve(window.PDFLib)
      else reject(new Error("pdf-lib script loaded but global object was not found."))
    }
    script.onerror = () => reject(new Error("Failed to load pdf-lib script."))
    document.head.appendChild(script)
  })

  return _pdfLibPromise
}

const _getCheckboxOnStates = (field) => {
  const states = new Set()
  const acro = field?.acroField
  const widgets = acro?.getWidgets?.() || []
  widgets.forEach((widget) => {
    const onValue = widget?.getOnValue?.()
    const state = onValue?.toString ? _decodePdfHex(onValue.toString()) : null
    if (!state || _normalizeToken(state) === "off") return
    states.add(state)
  })
  return Array.from(states)
}

const _setCheckboxByState = (field, requestedState, PDFLib) => {
  const acro = field?.acroField
  const widgets = acro?.getWidgets?.() || []
  if (!acro || widgets.length === 0) return false

  const normalizedRequested = _normalizeToken(requestedState)
  let targetStateName = null

  for (const widget of widgets) {
    const onValue = widget?.getOnValue?.()
    const onText = onValue?.toString ? _decodePdfHex(onValue.toString()) : null
    if (!onText) continue
    if (_normalizeToken(onText) !== normalizedRequested) continue
    targetStateName = onValue instanceof PDFLib.PDFName ? onValue : PDFLib.PDFName.of(onText)
    break
  }

  if (!targetStateName) {
    targetStateName = PDFLib.PDFName.of(requestedState)
  }

  try {
    acro.setValue?.(targetStateName)
  } catch (error) {
    return false
  }

  const offState = PDFLib.PDFName.of("Off")
  widgets.forEach((widget) => {
    if (!widget?.setAppearanceState) return
    const onValue = widget?.getOnValue?.()
    const onText = onValue?.toString ? _decodePdfHex(onValue.toString()) : null
    const isOn = onText && _normalizeToken(onText) === normalizedRequested
    widget.setAppearanceState(isOn && onValue ? onValue : offState)
  })

  return true
}

const _fillField = (field, rawValue, sourceFieldId, warnings, PDFLib) => {
  try {
    if (field instanceof PDFLib.PDFTextField) {
      const text = _toText(rawValue)
      if (!text) return false
      field.setText(text)
      return true
    }

    if (field instanceof PDFLib.PDFRadioGroup) {
      const options = field.getOptions() || []
      const match = _matchSingleOption(rawValue, options)
      if (!match) {
        warnings.push(\`Field \\"\${field.getName()}\\" (\${sourceFieldId}): no matching radio option.\`)
        return false
      }
      field.select(match)
      return true
    }

    if (field instanceof PDFLib.PDFDropdown) {
      const options = field.getOptions() || []
      const match = _matchSingleOption(rawValue, options)
      if (!match) {
        warnings.push(\`Field \\"\${field.getName()}\\" (\${sourceFieldId}): no matching dropdown option.\`)
        return false
      }
      field.select(match)
      return true
    }

    if (field instanceof PDFLib.PDFOptionList) {
      const options = field.getOptions() || []
      const matches = _matchMultipleOptions(rawValue, options)
      if (!matches.length) {
        warnings.push(\`Field \\"\${field.getName()}\\" (\${sourceFieldId}): no matching list option.\`)
        return false
      }
      field.select(matches)
      return true
    }

    if (field instanceof PDFLib.PDFCheckBox) {
      const states = _getCheckboxOnStates(field)
      if (states.length > 0) {
        const match = _matchSingleOption(rawValue, states)
        if (match && _setCheckboxByState(field, match, PDFLib)) {
          return true
        }
      }

      const boolValue = _toBooleanLike(rawValue)
      if (boolValue === undefined) {
        warnings.push(\`Field \\"\${field.getName()}\\" (\${sourceFieldId}): value is not boolean-like.\`)
        return false
      }
      if (boolValue) field.check()
      else field.uncheck()
      return true
    }

    return false
  } catch (error) {
    warnings.push(\`Field \\"\${field.getName()}\\" (\${sourceFieldId}): \${error?.message || "failed"}\`)
    return false
  }
}

const _statusColor = (kind) => {
  if (kind === "success") return "#107c10"
  if (kind === "error") return "#a4262c"
  return "#605e5c"
}

const PdfRegenerator = ({
  label,
  buttonText = "Download Filled PDF",
  fileName = "filled-form.pdf",
  iconName = "Print",
  sourcePdfBase64,
  sourcePdfPath = "sessionPdf.base64",
  sourcePdfFieldId,
  fieldMap,
  includeOnlyFieldIds,
  flatten = false,
  disabled = false,
  showStatus = false,
  showDiagnostics = false,
  onComplete,
}) => {
  const [fd] = useActiveData()
  const sd = useSourceData()
  const [isBusy, setIsBusy] = useState(false)
  const [status, setStatus] = useState(null)

  const resolvedPdfSource = useMemo(() => {
    if (_isNonEmptyString(sourcePdfBase64)) {
      return sourcePdfBase64.trim()
    }

    const sourceId = _isNonEmptyString(sourcePdfFieldId) ? sourcePdfFieldId.trim() : ""
    if (sourceId) {
      const fromData = fd?.field?.data?.[sourceId]
      if (_isNonEmptyString(fromData)) return fromData.trim()
    }

    const fromPath = _isNonEmptyString(sourcePdfPath)
      ? _resolveValueByPath(sd, sourcePdfPath.trim())
      : null
    if (_isNonEmptyString(fromPath)) {
      return fromPath.trim()
    }

    return null
  }, [sourcePdfBase64, sourcePdfFieldId, sourcePdfPath, fd, sd])

  const handleGeneratePdf = useCallback(async () => {
    if (!_isNonEmptyString(resolvedPdfSource)) {
      setStatus({ kind: "error", message: "No source PDF found." })
      return
    }

    setIsBusy(true)
    setStatus({ kind: "info", message: "Generating PDF..." })

    try {
      const PDFLib = await _loadPdfLib()
      const bytes = _base64ToBytes(resolvedPdfSource)
      const formData = fd?.field?.data || {}
      const map = _normalizeFieldMap(fieldMap, formData)
      const includeSet = Array.isArray(includeOnlyFieldIds)
        ? new Set(includeOnlyFieldIds.map((id) => String(id || "").trim()).filter(Boolean))
        : null

      const doc = await PDFLib.PDFDocument.load(bytes, {
        throwOnInvalidObject: false,
        ignoreEncryption: true,
      })

      const form = doc.getForm()
      const warnings = []
      let filledFieldCount = 0
      let skippedFieldCount = 0

      form.getFields().forEach((field) => {
        const pdfFieldName = field.getName()
        const sourceFieldId = map.get(pdfFieldName) || pdfFieldName

        if (includeSet && !includeSet.has(sourceFieldId) && !includeSet.has(pdfFieldName)) {
          skippedFieldCount += 1
          return
        }

        const rawValue = formData[sourceFieldId]
        if (rawValue === undefined || rawValue === null || rawValue === "") {
          skippedFieldCount += 1
          return
        }

        const didFill = _fillField(field, rawValue, sourceFieldId, warnings, PDFLib)
        if (didFill) filledFieldCount += 1
        else skippedFieldCount += 1
      })

      if (flatten) {
        form.flatten()
      }

      const outputBytes = await doc.save()
      const nextFileName = _isNonEmptyString(fileName) ? fileName.trim() : "filled-form.pdf"
      _downloadBytes(outputBytes, nextFileName)

      const warningCount = warnings.length
      setStatus({
        kind: "success",
        message: \`PDF generated. Filled \${filledFieldCount} field\${filledFieldCount === 1 ? "" : "s"}\${warningCount ? \` with \${warningCount} warning\${warningCount === 1 ? "" : "s"}\` : ""}.\`,
        warnings,
      })

      if (typeof onComplete === "function") {
        onComplete({
          pdfBytes: outputBytes,
          filledFieldCount,
          skippedFieldCount,
          warnings,
        })
      }
    } catch (error) {
      setStatus({
        kind: "error",
        message: \`Failed to generate PDF: \${error?.message || "unknown error"}\`,
      })
    } finally {
      setIsBusy(false)
    }
  }, [resolvedPdfSource, fd, fieldMap, includeOnlyFieldIds, flatten, fileName, onComplete])

  const diagnosticsText = useMemo(() => {
    if (!showDiagnostics) return null
    if (!_isNonEmptyString(resolvedPdfSource)) return "Waiting for source PDF data."
    return "Source PDF detected."
  }, [showDiagnostics, resolvedPdfSource])

  const renderButton = (
    <DefaultButton
      text={isBusy ? "Generating..." : buttonText}
      iconProps={iconName ? { iconName } : undefined}
      onClick={handleGeneratePdf}
      disabled={disabled || isBusy || !_isNonEmptyString(resolvedPdfSource)}
    />
  )

  if (!label && !showStatus && !showDiagnostics) {
    return renderButton
  }

  return (
    <Stack tokens={{ childrenGap: 6 }}>
      {label ? (
        <Text variant="smallPlus" styles={{ root: { fontWeight: 600 } }}>
          {label}
        </Text>
      ) : null}

      {renderButton}

      {diagnosticsText ? (
        <Text variant="small" styles={{ root: { color: "#605e5c" } }}>
          {diagnosticsText}
        </Text>
      ) : null}

      {showStatus && status ? (
        <Text variant="small" styles={{ root: { color: _statusColor(status.kind) } }}>
          {status.message}
        </Text>
      ) : null}

      {showStatus && Array.isArray(status?.warnings) && status.warnings.length > 0 ? (
        <Stack tokens={{ childrenGap: 2 }}>
          {status.warnings.slice(0, 3).map((warning, index) => (
            <Text key={\`\${index}-\${warning}\`} variant="small" styles={{ root: { color: "#8a8886" } }}>
              {warning}
            </Text>
          ))}
          {status.warnings.length > 3 ? (
            <Text variant="small" styles={{ root: { color: "#8a8886" } }}>
              +{status.warnings.length - 3} more warning{status.warnings.length - 3 === 1 ? "" : "s"}
            </Text>
          ) : null}
        </Stack>
      ) : null}
    </Stack>
  )
}
`,
  './PlannedActions/index.jsx': `
/**
 * Display a list of planned actions for the patient. By default, it will display
 * all planned actions in the chart. The user can then remove unwanted items.
 */
const PlannedActions = ({
  id = "actions",
  selectionType = "multiple",
  selectText = "Select actions",
  filterPred=plannedActionsActiveOnly,
  ...props
}: Props) => {

  return (
    <ListSelection
      {...{columns: plannedActionsColumns, id, selectionType, selectText, filterPred}}
      {...props}
    />
  )

}

const plannedActionsColumns: ColumnSelection = [
  {
    id: "plannedActionId",
    type: "key",
  },
  {
    title: "Start",
    id: "startDate",
    type: "date",
  },
  {
    title: "End",
    id: "endDate",
    type: "date",
  },
  {
    title: "Action",
    id: "action",
    type: "string",
  },
  {
    title: "Participant(s)",
    id: "responsibility",
    type: "string",
    size: "small",
  },
  {
    title: "Completed",
    id: "completedDate",
    type: "date",
  },
  {
    id: "isCompleted",
    type: "hidden",
  },
]

const plannedActionsActiveOnly = item => (item.isCompleted?.code!=="Y")

const PlannedActionsFields = \`plannedActionId startDate endDate action responsibility completedDate
 isCompleted { code display system }\`

`,
  './ReferralSource/index.jsx': `
const ReferralSource = props => {
  const codeSystem = "VALUESET:REFERRAL.SOURCE"
  const sd = useSourceData()
  const optionList = sd.optionLists[codeSystem] ?? referralValueSet
  return (
    <SimpleCodeSelect
      fieldId="referralSource"
      label="Referral Source/Requested By"
      {...{optionList,codeSystem}}
      {...props}
    />
  )
}

// This is a fallback value set if VALUESET:REFERRAL.SOURCE is not in the
// Database.
const referralValueSet = [
  { code: "ABORIGINAL COMMUNITY SERVICE", display: "Aboriginal Community Service (not HA service)" },
  { code: "ACUTE CARE", display: "Acute Care" },
  { code: "ADULT JUSTICE", display: "Adult Justice (Corrections, Probation and Police)" },
  { code: "YOUTH MENTAL HEALTH", display: "Child and Youth Mental Health" },
  { code: "CHILD PROTECTION", display: "Child Protection" },
  { code: "COMMUNITY AGENCY", display: "Community Agency" },
  { code: "CRISIS RESPONSE SERVICE", display: "Crisis Response Service (not HA service)" },
  { code: "EMERGENCY ROOM", display: "Emergency Room" },
  { code: "FAMILY RELATIVE FRIEND OR CAREGIVER", display: "Family, Relative, Friend or Caregiver" },
  { code: "HOME AND COMMUNITY CARE", display: "Home and Community Care" },
  { code: "HOSPITAL", display: "Hospital" },
  { code: "HOUSING SERVICE", display: "Housing Service" },
  { code: "INCOME ASSISTANCE", display: "Income Assistance" },
  { code: "OTHER", display: "Other" },
  { code: "OTHER COMMUNITY SERVICE", display: "Other Community Service (not MHSU, not HCC)" },
  { code: "OTHER HEALTH AUTHORITY", display: "Other Health Authority" },
  { code: "OTHER HEALTH PROFESSIONAL", display: "Other Health Professional" },
  { code: "OTHER MENTAL HEALTHSERVICE", display: "Other Mental Health Service (not HA service)" },
  { code: "OTHER MHSU SERVICE", display: "Other MHSU Service from within the same HA" },
  { code: "OTHER SUBSTANCE USE SERVICE", display: "Other Substance Use Service (not HA service)" },
  { code: "PHYSICIAN SPECIALIST", display: "Physician/GP, Specialist (include Psychiatrist)" },
  { code: "PUBLIC HEALTH SERVICE", display: "Public Health Service" },
  { code: "EDUCATIONAL INSTITUTION", display: "Schools and Educational Institutions" },
  { code: "SELF", display: "Self" },
  { code: "TERTIARY CARE", display: "Tertiary Care" },
  { code: "UNKNOWN", display: "Unknown/not asked" },
  { code: "YOUTH FORENSICS", display: "Youth Forensics" },
  { code: "YOUTH JUSTICE", display: "Youth Justice" },
]
`,
  './RelationshipStatus/index.jsx': `
/**
 * Display the relationship (marital) status demographic field of the patient as
 * a read only field.
 */
const RelationshipStatus = ({
  sourceId = "maritalStatus",
  fieldId = "relationshipStatus",
  label = "Relationship status",
  placeholder="Not recorded in chart",
  ...props
}) => {

  return (
    <SimpleCodeSelect
      {...{fieldId,sourceId,label,placeholder}}
      readOnly
      refresh
      {...props}
    />
  )
}
`,
  './SaveOnClose/index.jsx': `/**
 * SaveOnClose Component
 * Automatically saves form data as draft when the browser window/tab is closed.
 * Only saves if the form is still in draft state (not signed/submitted).
 */

const { useEffect } = React

/**
 * SaveOnClose - Renders nothing but sets up auto-save on window close
 *
 * @param {Object} props
 * @param {Function} props.getSaveData - Function that returns the save data object
 * @param {boolean} props.disabled - If true, disables the save on close behavior
 */
const SaveOnClose = ({ getSaveData, disabled = false }) => {
  const sd = useSourceData()
  const [fd] = useActiveData()

  useEffect(() => {
    if (disabled) return

    window.onbeforeunload = () => {
      // Only save if form is still a draft (not signed/submitted)
      const isDraft = sd?.webform?.isDraft
      if (isDraft === 'N') {
        // Form is already signed, don't auto-save
        return
      }

      // Get save data from prop function or use default
      const saveData = getSaveData
        ? getSaveData()
        : { formData: fd?.field?.data, webformUpdate: null }

      // Trigger draft save
      saveDraft(sd, fd, saveData)
    }

    return () => {
      window.onbeforeunload = null
    }
  }, [sd, fd, getSaveData, disabled])

  // This component renders nothing - it only sets up the side effect
  return null
}

/**
 * useSaveOnClose - Hook version for more control
 *
 * @param {Function} getSaveData - Function that returns the save data object
 * @param {boolean} disabled - If true, disables the save on close behavior
 */
const useSaveOnClose = (getSaveData, disabled = false) => {
  const sd = useSourceData()
  const [fd] = useActiveData()

  useEffect(() => {
    if (disabled) return

    window.onbeforeunload = () => {
      const isDraft = sd?.webform?.isDraft
      if (isDraft === 'N') return

      const saveData = getSaveData
        ? getSaveData()
        : { formData: fd?.field?.data, webformUpdate: null }

      saveDraft(sd, fd, saveData)
    }

    return () => {
      window.onbeforeunload = null
    }
  }, [sd, fd, getSaveData, disabled])
}

// Note: No export statements - nhforms loading extracts components by name
`,
  './ScaleField/index.jsx': `const { useEffect } = React
const {
  Stack,
  Label,
  Text,
  StackItem,
  TooltipHost,
  Separator,
} = Fluent

/**
 * ScaleField - A configurable scale input component for form builder
 *
 * This component bridges the form builder's scale field configuration
 * to a HoNOS-style scale UI with horizontal radio buttons and tooltips.
 *
 * Props:
 * - fieldId: string - The field identifier for data binding
 * - label: string - The field label/question text
 * - options: Array<{ value: number, label: string, description?: string }> - Scale options
 * - showLegend: boolean - Whether to show the legend row above
 * - showInlineLabels: boolean - Whether to show inline option labels beside radio controls
 * - required: boolean - Whether the field is required
 * - readOnly: boolean - Whether the field is read-only
 */

// Styles
const LABEL_STYLE = {
  root: {
    margin: "0px 0px 0px 0px",
    minWidth: 200,
    flexShrink: 0,
  },
}

const CHOICE_FIELD_STYLE = {
  root: {
    padding: "0px 10px 5px 15px",
    minWidth: 60,
    textAlign: "center",
  },
}

const choiceGroupStyles = {
  flexContainer: {
    display: "flex",
    justifyContent: "space-between",
    width: "100%",
  },
}

// Legend component for showing option labels above the scale
const ScaleFieldLegend = ({ options }) => {
  const legendRowStyle = {
    root: {
      justifyContent: "space-between",
      width: "100%",
    },
  }

  const legendStyle = {
    padding: "5px 10px 0px 10px",
    minWidth: 60,
    textAlign: "center",
    fontSize: "11px",
  }

  return (
    <Stack horizontal wrap style={{ margin: "0px 0px 8px 0px" }}>
      <StackItem disableShrink>
        <Label styles={LABEL_STYLE}>&nbsp;</Label>
      </StackItem>
      <StackItem grow>
        <Stack horizontal styles={legendRowStyle} tokens={{ padding: 5 }}>
          {options.map((opt, i) => (
            <Text key={i} style={legendStyle}>
              <b>{opt.label}</b>
            </Text>
          ))}
        </Stack>
      </StackItem>
    </Stack>
  )
}

// Tooltip content showing all option descriptions
const ScaleFieldTooltip = ({ options }) => {
  if (!options || options.length === 0) return null

  return (
    <div style={{ padding: "8px" }}>
      {options.map((opt, i) => (
        <Stack horizontal key={i} styles={{ root: { paddingBottom: 5 } }}>
          <StackItem styles={{ root: { minWidth: 30, fontWeight: 600 } }}>
            {opt.value}
          </StackItem>
          <StackItem>{opt.description || opt.label}</StackItem>
        </Stack>
      ))}
    </div>
  )
}

// Main ScaleField component
const ScaleField = ({
  fieldId,
  label,
  options,
  showLegend = false,
  showInlineLabels = true,
  required = false,
  readOnly = false,
}) => {
  const [fieldData, setFieldData] = useActiveData(fd => fd.field.data)
  const theme = useTheme()

  // Default options if none provided (0-5 scale)
  const scaleOptions = options && options.length > 0 ? options : [
    { value: 0, label: "0", description: "None" },
    { value: 1, label: "1", description: "Mild" },
    { value: 2, label: "2", description: "Moderate" },
    { value: 3, label: "3", description: "Moderately Severe" },
    { value: 4, label: "4", description: "Severe" },
  ]

  // Convert options to ChoiceGroup format
  const choiceOptions = scaleOptions.map(opt => ({
    key: String(opt.value),
    text: showInlineLabels ? String(opt.value) : "",
    styles: CHOICE_FIELD_STYLE,
  }))

  // Get current value from field data
  const currentData = fieldData?.[fieldId] || { selectedKey: null, value: null }

  // Initialize field data if needed
  useEffect(() => {
    if (!fieldData?.[fieldId]) {
      setFieldData({
        [fieldId]: {
          selectedKey: null,
          value: null,
          response: null,
        }
      })
    }
  }, [fieldId, fieldData, setFieldData])

  // Handle selection change
  const handleChange = (ev, option) => {
    if (readOnly) return

    const selectedOption = scaleOptions.find(o => String(o.value) === option.key)

    setFieldData({
      [fieldId]: {
        selectedKey: option.key,
        value: selectedOption?.value ?? parseInt(option.key, 10),
        response: selectedOption?.label || option.key,
        detailResponse: selectedOption?.description || selectedOption?.label || option.key,
      }
    })
  }

  // Styling based on selection state
  const containerStyle = {
    backgroundColor: currentData.selectedKey
      ? theme.semanticColors.bodyBackground
      : "#FBFBFB",
    padding: "8px 0px 8px 10px",
    marginBottom: "1px",
    borderRadius: "4px",
  }

  // Check if any option has a description for tooltip
  const hasDescriptions = scaleOptions.some(opt => opt.description)

  return (
    <div>
      {showLegend && <ScaleFieldLegend options={scaleOptions} />}

      <div style={containerStyle}>
        <TooltipHost
          id={\`tooltip_\${fieldId}\`}
          tooltipProps={
            hasDescriptions
              ? {
                  onRenderContent: () => <ScaleFieldTooltip options={scaleOptions} />,
                }
              : undefined
          }
        >
          <Stack horizontal wrap verticalAlign="center">
            <StackItem disableShrink>
              <Label
                styles={LABEL_STYLE}
                required={required}
              >
                {label}
              </Label>
            </StackItem>
            <StackItem grow>
              <OptionChoice
                inline
                displayStyle="radio"
                id={\`scale-\${fieldId}\`}
                options={choiceOptions}
                selectedKey={currentData.selectedKey}
                onChange={handleChange}
                disabled={readOnly}
                controlStyles={choiceGroupStyles}
              />
            </StackItem>
          </Stack>
        </TooltipHost>
      </div>
    </div>
  )
}

// Export for use in forms
ScaleField.Legend = ScaleFieldLegend
ScaleField.Tooltip = ScaleFieldTooltip
`,
  './ScoringModule/index.jsx': `/**
 * ScoringModule - A scoring questionnaire component with interpretation
 *
 * Features:
 * - Uses SimpleCodeChecklist for question/answer selection
 * - Configurable questions with scored answer options
 * - Automatic total calculation with weighted terms
 * - Interpretation ranges with labels (e.g., "Follow-up required")
 * - Dark mode support via theme
 */

const { useMemo, useEffect } = React
const {
  Stack,
  StackItem,
  Label,
  Text,
  Separator,
} = Fluent

// ================================================
// Type definitions (JSDoc for documentation)
// ================================================

/**
 * @typedef {Object} ScoringOptionConfig
 * @property {string} key - Option code/key
 * @property {string} text - Display text
 * @property {number} score - Score value when selected
 */

/**
 * @typedef {Object} ScoringQuestionConfig
 * @property {string} id - Unique question ID (also used as fieldId)
 * @property {string} label - Question text
 * @property {ScoringOptionConfig[]} options - Answer options with scores
 * @property {boolean} [multiline] - Use vertical layout for options
 * @property {string} [codeSystem] - Optional code system reference
 */

/**
 * @typedef {Object} ScoreTotalTerm
 * @property {string} questionId - Question ID to include in total
 * @property {number} [weight=1] - Weight multiplier for the question's score
 */

/**
 * @typedef {Object} ScoreTotalRange
 * @property {string} label - Interpretation label
 * @property {number} min - Minimum score for this range
 * @property {number|null} max - Maximum score (null for unbounded)
 * @property {boolean} [minInclusive=true] - Whether min is inclusive ( vs >)
 * @property {boolean} [maxInclusive=true] - Whether max is inclusive ( vs <)
 */

/**
 * @typedef {Object} ScoreTotalConfig
 * @property {string} id - Unique total ID
 * @property {string} label - Display label for the total
 * @property {ScoreTotalTerm[]} terms - Questions/weights that make up this total
 * @property {string} [targetFieldId] - Field ID to write result to
 * @property {ScoreTotalRange[]} ranges - Interpretation ranges
 */

/**
 * @typedef {Object} ScoringConfig
 * @property {ScoringQuestionConfig[]} questions - Question configurations
 * @property {ScoreTotalConfig[]} totals - Total/score configurations
 */

// ================================================
// Styles
// ================================================

const QUESTION_CONTAINER_STYLE = {
  padding: "12px 16px",
  marginBottom: "8px",
  borderRadius: "4px",
}

const TOTAL_CONTAINER_STYLE = {
  padding: "16px",
  marginTop: "16px",
  borderRadius: "8px",
}

const INTERPRETATION_BOX_STYLE = {
  padding: "8px 12px",
  borderRadius: "4px",
  display: "inline-block",
  marginTop: "8px",
}

// ================================================
// Helper Functions
// ================================================

/**
 * Build a score map from question options for quick lookup
 * @param {ScoringQuestionConfig[]} questions
 * @returns {Map<string, Map<string, number>>} Map of questionId -> (optionKey -> score)
 */
const buildScoreMap = (questions) => {
  const map = new Map()
  for (const question of questions || []) {
    const optionMap = new Map()
    for (const opt of question.options || []) {
      optionMap.set(opt.key, opt.score ?? 0)
    }
    map.set(question.id, optionMap)
  }
  return map
}

const normalizeScoreToken = (value) => String(value ?? "").trim().toLowerCase()

const collectScoreCandidates = (value, out = new Set(), depth = 0) => {
  if (depth > 4 || value === null || value === undefined) return out

  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    const token = String(value).trim()
    if (token) out.add(token)
    return out
  }

  if (Array.isArray(value)) {
    value.forEach((entry) => collectScoreCandidates(entry, out, depth + 1))
    return out
  }

  if (typeof value !== "object") return out

  const candidateKeys = [
    "code",
    "key",
    "value",
    "id",
    "text",
    "display",
    "label",
    "state",
    "fieldId",
  ]
  candidateKeys.forEach((key) => {
    collectScoreCandidates(value[key], out, depth + 1)
  })

  if (Array.isArray(value.selectedItems)) {
    value.selectedItems.forEach((entry) => collectScoreCandidates(entry, out, depth + 1))
  }
  collectScoreCandidates(value.selectedItem, out, depth + 1)
  if (Array.isArray(value.selectedIds)) {
    value.selectedIds.forEach((entry) => collectScoreCandidates(entry, out, depth + 1))
  }
  if (Array.isArray(value.selectedLabels)) {
    value.selectedLabels.forEach((entry) => collectScoreCandidates(entry, out, depth + 1))
  }

  return out
}

/**
 * Get score for a selected value
 * @param {Object} value - The Coding value from SimpleCodeChecklist
 * @param {Map<string, number>} optionScoreMap - Map of option key to score
 * @returns {number|null}
 */
const getScoreFromValue = (value, optionScoreMap) => {
  if (!optionScoreMap) return null

  const candidates = Array.from(collectScoreCandidates(value))
  if (candidates.length === 0) return null

  for (const candidate of candidates) {
    if (optionScoreMap.has(candidate)) {
      return optionScoreMap.get(candidate)
    }
  }

  const normalizedOptionMap = new Map()
  optionScoreMap.forEach((score, key) => {
    normalizedOptionMap.set(normalizeScoreToken(key), score)
  })

  for (const candidate of candidates) {
    const direct = normalizedOptionMap.get(normalizeScoreToken(candidate))
    if (direct !== undefined) return direct
  }

  return null
}

/**
 * Check if a score falls within a range
 */
const isInRange = (score, range) => {
  if (score === null || score === undefined) return false

  const min = range.min
  const max = range.max

  const meetsMin = range.minInclusive !== false ? score >= min : score > min
  const meetsMax = max === null ? true : (range.maxInclusive !== false ? score <= max : score < max)

  return meetsMin && meetsMax
}

/**
 * Get the interpretation for a score based on ranges
 */
const getInterpretation = (score, ranges) => {
  if (score === null || score === undefined || !ranges?.length) {
    return null
  }

  for (const range of ranges) {
    if (isInRange(score, range)) {
      return {
        label: range.label,
        range,
        bounds: formatBounds(range),
      }
    }
  }

  return null
}

/**
 * Format range bounds for display (e.g., "14" or "10-13")
 */
const formatBounds = (range) => {
  const minSymbol = range.minInclusive !== false ? "" : ">"
  const maxSymbol = range.maxInclusive !== false ? "" : "<"

  if (range.max === null) {
    return \`\${minSymbol}\${range.min}\`
  }

  if (range.min === range.max && range.minInclusive !== false && range.maxInclusive !== false) {
    return \`=\${range.min}\`
  }

  return \`\${range.min}-\${range.max}\`
}

// ================================================
// Sub-components
// ================================================

/**
 * Single question using SimpleCodeChecklist
 */
const ScoringQuestion = ({
  question,
  isDarkMode,
}) => {
  const containerStyle = {
    ...QUESTION_CONTAINER_STYLE,
    backgroundColor: isDarkMode ? "#2a2a2a" : "#f8f8f8",
    border: \`1px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
  }

  // Convert options to SimpleCodeChecklist format
  // Include score in the text for transparency
  const optionList = useMemo(() => {
    return (question.options || []).map(opt => ({
      key: opt.key,
      text: opt.text,
    }))
  }, [question.options])

  return (
    <div style={containerStyle}>
      <SimpleCodeChecklist
        fieldId={question.id}
        label={question.label}
        optionList={optionList}
        selectionType="single"
        multiline={question.multiline}
        codeSystem={question.codeSystem}
      />
    </div>
  )
}

/**
 * Total score display with interpretation
 */
const ScoringTotal = ({
  total,
  score,
  isComplete,
  isDarkMode,
}) => {
  const interpretation = useMemo(() => {
    return getInterpretation(score, total.ranges)
  }, [score, total.ranges])

  const containerStyle = {
    ...TOTAL_CONTAINER_STYLE,
    backgroundColor: isDarkMode ? "#1a3a5c" : "#e6f2ff",
    border: \`1px solid \${isDarkMode ? "#2a5a8c" : "#b8d4f0"}\`,
  }

  const errorContainerStyle = {
    ...TOTAL_CONTAINER_STYLE,
    backgroundColor: isDarkMode ? "#5c1a1a" : "#ffe6e6",
    border: \`1px solid \${isDarkMode ? "#8c2a2a" : "#f0b8b8"}\`,
  }

  const interpretationStyle = {
    ...INTERPRETATION_BOX_STYLE,
    backgroundColor: isDarkMode ? "#2a5a8c" : "#0078d4",
    color: "#ffffff",
  }

  if (!isComplete) {
    return (
      <div style={errorContainerStyle}>
        <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 12 }}>
          <Text variant="mediumPlus" styles={{ root: { fontWeight: 600 } }}>
            {total.label}:
          </Text>
          <Text styles={{ root: { color: isDarkMode ? "#ff8a8a" : "#d32f2f" } }}>
            Please answer all questions
          </Text>
        </Stack>
      </div>
    )
  }

  return (
    <div style={containerStyle}>
      <Stack tokens={{ childrenGap: 8 }}>
        <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 12 }}>
          <Text variant="mediumPlus" styles={{ root: { fontWeight: 600 } }}>
            {total.label}:
          </Text>
          <Text variant="xLarge" styles={{ root: { fontWeight: 700 } }}>
            {score}
          </Text>
        </Stack>

        {interpretation && (
          <Stack horizontal verticalAlign="center" tokens={{ childrenGap: 8 }}>
            <span style={interpretationStyle}>
              {interpretation.bounds}  {interpretation.label}
            </span>
          </Stack>
        )}
      </Stack>
    </div>
  )
}

// ================================================
// Main Component
// ================================================

/**
 * ScoringModule - Main scoring questionnaire component
 *
 * Uses SimpleCodeChecklist for each question and automatically
 * calculates totals based on configured score mappings.
 *
 * @param {Object} props
 * @param {string} props.id - Unique ID for this scoring module
 * @param {ScoringConfig} props.config - Scoring configuration
 * @param {string} [props.title] - Optional title for the module
 * @param {boolean} [props.showProgress] - Show completion progress
 */
const ScoringModule = ({
  id = "scoringModule",
  config = { questions: [], totals: [] },
  title,
  showProgress = true,
  ...props
}) => {
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  // Build score maps from config
  const scoreMap = useMemo(() => buildScoreMap(config.questions), [config.questions])

  // Get all answers from form data (each question stores its value at fd.field.data[questionId])
  const getAnswers = () => {
    const answers = {}
    for (const question of config.questions || []) {
      const value = fd?.field?.data?.[question.id]
      if (value) {
        answers[question.id] = value
      }
    }
    return answers
  }

  const answers = getAnswers()

  // Calculate totals
  const calculatedTotals = useMemo(() => {
    const results = {}

    for (const total of config.totals || []) {
      let score = 0
      let isComplete = true

      for (const term of total.terms || []) {
        const answer = answers[term.questionId]
        const optionScoreMap = scoreMap.get(term.questionId)
        const answerScore = getScoreFromValue(answer, optionScoreMap)

        if (answerScore !== null) {
          score += answerScore * (term.weight || 1)
        } else {
          isComplete = false
        }
      }

      results[total.id] = {
        score: isComplete ? score : null,
        isComplete,
      }
    }

    return results
  }, [answers, config.totals, scoreMap])

  // Calculate progress
  const progress = useMemo(() => {
    const questions = config.questions || []
    const total = questions.length
    const answered = questions.filter((question) => {
      const value = answers[question.id]
      const optionScoreMap = scoreMap.get(question.id)
      return getScoreFromValue(value, optionScoreMap) !== null
    }).length
    return { answered, total, percentage: total > 0 ? Math.round((answered / total) * 100) : 0 }
  }, [answers, config.questions, scoreMap])

  // Container styles
  const containerStyle = {
    padding: "16px",
    border: \`1px solid \${isDarkMode ? "#404040" : "#e0e0e0"}\`,
    borderRadius: "8px",
    backgroundColor: isDarkMode ? "#1f1f1f" : "#ffffff",
  }

  const headerStyle = {
    marginBottom: "16px",
  }

  const progressStyle = {
    fontSize: "14px",
    color: isDarkMode ? "#a0a0a0" : "#666666",
    marginTop: "4px",
  }

  return (
    <div style={containerStyle}>
      {(title || showProgress) && (
        <div style={headerStyle}>
          {title && (
            <Text variant="large" styles={{ root: { fontWeight: 600 } }}>
              {title}
            </Text>
          )}
          {showProgress && (
            <div style={progressStyle}>
              {progress.answered} of {progress.total} questions answered ({progress.percentage}%)
            </div>
          )}
          <Separator styles={{ root: { marginTop: "12px" } }} />
        </div>
      )}

      {/* Questions */}
      <Stack tokens={{ childrenGap: 8 }}>
        {(config.questions || []).map((question) => (
          <ScoringQuestion
            key={question.id}
            question={question}
            isDarkMode={isDarkMode}
          />
        ))}
      </Stack>

      {/* Totals */}
      {(config.totals || []).map((total) => (
        <ScoringTotal
          key={total.id}
          total={total}
          score={calculatedTotals[total.id]?.score}
          isComplete={calculatedTotals[total.id]?.isComplete}
          isDarkMode={isDarkMode}
        />
      ))}
    </div>
  )
}

/**
 * Schema definition for ScoringModule data
 * Each question stores its value as a Coding object
 */
const ScoringModuleSchema = {
  type: "object",
  additionalProperties: {
    $ref: "#/definitions/coding",
  },
}

/**
 * Helper to create question configurations with scored options
 * @param {Object} def - Question definition
 * @returns {ScoringQuestionConfig}
 *
 * @example
 * createScoringQuestion({
 *   id: "anxiety",
 *   label: "How often do you feel anxious?",
 *   options: [
 *     { key: "0", text: "Never", score: 0 },
 *     { key: "1", text: "Sometimes", score: 1 },
 *     { key: "2", text: "Often", score: 2 },
 *     { key: "3", text: "Always", score: 3 },
 *   ]
 * })
 */
const createScoringQuestion = (def) => ({
  id: def.id,
  label: def.label,
  multiline: def.multiline ?? false,
  codeSystem: def.codeSystem,
  options: (def.options || []).map((opt, idx) => ({
    key: opt.key || \`\${idx}\`,
    text: opt.text || opt.label || \`Option \${idx + 1}\`,
    score: opt.score ?? idx,
  })),
})

/**
 * Helper to create total configurations
 * @param {Object} def - Total definition
 * @returns {ScoreTotalConfig}
 *
 * @example
 * createScoringTotal({
 *   id: "total",
 *   label: "Total Score",
 *   questionIds: ["q1", "q2", "q3"],  // shorthand for equal-weighted terms
 *   ranges: [
 *     { label: "Low", min: 0, max: 5 },
 *     { label: "High", min: 6, max: null },
 *   ]
 * })
 */
const createScoringTotal = (def) => ({
  id: def.id,
  label: def.label,
  targetFieldId: def.targetFieldId,
  terms: (def.terms || def.questionIds || []).map(t =>
    typeof t === "string" ? { questionId: t, weight: 1 } : t
  ),
  ranges: (def.ranges || []).map(r => ({
    label: r.label,
    min: r.min ?? 0,
    max: r.max ?? null,
    minInclusive: r.minInclusive !== false,
    maxInclusive: r.maxInclusive !== false,
  })),
})

/**
 * Helper to create a full scoring config
 * @param {Object} def - Config definition
 * @returns {ScoringConfig}
 *
 * @example
 * createScoringConfig({
 *   questions: [
 *     { id: "q1", label: "Question 1", options: [...] },
 *     { id: "q2", label: "Question 2", options: [...] },
 *   ],
 *   totals: [
 *     { id: "total", label: "Score", questionIds: ["q1", "q2"], ranges: [...] }
 *   ]
 * })
 */
const createScoringConfig = (def) => ({
  questions: (def.questions || []).map(createScoringQuestion),
  totals: (def.totals || []).map(createScoringTotal),
})

/**
 * Pre-built option sets for common scoring scales
 */
const ScoringScales = {
  /**
   * HoNOS Scale5 - Health of the Nation Outcome Scales
   * Standard 0-4 severity rating with 9 for unknown
   * Used in mental health assessments
   */
  honos: [
    { key: "0", text: "0 - No problem", score: 0 },
    { key: "1", text: "1 - Minor problem not requiring action", score: 1 },
    { key: "2", text: "2 - Mild problem but definitely present", score: 2 },
    { key: "3", text: "3 - Moderate problem", score: 3 },
    { key: "4", text: "4 - Severe to very severe problem", score: 4 },
    { key: "9", text: "9 - Unknown or not asked", score: 0 },
  ],
  /**
   * HoNOS Scale5 compact - Shows only numbers (like original HonosQuestion)
   * Useful when question labels already explain the scale
   */
  honosCompact: [
    { key: "0", text: "0", score: 0 },
    { key: "1", text: "1", score: 1 },
    { key: "2", text: "2", score: 2 },
    { key: "3", text: "3", score: 3 },
    { key: "4", text: "4", score: 4 },
    { key: "9", text: "9", score: 0 },
  ],
  /** Standard 0-4 frequency scale */
  frequency5: [
    { key: "0", text: "Never (0)", score: 0 },
    { key: "1", text: "Rarely (1)", score: 1 },
    { key: "2", text: "Sometimes (2)", score: 2 },
    { key: "3", text: "Often (3)", score: 3 },
    { key: "4", text: "Always (4)", score: 4 },
  ],
  /** Standard 0-3 severity scale */
  severity4: [
    { key: "0", text: "None (0)", score: 0 },
    { key: "1", text: "Mild (1)", score: 1 },
    { key: "2", text: "Moderate (2)", score: 2 },
    { key: "3", text: "Severe (3)", score: 3 },
  ],
  /** Standard 0-4 agreement scale */
  agreement5: [
    { key: "0", text: "Strongly Disagree (0)", score: 0 },
    { key: "1", text: "Disagree (1)", score: 1 },
    { key: "2", text: "Neutral (2)", score: 2 },
    { key: "3", text: "Agree (3)", score: 3 },
    { key: "4", text: "Strongly Agree (4)", score: 4 },
  ],
  /** Yes/No scale */
  yesNo: [
    { key: "Y", text: "Yes", score: 1 },
    { key: "N", text: "No", score: 0 },
  ],
  /** Yes/No/Unknown scale */
  yesNoUnknown: [
    { key: "Y", text: "Yes", score: 1 },
    { key: "N", text: "No", score: 0 },
    { key: "U", text: "Unknown", score: 0 },
  ],
}
`,
  './ServiceEpisodes/index.jsx': `/**
 * Provide dropdown selection of a single service episode. The initial data is
 * obtained from the patient object.
 */
const ServiceEpisodes = ({
  id = "serviceEpisodes",
  readOnly = false,
  selectText = "Select service episodes",
  selectionType = "single",
  listCompare = startDateDesc,
  ...props
}:Props) => {

  return (
    <ListSelection
      {...{id, selectionType, columns: serviceEpisodeColumns, selectText, readOnly, listCompare}}
      {...props}
    />
  )
}

const activeServiceEpisodes = se => (!se.endDate)

const serviceEpisodeColumns: ColumnSelection = [
  {
    id: "serviceEpisodeId",
    type: "key",
  },
  {
    title: "Start",
    id: "startDate",
    type: "date",
  },
  {
    title: "End",
    id: "endDate",
    type: "date",
  },
  {
    title: "Service Episode",
    id: "service",
    type: "code",
    size: "large",
  },
  {
    title: "Service MRP",
    id: "serviceMrp",
    type: "code",
    size: "small",
  }
]

const ServiceEpisodesFields = "serviceEpisodeId startDate endDate service {code display system} serviceMrp {code display system}"
`,
  './ServiceRequests/index.jsx': `/**
 * Shows and allows selection of service requests
 */
const ServiceRequests = ({
  id = "serviceRequests",
  label = "Service Requests",
  moisModule = "ORDERS",
  selectText = "Select service request",
  selectionType = "single",
  listCompare = orderDateDesc,
  ...props
}:Props) => {


  return (
    <ListSelection
      {...{id, label, moisModule, selectText, selectionType, listCompare, columns: serviceRequestColumns}}
      {...props}
    />
  )
}

const serviceRequestColumns: ColumnSelection = [
  {
    id: "serviceRequestId",
    type: "key",
  },
  {
    title: "Date",
    id: "orderDate",
    type: "date",
  },
  {
    title: "Type",
    id: "serviceRequestType",
    type: "code",
  },
  {
    title: "Ordered by",
    id: "orderedBy",
    type: "string",
    size: "small",
  },
  {
    title: "Order",
    id: "order",
    type: "code",
    size: "large",
  },
  {
    title: "Status",
    id: "status",
    type: "rawcode",
  },
]

const orderDateDesc = (a,b) => -(a.orderDate?.localeCompare(b.orderDate) ?? 0)
const activeServiceRequests = (sr) => {
  return ["IP","SC","A","HD",].includes(sr.status.code)
}

const ServiceRequestsFields = \`
serviceRequestId
orderDate
serviceRequestType { code display system }
orderedBy
order { code display system }
status { code display system }
\``,
  './SignaturePad/index.jsx': `/**
 * SignaturePad NHForms Component
 *
 * Generated from: signature_pad v5.1.3 (https://github.com/szimek/signature_pad)
 * Strategy: Inline (self-contained generated JSX)
 *
 * DO NOT HAND-EDIT the embedded library section below.
 * To update, re-bundle from the signature_pad source.
 */

//  Embedded signature_pad v5.1.3 UMD (MIT License) 
const SignaturePadLib = (function() {
  var exports = {};
  var module = { exports: {} };
  var define = undefined;

  /*!
   * Signature Pad v5.1.3 | https://github.com/szimek/signature_pad
   * (c) 2025 Szymon Nowak | Released under the MIT license
   */
  (function(g,f){if(typeof exports=="object"&&typeof module<"u"){module.exports=f()}else if("function"==typeof define && define.amd){define("SignaturePad",f)}else {g["SignaturePad"]=f()}}(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this,function(){var exports={};var __exports=exports;var module={exports};
  var y=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var f=(d,n)=>()=>(d&&(n=d(d=0)),n);var L=(d,n)=>{for(var t in n)y(d,t,{get:n[t],enumerable:!0})},G=(d,n,t,e)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of U(n))!W.call(d,i)&&i!==t&&y(d,i,{get:()=>n[i],enumerable:!(e=D(n,i))||e.enumerable});return d};var B=d=>G(y({},"__esModule",{value:!0}),d);var b,P=f(()=>{"use strict";b=class{x;y;pressure;time;constructor(n,t,e,i){if(isNaN(n)||isNaN(t))throw new Error(\`Point is invalid: (\${n}, \${t})\`);this.x=+n,this.y=+t,this.pressure=e||0,this.time=i||Date.now()}distanceTo(n){return Math.sqrt(Math.pow(this.x-n.x,2)+Math.pow(this.y-n.y,2))}equals(n){return this.x===n.x&&this.y===n.y&&this.pressure===n.pressure&&this.time===n.time}velocityFrom(n){return this.time!==n.time?this.distanceTo(n)/(this.time-n.time):0}}});var x,S=f(()=>{"use strict";P();x=class d{constructor(n,t,e,i,o,r){this.startPoint=n;this.control2=t;this.control1=e;this.endPoint=i;this.startWidth=o;this.endWidth=r}static fromPoints(n,t){let e=this.calculateControlPoints(n[0],n[1],n[2]).c2,i=this.calculateControlPoints(n[1],n[2],n[3]).c1;return new d(n[1],e,i,n[2],t.start,t.end)}static calculateControlPoints(n,t,e){let i=n.x-t.x,o=n.y-t.y,r=t.x-e.x,c=t.y-e.y,a={x:(n.x+t.x)/2,y:(n.y+t.y)/2},h={x:(t.x+e.x)/2,y:(t.y+e.y)/2},l=Math.sqrt(i*i+o*o),s=Math.sqrt(r*r+c*c),v=a.x-h.x,p=a.y-h.y,m=l+s==0?0:s/(l+s),_={x:h.x+v*m,y:h.y+p*m},u=t.x-_.x,g=t.y-_.y;return{c1:new b(a.x+u,a.y+g),c2:new b(h.x+u,h.y+g)}}length(){let t=0,e,i;for(let o=0;o<=10;o+=1){let r=o/10,c=this.point(r,this.startPoint.x,this.control1.x,this.control2.x,this.endPoint.x),a=this.point(r,this.startPoint.y,this.control1.y,this.control2.y,this.endPoint.y);if(o>0){let h=c-e,l=a-i;t+=Math.sqrt(h*h+l*l)}e=c,i=a}return t}point(n,t,e,i,o){return t*(1-n)*(1-n)*(1-n)+3*e*(1-n)*(1-n)*n+3*i*(1-n)*n*n+o*n*n*n}}});var E,C=f(()=>{"use strict";E=class{_et;constructor(){try{this._et=new EventTarget}catch{this._et=document}}addEventListener(n,t,e){this._et.addEventListener(n,t,e)}dispatchEvent(n){return this._et.dispatchEvent(n)}removeEventListener(n,t,e){this._et.removeEventListener(n,t,e)}}});function O(d,n=250){let t=0,e=null,i,o,r,c=()=>{t=Date.now(),e=null,i=d.apply(o,r),e||(o=null,r=[])};return function(...h){let l=Date.now(),s=n-(l-t);return o=this,r=h,s<=0||s>n?(e&&(clearTimeout(e),e=null),t=l,i=d.apply(o,r),e||(o=null,r=[])):e||(e=window.setTimeout(c,s)),i}}var k=f(()=>{"use strict"});var T={};L(T,{default:()=>w});var w,M=f(()=>{"use strict";S();P();C();k();P();w=class d extends E{constructor(t,e={}){super();this.canvas=t;this.velocityFilterWeight=e.velocityFilterWeight||.7,this.minWidth=e.minWidth||.5,this.maxWidth=e.maxWidth||2.5,this.throttle=e.throttle??16,this.minDistance=e.minDistance??5,this.dotSize=e.dotSize||0,this.penColor=e.penColor||"black",this.backgroundColor=e.backgroundColor||"rgba(0,0,0,0)",this.compositeOperation=e.compositeOperation||"source-over",this.canvasContextOptions=e.canvasContextOptions??{},this._strokeMoveUpdate=this.throttle?O(d.prototype._strokeUpdate,this.throttle):d.prototype._strokeUpdate,this._handleMouseDown=this._handleMouseDown.bind(this),this._handleMouseMove=this._handleMouseMove.bind(this),this._handleMouseUp=this._handleMouseUp.bind(this),this._handleTouchStart=this._handleTouchStart.bind(this),this._handleTouchMove=this._handleTouchMove.bind(this),this._handleTouchEnd=this._handleTouchEnd.bind(this),this._handlePointerDown=this._handlePointerDown.bind(this),this._handlePointerMove=this._handlePointerMove.bind(this),this._handlePointerUp=this._handlePointerUp.bind(this),this._handlePointerCancel=this._handlePointerCancel.bind(this),this._handleTouchCancel=this._handleTouchCancel.bind(this),this._ctx=t.getContext("2d",this.canvasContextOptions),this.clear(),this.on()}dotSize;minWidth;maxWidth;penColor;minDistance;velocityFilterWeight;compositeOperation;backgroundColor;throttle;canvasContextOptions;_ctx;_drawingStroke=!1;_isEmpty=!0;_dataUrl;_dataUrlOptions;_lastPoints=[];_data=[];_lastVelocity=0;_lastWidth=0;_strokeMoveUpdate;_strokePointerId;clear(){let{_ctx:t,canvas:e}=this;t.fillStyle=this.backgroundColor,t.clearRect(0,0,e.width,e.height),t.fillRect(0,0,e.width,e.height),this._data=[],this._reset(this._getPointGroupOptions()),this._isEmpty=!0,this._dataUrl=void 0,this._dataUrlOptions=void 0,this._strokePointerId=void 0}redraw(){let t=this._data,e=this._dataUrl,i=this._dataUrlOptions;this.clear(),e&&this.fromDataURL(e,i),this.fromData(t,{clear:!1})}fromDataURL(t,e={}){return new Promise((i,o)=>{let r=new Image,c=e.ratio||window.devicePixelRatio||1,a=e.width||this.canvas.width/c,h=e.height||this.canvas.height/c,l=e.xOffset||0,s=e.yOffset||0;this._reset(this._getPointGroupOptions()),r.onload=()=>{this._ctx.drawImage(r,l,s,a,h),i()},r.onerror=v=>{o(v)},r.crossOrigin="anonymous",r.src=t,this._isEmpty=!1,this._dataUrl=t,this._dataUrlOptions={...e}})}toDataURL(t="image/png",e){switch(t){case"image/svg+xml":return typeof e!="object"&&(e=void 0),\`data:image/svg+xml;base64,\${btoa(this.toSVG(e))}\`;default:return typeof e!="number"&&(e=void 0),this.canvas.toDataURL(t,e)}}on(){this.canvas.style.touchAction="none",this.canvas.style.msTouchAction="none",this.canvas.style.userSelect="none",this.canvas.style.webkitUserSelect="none";let t=/Macintosh/.test(navigator.userAgent)&&"ontouchstart"in document;window.PointerEvent&&!t?this._handlePointerEvents():(this._handleMouseEvents(),"ontouchstart"in window&&this._handleTouchEvents())}off(){this.canvas.style.touchAction="auto",this.canvas.style.msTouchAction="auto",this.canvas.style.userSelect="auto",this.canvas.style.webkitUserSelect="auto",this.canvas.removeEventListener("pointerdown",this._handlePointerDown),this.canvas.removeEventListener("mousedown",this._handleMouseDown),this.canvas.removeEventListener("touchstart",this._handleTouchStart),this._removeMoveUpEventListeners()}_getListenerFunctions(){let t=window.document===this.canvas.ownerDocument?window:this.canvas.ownerDocument.defaultView??this.canvas.ownerDocument;return{addEventListener:t.addEventListener.bind(t),removeEventListener:t.removeEventListener.bind(t)}}_removeMoveUpEventListeners(){let{removeEventListener:t}=this._getListenerFunctions();t("pointermove",this._handlePointerMove),t("pointerup",this._handlePointerUp),t("pointercancel",this._handlePointerCancel),t("mousemove",this._handleMouseMove),t("mouseup",this._handleMouseUp),t("touchmove",this._handleTouchMove),t("touchend",this._handleTouchEnd),t("touchcancel",this._handleTouchCancel)}isEmpty(){return this._isEmpty}fromData(t,{clear:e=!0}={}){e&&this.clear(),this._fromData(t,this._drawCurve.bind(this),this._drawDot.bind(this)),this._data=this._data.concat(t)}toData(){return this._data}_isLeftButtonPressed(t,e){return e?t.buttons===1:(t.buttons&1)===1}_pointerEventToSignatureEvent(t){return{event:t,type:t.type,x:t.clientX,y:t.clientY,pressure:"pressure"in t?t.pressure:0}}_touchEventToSignatureEvent(t){let e=t.changedTouches[0];return{event:t,type:t.type,x:e.clientX,y:e.clientY,pressure:e.force}}_handleMouseDown(t){!this._isLeftButtonPressed(t,!0)||this._drawingStroke||this._strokeBegin(this._pointerEventToSignatureEvent(t))}_handleMouseMove(t){if(!this._isLeftButtonPressed(t,!0)||!this._drawingStroke){this._strokeEnd(this._pointerEventToSignatureEvent(t),!1);return}this._strokeMoveUpdate(this._pointerEventToSignatureEvent(t))}_handleMouseUp(t){this._isLeftButtonPressed(t)||this._strokeEnd(this._pointerEventToSignatureEvent(t))}_handleTouchStart(t){t.targetTouches.length!==1||this._drawingStroke||(t.cancelable&&t.preventDefault(),this._strokeBegin(this._touchEventToSignatureEvent(t)))}_handleTouchMove(t){if(t.targetTouches.length===1){if(t.cancelable&&t.preventDefault(),!this._drawingStroke){this._strokeEnd(this._touchEventToSignatureEvent(t),!1);return}this._strokeMoveUpdate(this._touchEventToSignatureEvent(t))}}_handleTouchEnd(t){t.targetTouches.length===0&&(t.cancelable&&t.preventDefault(),this._strokeEnd(this._touchEventToSignatureEvent(t)))}_handlePointerCancel(t){this._allowPointerId(t)&&(t.preventDefault(),this._strokeEnd(this._pointerEventToSignatureEvent(t),!1))}_handleTouchCancel(t){t.cancelable&&t.preventDefault(),this._strokeEnd(this._touchEventToSignatureEvent(t),!1)}_getPointerId(t){return t.persistentDeviceId||t.pointerId}_allowPointerId(t,e=!1){return typeof this._strokePointerId>"u"?e:this._getPointerId(t)===this._strokePointerId}_handlePointerDown(t){this._drawingStroke||!this._isLeftButtonPressed(t)||!this._allowPointerId(t,!0)||(this._strokePointerId=this._getPointerId(t),t.preventDefault(),this._strokeBegin(this._pointerEventToSignatureEvent(t)))}_handlePointerMove(t){if(this._allowPointerId(t)){if(!this._isLeftButtonPressed(t,!0)||!this._drawingStroke){this._strokeEnd(this._pointerEventToSignatureEvent(t),!1);return}t.preventDefault(),this._strokeMoveUpdate(this._pointerEventToSignatureEvent(t))}}_handlePointerUp(t){this._isLeftButtonPressed(t)||!this._allowPointerId(t)||(t.preventDefault(),this._strokeEnd(this._pointerEventToSignatureEvent(t)))}_getPointGroupOptions(t){return{penColor:t&&"penColor"in t?t.penColor:this.penColor,dotSize:t&&"dotSize"in t?t.dotSize:this.dotSize,minWidth:t&&"minWidth"in t?t.minWidth:this.minWidth,maxWidth:t&&"maxWidth"in t?t.maxWidth:this.maxWidth,velocityFilterWeight:t&&"velocityFilterWeight"in t?t.velocityFilterWeight:this.velocityFilterWeight,compositeOperation:t&&"compositeOperation"in t?t.compositeOperation:this.compositeOperation}}_strokeBegin(t){if(!this.dispatchEvent(new CustomEvent("beginStroke",{detail:t,cancelable:!0})))return;let{addEventListener:i}=this._getListenerFunctions();switch(t.event.type){case"mousedown":i("mousemove",this._handleMouseMove,{passive:!1}),i("mouseup",this._handleMouseUp,{passive:!1});break;case"touchstart":i("touchmove",this._handleTouchMove,{passive:!1}),i("touchend",this._handleTouchEnd,{passive:!1}),i("touchcancel",this._handleTouchCancel,{passive:!1});break;case"pointerdown":i("pointermove",this._handlePointerMove,{passive:!1}),i("pointerup",this._handlePointerUp,{passive:!1}),i("pointercancel",this._handlePointerCancel,{passive:!1});break;default:}this._drawingStroke=!0;let o=this._getPointGroupOptions(),r={...o,points:[]};this._data.push(r),this._reset(o),this._strokeUpdate(t)}_strokeUpdate(t){if(!this._drawingStroke)return;if(this._data.length===0){this._strokeBegin(t);return}this.dispatchEvent(new CustomEvent("beforeUpdateStroke",{detail:t}));let e=this._createPoint(t.x,t.y,t.pressure),i=this._data[this._data.length-1],o=i.points,r=o.length>0&&o[o.length-1],c=r?e.distanceTo(r)<=this.minDistance:!1,a=this._getPointGroupOptions(i);if(!r||!(r&&c)){let h=this._addPoint(e,a);r?h&&this._drawCurve(h,a):this._drawDot(e,a),o.push({time:e.time,x:e.x,y:e.y,pressure:e.pressure})}this.dispatchEvent(new CustomEvent("afterUpdateStroke",{detail:t}))}_strokeEnd(t,e=!0){this._removeMoveUpEventListeners(),this._drawingStroke&&(e&&this._strokeUpdate(t),this._drawingStroke=!1,this._strokePointerId=void 0,this.dispatchEvent(new CustomEvent("endStroke",{detail:t})))}_handlePointerEvents(){this._drawingStroke=!1,this.canvas.addEventListener("pointerdown",this._handlePointerDown,{passive:!1})}_handleMouseEvents(){this._drawingStroke=!1,this.canvas.addEventListener("mousedown",this._handleMouseDown,{passive:!1})}_handleTouchEvents(){this.canvas.addEventListener("touchstart",this._handleTouchStart,{passive:!1})}_reset(t){this._lastPoints=[],this._lastVelocity=0,this._lastWidth=(t.minWidth+t.maxWidth)/2,this._ctx.fillStyle=t.penColor,this._ctx.globalCompositeOperation=t.compositeOperation}_createPoint(t,e,i){let o=this.canvas.getBoundingClientRect();return new b(t-o.left,e-o.top,i,new Date().getTime())}_addPoint(t,e){let{_lastPoints:i}=this;if(i.push(t),i.length>2){i.length===3&&i.unshift(i[0]);let o=this._calculateCurveWidths(i[1],i[2],e),r=x.fromPoints(i,o);return i.shift(),r}return null}_calculateCurveWidths(t,e,i){let o=i.velocityFilterWeight*e.velocityFrom(t)+(1-i.velocityFilterWeight)*this._lastVelocity,r=this._strokeWidth(o,i),c={end:r,start:this._lastWidth};return this._lastVelocity=o,this._lastWidth=r,c}_strokeWidth(t,e){return Math.max(e.maxWidth/(t+1),e.minWidth)}_drawCurveSegment(t,e,i){let o=this._ctx;o.moveTo(t,e),o.arc(t,e,i,0,2*Math.PI,!1),this._isEmpty=!1}_drawCurve(t,e){let i=this._ctx,o=t.endWidth-t.startWidth,r=Math.ceil(t.length())*2;i.beginPath(),i.fillStyle=e.penColor;for(let c=0;c<r;c+=1){let a=c/r,h=a*a,l=h*a,s=1-a,v=s*s,p=v*s,m=p*t.startPoint.x;m+=3*v*a*t.control1.x,m+=3*s*h*t.control2.x,m+=l*t.endPoint.x;let _=p*t.startPoint.y;_+=3*v*a*t.control1.y,_+=3*s*h*t.control2.y,_+=l*t.endPoint.y;let u=Math.min(t.startWidth+l*o,e.maxWidth);this._drawCurveSegment(m,_,u)}i.closePath(),i.fill()}_drawDot(t,e){let i=this._ctx,o=e.dotSize>0?e.dotSize:(e.minWidth+e.maxWidth)/2;i.beginPath(),this._drawCurveSegment(t.x,t.y,o),i.closePath(),i.fillStyle=e.penColor,i.fill()}_fromData(t,e,i){for(let o of t){let{points:r}=o,c=this._getPointGroupOptions(o);if(r.length>1)for(let a=0;a<r.length;a+=1){let h=r[a],l=new b(h.x,h.y,h.pressure,h.time);a===0&&this._reset(c);let s=this._addPoint(l,c);s&&e(s,c)}else this._reset(c),i(r[0],c)}}toSVG({includeBackgroundColor:t=!1,includeDataUrl:e=!1}={}){let i=this._data,o=Math.max(window.devicePixelRatio||1,1),r=0,c=0,a=this.canvas.width/o,h=this.canvas.height/o,l=document.createElementNS("http://www.w3.org/2000/svg","svg");if(l.setAttribute("xmlns","http://www.w3.org/2000/svg"),l.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink"),l.setAttribute("viewBox",\`\${r} \${c} \${a} \${h}\`),l.setAttribute("width",a.toString()),l.setAttribute("height",h.toString()),t&&this.backgroundColor){let s=document.createElement("rect");s.setAttribute("width","100%"),s.setAttribute("height","100%"),s.setAttribute("fill",this.backgroundColor),l.appendChild(s)}if(e&&this._dataUrl){let s=this._dataUrlOptions?.ratio||window.devicePixelRatio||1,v=this._dataUrlOptions?.width||this.canvas.width/s,p=this._dataUrlOptions?.height||this.canvas.height/s,m=this._dataUrlOptions?.xOffset||0,_=this._dataUrlOptions?.yOffset||0,u=document.createElement("image");u.setAttribute("x",m.toString()),u.setAttribute("y",_.toString()),u.setAttribute("width",v.toString()),u.setAttribute("height",p.toString()),u.setAttribute("preserveAspectRatio","none"),u.setAttribute("href",this._dataUrl),l.appendChild(u)}return this._fromData(i,(s,{penColor:v})=>{let p=document.createElement("path");if(!isNaN(s.control1.x)&&!isNaN(s.control1.y)&&!isNaN(s.control2.x)&&!isNaN(s.control2.y)){let m=\`M \${s.startPoint.x.toFixed(3)},\${s.startPoint.y.toFixed(3)} C \${s.control1.x.toFixed(3)},\${s.control1.y.toFixed(3)} \${s.control2.x.toFixed(3)},\${s.control2.y.toFixed(3)} \${s.endPoint.x.toFixed(3)},\${s.endPoint.y.toFixed(3)}\`;p.setAttribute("d",m),p.setAttribute("stroke-width",(s.endWidth*2.25).toFixed(3)),p.setAttribute("stroke",v),p.setAttribute("fill","none"),p.setAttribute("stroke-linecap","round"),l.appendChild(p)}},(s,{penColor:v,dotSize:p,minWidth:m,maxWidth:_})=>{let u=document.createElement("circle"),g=p>0?p:(m+_)/2;u.setAttribute("r",g.toString()),u.setAttribute("cx",s.x.toString()),u.setAttribute("cy",s.y.toString()),u.setAttribute("fill",v),l.appendChild(u)}),l.outerHTML}}});module.exports=(M(),B(T)).default;
  if(__exports != exports)module.exports = exports;return module.exports}));

  return module.exports;
})();
//  End embedded signature_pad 

const { useEffect, useCallback } = React
const { Stack, Label, DefaultButton, Text } = Fluent

/**
 * SignaturePad - A canvas-based signature capture component
 *
 * Props:
 * - fieldId: string - The field identifier for data binding
 * - label: string - The field label text
 * - penColor: string - Drawing color (default: "black")
 * - penMinWidth: number - Min stroke width (default: 0.5)
 * - penMaxWidth: number - Max stroke width (default: 2.5)
 * - backgroundColor: string - Canvas background color (default: "rgb(255,255,255)")
 * - height: number - Canvas height in pixels (default: 120)
 * - required: boolean - Whether the field is required
 * - readOnly: boolean - Whether the field is read-only
 */
const SignaturePad = ({
  fieldId = "signature",
  label = "Signature",
  penColor = "black",
  penMinWidth = 0.5,
  penMaxWidth = 2.5,
  backgroundColor = "rgb(255,255,255)",
  height = 120,
  required = false,
  readOnly = false,
}) => {
  const [fieldData, setFieldData] = useActiveData(fd => fd.field.data)
  const theme = useTheme()
  const canvasRef = useRef(null)
  const padRef = useRef(null)
  const containerRef = useRef(null)

  const savedDataUrl = fieldData?.[fieldId]?.dataUrl || null

  // Resize canvas to match container width while preserving DPI
  const resizeCanvas = useCallback(() => {
    const canvas = canvasRef.current
    const container = containerRef.current
    if (!canvas || !container) return

    const ratio = Math.max(window.devicePixelRatio || 1, 1)
    const width = container.clientWidth

    canvas.width = width * ratio
    canvas.height = height * ratio
    canvas.style.width = width + "px"
    canvas.style.height = height + "px"
    canvas.getContext("2d").scale(ratio, ratio)

    if (padRef.current) {
      padRef.current.clear()
      // Restore saved data after resize
      if (savedDataUrl) {
        padRef.current.fromDataURL(savedDataUrl, {
          ratio: ratio,
          width: width,
          height: height,
        })
      }
    }
  }, [height, savedDataUrl])

  // Initialize signature pad
  useEffect(() => {
    if (readOnly || !canvasRef.current) return

    const pad = new SignaturePadLib(canvasRef.current, {
      penColor: penColor,
      minWidth: penMinWidth,
      maxWidth: penMaxWidth,
      backgroundColor: backgroundColor,
    })
    padRef.current = pad

    // Save signature data on stroke end
    const handleEndStroke = () => {
      if (pad.isEmpty()) return
      const dataUrl = pad.toDataURL("image/png")
      setFieldData({
        [fieldId]: {
          dataUrl: dataUrl,
          isEmpty: false,
        }
      })
    }
    pad.addEventListener("endStroke", handleEndStroke)

    resizeCanvas()

    // Restore existing data
    if (savedDataUrl) {
      const ratio = Math.max(window.devicePixelRatio || 1, 1)
      const canvas = canvasRef.current
      const container = containerRef.current
      const width = container ? container.clientWidth : canvas.width
      pad.fromDataURL(savedDataUrl, {
        ratio: ratio,
        width: width,
        height: height,
      })
    }

    return () => {
      pad.removeEventListener("endStroke", handleEndStroke)
      pad.off()
      padRef.current = null
    }
  }, [readOnly, penColor, penMinWidth, penMaxWidth, backgroundColor, fieldId])

  // Handle window resize
  useEffect(() => {
    if (readOnly) return
    window.addEventListener("resize", resizeCanvas)
    return () => window.removeEventListener("resize", resizeCanvas)
  }, [resizeCanvas, readOnly])

  // Clear handler
  const handleClear = useCallback(() => {
    if (padRef.current) {
      padRef.current.clear()
      setFieldData({
        [fieldId]: {
          dataUrl: null,
          isEmpty: true,
        }
      })
    }
  }, [fieldId, setFieldData])

  const containerStyle = {
    border: "1px solid " + (theme.semanticColors?.inputBorder || "#c8c6c4"),
    borderRadius: "4px",
    overflow: "hidden",
    backgroundColor: backgroundColor,
  }

  const readOnlyImageStyle = {
    maxWidth: "100%",
    height: height + "px",
    objectFit: "contain",
    backgroundColor: backgroundColor,
    borderRadius: "4px",
    border: "1px solid " + (theme.semanticColors?.inputBorder || "#c8c6c4"),
  }

  return (
    <div style={{ marginBottom: "8px" }}>
      <Label required={required}>{label}</Label>

      {readOnly ? (
        savedDataUrl ? (
          <img src={savedDataUrl} alt="Signature" style={readOnlyImageStyle} />
        ) : (
          <Text variant="small" style={{ color: theme.semanticColors?.disabledText || "#a19f9d", fontStyle: "italic" }}>
            No signature captured
          </Text>
        )
      ) : (
        <div>
          <div ref={containerRef} style={containerStyle}>
            <canvas
              ref={canvasRef}
              style={{ display: "block", width: "100%", height: height + "px" }}
            />
          </div>
          <Stack horizontal tokens={{ childrenGap: 8 }} style={{ marginTop: "8px" }}>
            <DefaultButton
              text="Clear"
              onClick={handleClear}
              iconProps={{ iconName: "EraseTool" }}
              disabled={!savedDataUrl}
            />
          </Stack>
        </div>
      )}
    </div>
  )
}
`,
  './SubformScoring/index.jsx': `/**
 * SubformScoring - Modal subform supporting scoring and data-entry modes.
 *
 * mode="scoring": existing behavior, opens ScoringModule in a dialog.
 * mode="data-entry": opens regular fields in a dialog with optional calculations.
 */

const { useState, useMemo, useCallback } = React
const {
  Stack,
  Text,
  PrimaryButton,
  DefaultButton,
  Dialog,
  DialogType,
} = Fluent

// ================================================
// Scoring helpers (same logic as ScoringModule)
// ================================================

const _buildScoreMap = (questions) => {
  const map = new Map()
  for (const question of questions || []) {
    const optionMap = new Map()
    for (const opt of question.options || []) {
      optionMap.set(opt.key, opt.score ?? 0)
    }
    map.set(question.id, optionMap)
  }
  return map
}

const _normalizeScoreToken = (value) => String(value ?? "").trim().toLowerCase()

const _collectScoreCandidates = (value, out = new Set(), depth = 0) => {
  if (depth > 4 || value === null || value === undefined) return out

  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    const token = String(value).trim()
    if (token) out.add(token)
    return out
  }

  if (Array.isArray(value)) {
    value.forEach((entry) => _collectScoreCandidates(entry, out, depth + 1))
    return out
  }

  if (typeof value !== "object") return out

  const candidateKeys = [
    "code",
    "key",
    "value",
    "id",
    "text",
    "display",
    "label",
    "state",
    "fieldId",
  ]
  candidateKeys.forEach((key) => {
    _collectScoreCandidates(value[key], out, depth + 1)
  })

  if (Array.isArray(value.selectedItems)) {
    value.selectedItems.forEach((entry) => _collectScoreCandidates(entry, out, depth + 1))
  }
  _collectScoreCandidates(value.selectedItem, out, depth + 1)
  if (Array.isArray(value.selectedIds)) {
    value.selectedIds.forEach((entry) => _collectScoreCandidates(entry, out, depth + 1))
  }
  if (Array.isArray(value.selectedLabels)) {
    value.selectedLabels.forEach((entry) => _collectScoreCandidates(entry, out, depth + 1))
  }

  return out
}

const _getScoreFromValue = (value, optionScoreMap) => {
  if (!optionScoreMap) return null

  const candidates = Array.from(_collectScoreCandidates(value))
  if (candidates.length === 0) return null

  for (const candidate of candidates) {
    if (optionScoreMap.has(candidate)) {
      return optionScoreMap.get(candidate)
    }
  }

  const normalizedOptionMap = new Map()
  optionScoreMap.forEach((score, key) => {
    normalizedOptionMap.set(_normalizeScoreToken(key), score)
  })
  for (const candidate of candidates) {
    const direct = normalizedOptionMap.get(_normalizeScoreToken(candidate))
    if (direct !== undefined) return direct
  }

  return null
}

const _isInRange = (score, range) => {
  if (score === null || score === undefined) return false
  const min = range.min
  const max = range.max
  const meetsMin = range.minInclusive !== false ? score >= min : score > min
  const meetsMax = max === null ? true : (range.maxInclusive !== false ? score <= max : score < max)
  return meetsMin && meetsMax
}

const _getInterpretation = (score, ranges) => {
  if (score === null || score === undefined || !ranges?.length) return null
  for (const range of ranges) {
    if (_isInRange(score, range)) {
      return {
        label: range.label,
        range,
        bounds: _formatBounds(range),
      }
    }
  }
  return null
}

const _formatBounds = (range) => {
  const minSymbol = range.minInclusive !== false ? "\\u2265" : ">"
  if (range.max === null) return \`\${minSymbol}\${range.min}\`
  if (range.min === range.max && range.minInclusive !== false && range.maxInclusive !== false) {
    return \`=\${range.min}\`
  }
  return \`\${range.min}-\${range.max}\`
}

// ================================================
// Data-entry helpers
// ================================================

const _isMeaningfulValue = (value) => {
  if (value === null || value === undefined) return false
  if (typeof value === "string") return value.trim().length > 0
  if (Array.isArray(value)) return value.length > 0
  if (typeof value === "object") {
    if (Number.isFinite(value.selectedCount)) {
      return Number(value.selectedCount) > 0
    }
    if (value.display) return String(value.display).trim().length > 0
    if (value.text) return String(value.text).trim().length > 0
    if (value.code) return String(value.code).trim().length > 0
    if (value.key) return String(value.key).trim().length > 0
    return Object.keys(value).length > 0
  }
  return true
}

const _toDisplayValue = (value) => {
  if (!_isMeaningfulValue(value)) return ""
  if (Array.isArray(value)) {
    return value.map(_toDisplayValue).filter(Boolean).join(", ")
  }
  if (typeof value === "object") {
    if (Array.isArray(value.selectedLabels) && value.selectedLabels.length > 0) {
      return value.selectedLabels.join(", ")
    }
    if (Array.isArray(value.selectedIds) && value.selectedIds.length > 0) {
      return value.selectedIds.join(", ")
    }
    if (Number.isFinite(value.selectedCount)) {
      return \`\${value.selectedCount}\`
    }
    return value.display || value.text || value.code || value.key || ""
  }
  return String(value)
}

const _toNumericValue = (value) => {
  if (value === null || value === undefined) return null
  if (typeof value === "number" && Number.isFinite(value)) return value
  if (typeof value === "string") {
    const trimmed = value.trim()
    if (!trimmed) return null
    const direct = Number(trimmed)
    if (Number.isFinite(direct)) return direct
    const normalized = trimmed
      .replace(/[]/g, "-")
      .replace(/(\\d)[,\\s](?=\\d{3}\\b)/g, "$1")
      .replace(/,(?=\\d{1,2}\\b)/g, ".")
    const extracted = normalized.match(/[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/)
    if (!extracted) return null
    const parsed = Number(extracted[0])
    return Number.isFinite(parsed) ? parsed : null
  }
  if (typeof value === "object") {
    if (Number.isFinite(value.selectedCount)) {
      return Number(value.selectedCount)
    }
    const candidate = value.value ?? value.display ?? value.text ?? value.code ?? value.key
    return _toNumericValue(candidate)
  }
  return null
}

const _evaluateExpression = (expression, varsByName) => {
  if (typeof expression !== "string") return null
  const trimmed = expression.trim()
  if (!trimmed) return null
  if (!/^[0-9+\\-*/().,\\s_a-zA-Z]+$/.test(trimmed)) return null

  const tokenMatches = trimmed.match(/[A-Za-z_][A-Za-z0-9_]*/g) || []
  const uniqueTokens = Array.from(new Set(tokenMatches)).sort((a, b) => b.length - a.length)
  let prepared = trimmed
  for (const token of uniqueTokens) {
    const numeric = varsByName[token]
    if (!Number.isFinite(numeric)) return null
    const replacement = String(numeric)
    prepared = prepared.replace(new RegExp(\`\\\\b\${token}\\\\b\`, "g"), replacement)
  }

  try {
    const result = Function(\`"use strict"; return (\${prepared});\`)()
    return typeof result === "number" && Number.isFinite(result) ? result : null
  } catch (error) {
    return null
  }
}

const _isHeadingField = (field) => field?.type === "heading"

const _resolveFieldWidthBasis = (field) => {
  if (_isHeadingField(field)) return "100%"
  const normalized = typeof field?.width === "string" ? field.width.trim().toLowerCase() : ""
  switch (normalized) {
    case "1/4":
    case "25%":
      return "25%"
    case "1/3":
    case "33%":
    case "33.3%":
    case "33.33%":
      return "33.3333%"
    case "1/2":
    case "50%":
    case "half":
      return "50%"
    case "2/3":
    case "66%":
    case "66.6%":
    case "66.67%":
      return "66.6667%"
    case "3/4":
    case "75%":
      return "75%"
    case "1/1":
    case "100%":
    case "full":
      return "100%"
    case "auto":
      return field?.type === "textarea" ? "100%" : "50%"
    default:
      return "100%"
  }
}

const _formatNumericValue = (value, precision = 1) => {
  if (value === null || value === undefined || !Number.isFinite(Number(value))) return null
  const numeric = Number(value)
  const boundedPrecision = Number.isFinite(precision) ? Math.max(0, Math.min(6, Math.trunc(precision))) : null
  if (boundedPrecision === null) return \`\${numeric}\`
  return numeric.toFixed(boundedPrecision).replace(/\\.0+$/, "").replace(/(\\.\\d*?)0+$/, "$1")
}

const _formatCalculatorDisplayValue = (value, precision = 1, fallback = "Incomplete") => {
  const formatted = _formatNumericValue(value, precision)
  return formatted === null ? fallback : formatted
}

const _computeMorphineEquivalent = (doseValue, equivalentDoseMg, baseEquivalentDoseMg) => {
  const dose = _toNumericValue(doseValue)
  const equivalentDose = Number(equivalentDoseMg)
  const baseDose = Number(baseEquivalentDoseMg)
  if (!Number.isFinite(dose)) return null
  if (!Number.isFinite(equivalentDose) || equivalentDose <= 0) return null
  if (!Number.isFinite(baseDose) || baseDose <= 0) return null
  return (dose * baseDose) / equivalentDose
}

// ================================================
// Summary sub-components
// ================================================

const ScoreSummaryItem = ({ total, score, isComplete, isDarkMode }) => {
  const style = {
    display: "flex",
    alignItems: "center",
    gap: "8px",
    padding: "6px 12px",
    borderRadius: "4px",
    backgroundColor: isDarkMode ? "#1a3a5c" : "#e6f2ff",
    border: \`1px solid \${isDarkMode ? "#2a5a8c" : "#b8d4f0"}\`,
  }

  if (!isComplete) {
    return (
      <div style={{ ...style, backgroundColor: isDarkMode ? "#3a3a1a" : "#fff8e6", border: \`1px solid \${isDarkMode ? "#5a5a2a" : "#f0e0b8"}\` }}>
        <Text styles={{ root: { fontWeight: 600, fontSize: "13px" } }}>{total.label}:</Text>
        <Text styles={{ root: { fontSize: "13px", color: isDarkMode ? "#cca050" : "#996600", fontStyle: "italic" } }}>
          Incomplete
        </Text>
      </div>
    )
  }

  return (
    <div style={style}>
      <Text styles={{ root: { fontWeight: 600, fontSize: "13px" } }}>{total.label}:</Text>
      <Text styles={{ root: { fontWeight: 700, fontSize: "16px" } }}>{score}</Text>
    </div>
  )
}

const InterpretationSummaryItem = ({ total, score, isComplete, isDarkMode }) => {
  const interpretation = _getInterpretation(score, total.ranges)

  if (!isComplete || !interpretation) return null

  const style = {
    display: "inline-flex",
    alignItems: "center",
    gap: "6px",
    padding: "4px 10px",
    borderRadius: "4px",
    backgroundColor: isDarkMode ? "#2a5a8c" : "#0078d4",
    color: "#ffffff",
    fontSize: "13px",
    fontWeight: 500,
  }

  return (
    <span style={style}>
      {interpretation.bounds} &middot; {interpretation.label}
    </span>
  )
}

const AnswerSummaryItem = ({ question, answer, isDarkMode }) => {
  if (!answer) return null
  const displayText = _toDisplayValue(answer)
  if (!displayText) return null

  const style = {
    display: "flex",
    alignItems: "baseline",
    gap: "6px",
    padding: "4px 0",
    fontSize: "13px",
  }

  const labelStyle = {
    color: isDarkMode ? "#a0a0a0" : "#666666",
    fontWeight: 500,
    flexShrink: 0,
  }

  return (
    <div style={style}>
      <span style={labelStyle}>{question.label}:</span>
      <span>{displayText}</span>
    </div>
  )
}

const DataFieldSummaryItem = ({ field, value, isDarkMode }) => {
  if (!field) return null
  const displayText = _toDisplayValue(value)
  if (!displayText) return null

  const style = {
    display: "flex",
    alignItems: "baseline",
    gap: "6px",
    padding: "4px 0",
    fontSize: "13px",
  }

  const labelStyle = {
    color: isDarkMode ? "#a0a0a0" : "#666666",
    fontWeight: 500,
    flexShrink: 0,
  }

  return (
    <div style={style}>
      <span style={labelStyle}>{field.label}:</span>
      <span>{displayText}</span>
    </div>
  )
}

const CalculationSummaryItem = ({ calculation, value, isDarkMode }) => {
  if (!calculation) return null

  const style = {
    display: "flex",
    alignItems: "center",
    gap: "8px",
    padding: "6px 12px",
    borderRadius: "4px",
    backgroundColor: isDarkMode ? "#1a3a5c" : "#e6f2ff",
    border: \`1px solid \${isDarkMode ? "#2a5a8c" : "#b8d4f0"}\`,
  }

  if (value === null || value === undefined) {
    return (
      <div style={{ ...style, backgroundColor: isDarkMode ? "#3a3a1a" : "#fff8e6", border: \`1px solid \${isDarkMode ? "#5a5a2a" : "#f0e0b8"}\` }}>
        <Text styles={{ root: { fontWeight: 600, fontSize: "13px" } }}>{calculation.label}:</Text>
        <Text styles={{ root: { fontSize: "13px", color: isDarkMode ? "#cca050" : "#996600", fontStyle: "italic" } }}>
          Incomplete
        </Text>
      </div>
    )
  }

  return (
    <div style={style}>
      <Text styles={{ root: { fontWeight: 600, fontSize: "13px" } }}>{calculation.label}:</Text>
      <Text styles={{ root: { fontWeight: 700, fontSize: "16px" } }}>{value}</Text>
    </div>
  )
}

const ProgressSummaryItem = ({ answered, total, percentage, isDarkMode }) => {
  const barBg = isDarkMode ? "#333333" : "#e0e0e0"
  const barFill = percentage === 100
    ? (isDarkMode ? "#2a8c2a" : "#28a745")
    : (isDarkMode ? "#0078d4" : "#0078d4")

  return (
    <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
      <div style={{
        flex: 1,
        height: "6px",
        backgroundColor: barBg,
        borderRadius: "3px",
        overflow: "hidden",
      }}>
        <div style={{
          width: \`\${percentage}%\`,
          height: "100%",
          backgroundColor: barFill,
          borderRadius: "3px",
          transition: "width 0.3s ease",
        }} />
      </div>
      <Text styles={{ root: { fontSize: "12px", color: isDarkMode ? "#a0a0a0" : "#666666", whiteSpace: "nowrap" } }}>
        {answered}/{total} ({percentage}%)
      </Text>
    </div>
  )
}

// ================================================
// Main component
// ================================================

const SubformScoring = ({
  id = "subformScoring",
  mode,
  title,
  buttonText = "Complete Assessment",
  config = { questions: [], totals: [] },
  dataEntryConfig = { fields: [], calculations: [] },
  summaryConfig = {},
  modalConfig = {},
  showProgress = true,
  ...props
}) => {
  const [isOpen, setIsOpen] = useState(false)
  const [fd] = useActiveData()
  const theme = useTheme()
  const isDarkMode = theme?.isInverted || false

  const isDataEntryMode = useMemo(() => {
    if (mode === "data-entry") return true
    if (mode === "scoring") return false
    return Array.isArray(dataEntryConfig?.fields) && dataEntryConfig.fields.length > 0
  }, [mode, dataEntryConfig])

  const setDataEntryValue = useCallback((fieldId, nextValue) => {
    if (!fieldId || !fd?.setFormData) return
    fd.setFormData((draft) => {
      if (!draft.field) {
        draft.field = { data: {}, status: {}, history: [] }
      }
      if (!draft.field.data) {
        draft.field.data = {}
      }
      if (nextValue === undefined) {
        draft.field.data[fieldId] = null
      } else {
        draft.field.data[fieldId] = nextValue
      }
    })
  }, [fd])

  // Scoring-mode answer and score calculations
  const scoreMap = useMemo(() => {
    if (isDataEntryMode) return new Map()
    return _buildScoreMap(config.questions)
  }, [isDataEntryMode, config.questions])

  const answers = useMemo(() => {
    if (isDataEntryMode) return {}
    const result = {}
    for (const question of config.questions || []) {
      const value = fd?.field?.data?.[question.id]
      if (value) {
        result[question.id] = value
      }
    }
    return result
  }, [isDataEntryMode, fd, config.questions])

  const calculatedTotals = useMemo(() => {
    if (isDataEntryMode) return {}
    const results = {}
    for (const total of config.totals || []) {
      let score = 0
      let isComplete = true
      for (const term of total.terms || []) {
        const answer = answers[term.questionId]
        const optionScoreMap = scoreMap.get(term.questionId)
        const answerScore = _getScoreFromValue(answer, optionScoreMap)
        if (answerScore !== null) {
          score += answerScore * (term.weight || 1)
        } else {
          isComplete = false
        }
      }
      results[total.id] = { score: isComplete ? score : null, isComplete }
    }
    return results
  }, [isDataEntryMode, answers, config.totals, scoreMap])

  // Data-entry-mode values and calculations
  const dataEntryFields = useMemo(() => {
    return Array.isArray(dataEntryConfig?.fields) ? dataEntryConfig.fields : []
  }, [dataEntryConfig])

  const dataEntryFieldById = useMemo(() => {
    const map = new Map()
    for (const field of dataEntryFields) {
      if (!field?.id) continue
      map.set(field.id, field)
    }
    return map
  }, [dataEntryFields])

  const dataEntryCalculatorConfig = useMemo(() => {
    const rawConfig = dataEntryConfig?.calculatorConfig || dataEntryConfig?.calculator_config
    if (!rawConfig || typeof rawConfig !== "object") return null

    const rawType = String(rawConfig.type || rawConfig.calculatorType || rawConfig.calculator_type || "").trim().toLowerCase()
    const normalizedType =
      rawType === "morphine-equivalence" ||
      rawType === "morphine_equivalence" ||
      rawType === "meq"
        ? "morphine-equivalence"
        : null
    if (!normalizedType) return null

    const rawRows = Array.isArray(rawConfig.rows) ? rawConfig.rows : []
    const rows = rawRows
      .map((row, index) => {
        if (!row || typeof row !== "object") return null
        const rowId = String(row.id || \`row_\${index + 1}\`).trim()
        const label = String(row.label || rowId || \`Row \${index + 1}\`).trim()
        const inputFieldId = String(
          row.inputFieldId ||
          row.input_field_id ||
          row.fieldId ||
          row.field_id ||
          row.doseFieldId ||
          row.dose_field_id ||
          ""
        ).trim()
        if (!inputFieldId) return null

        const equivalentDoseMg = Number(
          row.equivalentDoseMg ??
          row.equivalent_dose_mg ??
          row.equivalentDose ??
          row.equivalent_dose
        )
        if (!Number.isFinite(equivalentDoseMg) || equivalentDoseMg <= 0) return null

        const meqCalculationId = String(row.meqCalculationId || row.meq_calculation_id || "").trim() || null
        const precisionRaw = Number(row.precision)
        const precision = Number.isFinite(precisionRaw)
          ? Math.max(0, Math.min(6, Math.trunc(precisionRaw)))
          : 1
        return {
          id: rowId,
          label,
          inputFieldId,
          equivalentDoseMg,
          meqCalculationId,
          precision
        }
      })
      .filter(Boolean)

    if (rows.length === 0) return null

    const baseEquivalentDoseRaw = Number(rawConfig.baseEquivalentDoseMg ?? rawConfig.base_equivalent_dose_mg)
    const baseEquivalentDoseMg = Number.isFinite(baseEquivalentDoseRaw) && baseEquivalentDoseRaw > 0
      ? baseEquivalentDoseRaw
      : 30
    const totalCalculationId = String(rawConfig.totalCalculationId || rawConfig.total_calculation_id || "").trim() || null
    const totalLabel = String(rawConfig.totalLabel || rawConfig.total_label || "TOTAL MEQ").trim() || "TOTAL MEQ"
    const doseColumnLabel = String(rawConfig.doseColumnLabel || rawConfig.dose_column_label || "Total Daily Dose").trim() || "Total Daily Dose"
    const equivalentColumnLabel = String(rawConfig.equivalentColumnLabel || rawConfig.equivalent_column_label || "Equivalent Dose (mg)").trim() || "Equivalent Dose (mg)"
    const resultColumnLabel = String(rawConfig.resultColumnLabel || rawConfig.result_column_label || "Morphine Equivalent (MEQ)").trim() || "Morphine Equivalent (MEQ)"

    return {
      type: normalizedType,
      rows,
      baseEquivalentDoseMg,
      totalCalculationId,
      totalLabel,
      doseColumnLabel,
      equivalentColumnLabel,
      resultColumnLabel
    }
  }, [dataEntryConfig])

  const isMorphineCalculatorMode = useMemo(() => {
    return isDataEntryMode &&
      dataEntryCalculatorConfig?.type === "morphine-equivalence" &&
      Array.isArray(dataEntryCalculatorConfig?.rows) &&
      dataEntryCalculatorConfig.rows.length > 0
  }, [isDataEntryMode, dataEntryCalculatorConfig])

  const dataEntryValues = useMemo(() => {
    if (!isDataEntryMode) return {}
    const result = {}
    for (const field of dataEntryFields) {
      if (_isHeadingField(field)) continue
      result[field.id] = fd?.field?.data?.[field.id]
    }
    if (isMorphineCalculatorMode) {
      for (const row of dataEntryCalculatorConfig?.rows || []) {
        if (!row?.inputFieldId) continue
        if (!(row.inputFieldId in result)) {
          result[row.inputFieldId] = fd?.field?.data?.[row.inputFieldId]
        }
      }
    }
    return result
  }, [isDataEntryMode, isMorphineCalculatorMode, dataEntryCalculatorConfig, dataEntryFields, fd])

  const dataEntryCalculations = useMemo(() => {
    return Array.isArray(dataEntryConfig?.calculations) ? dataEntryConfig.calculations : []
  }, [dataEntryConfig])

  const calculatedExpressions = useMemo(() => {
    if (!isDataEntryMode) return {}
    const vars = {}
    const variableFieldIds = new Set()
    for (const field of dataEntryFields) {
      if (_isHeadingField(field)) continue
      variableFieldIds.add(field.id)
    }
    if (isMorphineCalculatorMode) {
      for (const row of dataEntryCalculatorConfig?.rows || []) {
        if (row?.inputFieldId) variableFieldIds.add(row.inputFieldId)
      }
    }
    for (const fieldId of variableFieldIds) {
      vars[fieldId] = _toNumericValue(dataEntryValues[fieldId])
    }
    const result = {}
    for (const calculation of dataEntryCalculations) {
      const value = _evaluateExpression(calculation.expression, vars)
      if (value === null || value === undefined) {
        result[calculation.id] = null
        continue
      }
      const precision = Number.isFinite(calculation.precision) ? Math.max(0, Math.min(6, calculation.precision)) : null
      result[calculation.id] = precision === null ? value : Number(value.toFixed(precision))
    }
    return result
  }, [isDataEntryMode, isMorphineCalculatorMode, dataEntryCalculatorConfig, dataEntryFields, dataEntryValues, dataEntryCalculations])

  const progress = useMemo(() => {
    if (isDataEntryMode) {
      const calculatorFields = isMorphineCalculatorMode
        ? (dataEntryCalculatorConfig?.rows || []).map((row) => (
            dataEntryFieldById.get(row.inputFieldId) || {
              id: row.inputFieldId,
              required: false,
            }
          ))
        : []
      const answerableFields = calculatorFields.length > 0
        ? calculatorFields
        : dataEntryFields.filter((field) => !_isHeadingField(field))
      const requiredFields = answerableFields.filter((field) => field.required)
      const fieldsForProgress = requiredFields.length > 0 ? requiredFields : answerableFields
      const total = fieldsForProgress.length
      const answered = fieldsForProgress.filter((field) => _isMeaningfulValue(dataEntryValues[field.id])).length
      return {
        answered,
        total,
        percentage: total > 0 ? Math.round((answered / total) * 100) : 0
      }
    }

    const total = config.questions?.length || 0
    const answered = (config.questions || []).filter((question) => {
      const value = answers[question.id]
      const optionScoreMap = scoreMap.get(question.id)
      return _getScoreFromValue(value, optionScoreMap) !== null
    }).length
    return {
      answered,
      total,
      percentage: total > 0 ? Math.round((answered / total) * 100) : 0
    }
  }, [isDataEntryMode, isMorphineCalculatorMode, dataEntryCalculatorConfig, dataEntryFieldById, dataEntryFields, dataEntryValues, config.questions, answers])

  const hasAnyAnswers = useMemo(() => {
    if (isDataEntryMode) {
      if (isMorphineCalculatorMode) {
        return (dataEntryCalculatorConfig?.rows || []).some((row) =>
          _isMeaningfulValue(dataEntryValues[row.inputFieldId])
        )
      }
      return dataEntryFields
        .filter((field) => !_isHeadingField(field))
        .some((field) => _isMeaningfulValue(dataEntryValues[field.id]))
    }
    return progress.answered > 0
  }, [isDataEntryMode, isMorphineCalculatorMode, dataEntryCalculatorConfig, dataEntryFields, dataEntryValues, progress])

  const showItems = useMemo(() => {
    if (Array.isArray(summaryConfig.showItems) && summaryConfig.showItems.length > 0) {
      return summaryConfig.showItems
    }
    if (isDataEntryMode) {
      if (isMorphineCalculatorMode && dataEntryCalculatorConfig?.totalCalculationId) {
        return [
          {
            type: "calculation",
            calculationId: dataEntryCalculatorConfig.totalCalculationId,
          },
          { type: "progress" },
        ]
      }
      const defaults = dataEntryCalculations.map((calculation) => ({
        type: "calculation",
        calculationId: calculation.id
      }))
      defaults.push({ type: "progress" })
      return defaults
    }
    return []
  }, [summaryConfig.showItems, isDataEntryMode, isMorphineCalculatorMode, dataEntryCalculatorConfig, dataEntryCalculations])

  const summaryLayout = summaryConfig.layout || "stacked"

  const getTotalConfig = useCallback((totalId) => {
    return (config.totals || []).find((total) => total.id === totalId)
  }, [config.totals])

  const getQuestionConfig = useCallback((questionId) => {
    return (config.questions || []).find((question) => question.id === questionId)
  }, [config.questions])

  const getDataEntryFieldConfig = useCallback((fieldId) => {
    return dataEntryFieldById.get(fieldId)
  }, [dataEntryFieldById])

  const getCalculationConfig = useCallback((calculationId) => {
    return dataEntryCalculations.find((calculation) => calculation.id === calculationId)
  }, [dataEntryCalculations])

  const renderDataEntryField = (field) => {
    if (_isHeadingField(field)) {
      return (
        <Text
          key={\`field-\${field.id}\`}
          styles={{
            root: {
              marginTop: "12px",
              marginBottom: "2px",
              fontSize: "13px",
              fontWeight: 700,
              textTransform: "uppercase",
              letterSpacing: "0.03em",
              color: isDarkMode ? "#d9d9d9" : "#333",
              borderBottom: \`1px solid \${isDarkMode ? "#404040" : "#e5e5e5"}\`,
              paddingBottom: "4px"
            }
          }}
        >
          {field.label}
        </Text>
      )
    }

    const required = field.required === true
    const commonProps = {
      fieldId: field.id,
      label: field.label,
      required,
    }

    if (field.type === "number") {
      const spinButtonProps = {}
      if (Number.isFinite(field.min)) spinButtonProps.min = field.min
      if (Number.isFinite(field.max)) spinButtonProps.max = field.max
      if (Number.isFinite(field.step)) spinButtonProps.step = field.step
      const hasSpinProps = Object.keys(spinButtonProps).length > 0
      return (
        <Numeric
          key={\`field-\${field.id}\`}
          {...commonProps}
          storeAsNumber
          buttonControls={hasSpinProps}
          spinButtonProps={hasSpinProps ? spinButtonProps : undefined}
          value={dataEntryValues[field.id] ?? ""}
          onChange={(value) => setDataEntryValue(field.id, value)}
        />
      )
    }

    if (field.type === "date") {
      return (
        <DateSelect
          key={\`field-\${field.id}\`}
          {...commonProps}
          placeholder={field.placeholder}
          value={dataEntryValues[field.id]}
          onChange={(value) => setDataEntryValue(field.id, value)}
        />
      )
    }

    if (field.type === "datetime") {
      return (
        <DateTimeSelect
          key={\`field-\${field.id}\`}
          {...commonProps}
          placeholder={field.placeholder}
          value={dataEntryValues[field.id]}
          onChange={(value) => setDataEntryValue(field.id, value)}
        />
      )
    }

    if (field.type === "choice") {
      const optionList = (field.options || []).map((option) => ({ key: option, text: option }))
      const useRadio = field.choiceStyle === "radio"
      if (useRadio) {
        return (
          <SimpleCodeChecklist
            key={\`field-\${field.id}\`}
            {...commonProps}
            optionList={optionList}
            selectionType="single"
            multiline
          />
        )
      }
      return (
        <SimpleCodeSelect
          key={\`field-\${field.id}\`}
          {...commonProps}
          optionList={optionList}
          selectionType="single"
          value={dataEntryValues[field.id]}
          onChange={(value) => setDataEntryValue(field.id, value)}
        />
      )
    }

    if (field.type === "booleanYesNo") {
      const yesNoOptions = (field.options && field.options.length >= 2)
        ? field.options
        : ["Yes", "No"]
      const optionList = yesNoOptions.map((option) => ({ key: option, text: option }))
      return (
        <SimpleCodeChecklist
          key={\`field-\${field.id}\`}
          {...commonProps}
          optionList={optionList}
          selectionType="single"
          multiline
        />
      )
    }

    if (field.type === "textarea") {
      return (
        <TextArea
          key={\`field-\${field.id}\`}
          {...commonProps}
          multiline
          rows={field.rows || 4}
          placeholder={field.placeholder}
          value={dataEntryValues[field.id] ?? ""}
          onChange={(_, value) => setDataEntryValue(field.id, value ?? "")}
        />
      )
    }

    if (field.type === "hotspotMap") {
      return (
        <HotspotMapField
          key={\`field-\${field.id}\`}
          {...commonProps}
          imageUrl={field.imageUrl}
          imageSvg={field.imageSvg}
          imageAlt={field.imageAlt}
          hotspots={Array.isArray(field.hotspots) ? field.hotspots : []}
          allowMultiSelect={field.allowMultiSelect !== false}
          showSummary={field.showSummary !== false}
          showSelectedLabels={field.showSelectedLabels === true}
          showHotspotLabels={field.showHotspotLabels === true}
          totalCountLabel={field.totalCountLabel}
          openInModal={field.openInModal === true}
          modalButtonText={field.modalButtonText}
          modalTitle={field.modalTitle}
          modalMinWidth={field.modalMinWidth}
          mapZoomPercent={field.mapZoomPercent}
          mapWidthPercent={field.mapWidthPercent}
          mapMaxWidth={field.mapMaxWidth}
          mapMinHeight={field.mapMinHeight}
          markerSize={field.markerSize}
          totalCountFieldId={field.totalCountFieldId}
          selectedIdsFieldId={field.selectedIdsFieldId}
          selectedLabelsFieldId={field.selectedLabelsFieldId}
        />
      )
    }

    return (
      <TextArea
        key={\`field-\${field.id}\`}
        {...commonProps}
        placeholder={field.placeholder}
        value={dataEntryValues[field.id] ?? ""}
        onChange={(_, value) => setDataEntryValue(field.id, value ?? "")}
      />
    )
  }

  const renderMorphineCalculator = () => {
    if (!isMorphineCalculatorMode || !dataEntryCalculatorConfig) return null

    const rows = Array.isArray(dataEntryCalculatorConfig.rows) ? dataEntryCalculatorConfig.rows : []
    if (rows.length === 0) return null

    const rowValues = rows.map((row) => {
      const fromCalculation = row.meqCalculationId
        ? calculatedExpressions[row.meqCalculationId]
        : null
      const computedFallback = _computeMorphineEquivalent(
        dataEntryValues[row.inputFieldId],
        row.equivalentDoseMg,
        dataEntryCalculatorConfig.baseEquivalentDoseMg
      )
      return fromCalculation ?? computedFallback
    })

    const totalFromCalculation = dataEntryCalculatorConfig.totalCalculationId
      ? calculatedExpressions[dataEntryCalculatorConfig.totalCalculationId]
      : null
    const totalFallback = rowValues.reduce((sum, value) => {
      if (!Number.isFinite(Number(value))) return sum
      return sum + Number(value)
    }, 0)
    const hasAnyRowValue = rowValues.some((value) => Number.isFinite(Number(value)))
    const totalValue = totalFromCalculation ?? (hasAnyRowValue ? totalFallback : null)

    return (
      <div style={{
        border: \`1px solid \${isDarkMode ? "#404040" : "#d8d8d8"}\`,
        borderRadius: "6px",
        overflow: "hidden"
      }}>
        <div
          style={{
            display: "grid",
            gridTemplateColumns: "1.5fr minmax(140px, 1fr) minmax(120px, 1fr) minmax(160px, 1fr)",
            gap: "8px",
            padding: "10px 12px",
            fontSize: "12px",
            fontWeight: 700,
            textTransform: "uppercase",
            letterSpacing: "0.03em",
            borderBottom: \`1px solid \${isDarkMode ? "#404040" : "#d8d8d8"}\`,
            backgroundColor: isDarkMode ? "#202020" : "#f8f8f8"
          }}
        >
          <span />
          <span>{dataEntryCalculatorConfig.doseColumnLabel}</span>
          <span>{dataEntryCalculatorConfig.equivalentColumnLabel}</span>
          <span>{dataEntryCalculatorConfig.resultColumnLabel}</span>
        </div>

        {rows.map((row, index) => {
          const field = dataEntryFieldById.get(row.inputFieldId)
          const inputType = field?.type === "text" ? "text" : "number"
          const rawValue = dataEntryValues[row.inputFieldId]
          const displayValue = rawValue === null || rawValue === undefined ? "" : String(rawValue)
          const meqValue = rowValues[index]
          const meqDisplay = _formatCalculatorDisplayValue(meqValue, row.precision, "-")

          return (
            <div
              key={\`calculator-row-\${row.id || row.inputFieldId}\`}
              style={{
                display: "grid",
                gridTemplateColumns: "1.5fr minmax(140px, 1fr) minmax(120px, 1fr) minmax(160px, 1fr)",
                gap: "8px",
                alignItems: "center",
                padding: "10px 12px",
                borderBottom: index < rows.length - 1
                  ? \`1px solid \${isDarkMode ? "#333" : "#ececec"}\`
                  : "none"
              }}
            >
              <Text styles={{ root: { fontSize: "16px", fontWeight: 500 } }}>
                {row.label}:
              </Text>
              <input
                type={inputType}
                inputMode="decimal"
                step="any"
                value={displayValue}
                placeholder={inputType === "number" ? "0" : ""}
                onChange={(event) => {
                  const nextRaw = event?.target?.value ?? ""
                  if (!nextRaw) {
                    setDataEntryValue(row.inputFieldId, null)
                    return
                  }
                  if (inputType === "number") {
                    const parsed = Number(nextRaw)
                    setDataEntryValue(row.inputFieldId, Number.isFinite(parsed) ? parsed : nextRaw)
                    return
                  }
                  setDataEntryValue(row.inputFieldId, nextRaw)
                }}
                style={{
                  width: "100%",
                  maxWidth: "140px",
                  height: "34px",
                  borderRadius: "2px",
                  border: \`1px solid \${isDarkMode ? "#5a5a5a" : "#b8b8b8"}\`,
                  backgroundColor: isDarkMode ? "#1a1a1a" : "#fff",
                  color: isDarkMode ? "#fff" : "#111",
                  padding: "4px 8px",
                  fontSize: "15px"
                }}
              />
              <Text styles={{ root: { fontSize: "20px", fontWeight: 500 } }}>
                {_formatCalculatorDisplayValue(row.equivalentDoseMg, 2, "-")}
              </Text>
              <Text styles={{ root: { fontSize: "22px", fontWeight: 700 } }}>
                {meqDisplay}
              </Text>
            </div>
          )
        })}

        <div style={{
          borderTop: \`1px solid \${isDarkMode ? "#404040" : "#d8d8d8"}\`,
          backgroundColor: isDarkMode ? "#252525" : "#f4f4f4",
          padding: "12px",
          display: "flex",
          justifyContent: "center",
          alignItems: "baseline",
          gap: "14px"
        }}>
          <Text styles={{ root: { fontSize: "36px", fontWeight: 800, letterSpacing: "0.02em" } }}>
            {dataEntryCalculatorConfig.totalLabel}:
          </Text>
          <Text styles={{ root: { fontSize: "40px", fontWeight: 800, lineHeight: 1 } }}>
            {_formatCalculatorDisplayValue(totalValue, 1)}
          </Text>
        </div>
      </div>
    )
  }

  const renderSummaryItem = (item, index) => {
    if (isDataEntryMode) {
      switch (item.type) {
        case "field": {
          const field = getDataEntryFieldConfig(item.fieldId)
          if (!field) return null
          return (
            <DataFieldSummaryItem
              key={\`field-\${index}\`}
              field={field}
              value={dataEntryValues[field.id]}
              isDarkMode={isDarkMode}
            />
          )
        }
        case "calculation": {
          const calculation = getCalculationConfig(item.calculationId)
          if (!calculation) return null
          return (
            <CalculationSummaryItem
              key={\`calc-\${index}\`}
              calculation={calculation}
              value={calculatedExpressions[calculation.id]}
              isDarkMode={isDarkMode}
            />
          )
        }
        case "progress":
          return (
            <ProgressSummaryItem
              key={\`progress-\${index}\`}
              answered={progress.answered}
              total={progress.total}
              percentage={progress.percentage}
              isDarkMode={isDarkMode}
            />
          )
        default:
          return null
      }
    }

    switch (item.type) {
      case "total": {
        const total = getTotalConfig(item.totalId)
        if (!total) return null
        const calc = calculatedTotals[item.totalId]
        return (
          <ScoreSummaryItem
            key={\`total-\${index}\`}
            total={total}
            score={calc?.score}
            isComplete={calc?.isComplete}
            isDarkMode={isDarkMode}
          />
        )
      }
      case "interpretation": {
        const total = getTotalConfig(item.totalId)
        if (!total) return null
        const calc = calculatedTotals[item.totalId]
        return (
          <InterpretationSummaryItem
            key={\`interp-\${index}\`}
            total={total}
            score={calc?.score}
            isComplete={calc?.isComplete}
            isDarkMode={isDarkMode}
          />
        )
      }
      case "answer": {
        const question = getQuestionConfig(item.questionId)
        if (!question) return null
        return (
          <AnswerSummaryItem
            key={\`answer-\${index}\`}
            question={question}
            answer={answers[item.questionId]}
            isDarkMode={isDarkMode}
          />
        )
      }
      case "progress":
        return (
          <ProgressSummaryItem
            key={\`progress-\${index}\`}
            answered={progress.answered}
            total={progress.total}
            percentage={progress.percentage}
            isDarkMode={isDarkMode}
          />
        )
      default:
        return null
    }
  }

  const containerStyle = {
    padding: "8px 0",
  }

  const buttonRowStyle = {
    display: "flex",
    alignItems: "center",
    gap: "12px",
  }

  const summaryContainerStyle = {
    marginTop: hasAnyAnswers && showItems.length > 0 ? "10px" : 0,
    padding: hasAnyAnswers && showItems.length > 0 ? "10px 14px" : 0,
    borderRadius: "6px",
    backgroundColor: hasAnyAnswers && showItems.length > 0
      ? (isDarkMode ? "#1f1f1f" : "#fafafa")
      : "transparent",
    border: hasAnyAnswers && showItems.length > 0
      ? \`1px solid \${isDarkMode ? "#333" : "#e8e8e8"}\`
      : "none",
  }

  const summaryItemsStyle = summaryLayout === "inline"
    ? { display: "flex", flexWrap: "wrap", alignItems: "center", gap: "10px" }
    : { display: "flex", flexDirection: "column", gap: "6px" }

  const dialogTitle = modalConfig.title || title || "Assessment"
  const dialogMinWidth = modalConfig.minWidth || 700
  const showCalculationsInModal =
    Boolean(modalConfig.showCalculationsInModal) ||
    Boolean(modalConfig.show_calculations_in_modal)

  const dialogContentProps = {
    type: DialogType.largeHeader,
    title: dialogTitle,
    closeButtonAriaLabel: "Close",
  }

  const modalProps = {
    isBlocking: false,
  }

  return (
    <div style={containerStyle}>
      <div style={buttonRowStyle}>
        <PrimaryButton
          text={buttonText}
          onClick={() => setIsOpen(true)}
          iconProps={{ iconName: hasAnyAnswers ? "EditNote" : "ClipboardList" }}
        />
        {title && (
          <Text styles={{ root: { fontWeight: 600, fontSize: "14px" } }}>
            {title}
          </Text>
        )}
        {hasAnyAnswers && (
          <Text styles={{ root: { fontSize: "12px", color: isDarkMode ? "#a0a0a0" : "#888" } }}>
            {progress.answered}/{progress.total} answered
          </Text>
        )}
      </div>

      {hasAnyAnswers && showItems.length > 0 && (
        <div style={summaryContainerStyle}>
          <div style={summaryItemsStyle}>
            {showItems.map((item, idx) => renderSummaryItem(item, idx))}
          </div>
        </div>
      )}

      <Dialog
        hidden={!isOpen}
        onDismiss={() => setIsOpen(false)}
        dialogContentProps={dialogContentProps}
        modalProps={modalProps}
        minWidth={dialogMinWidth}
      >
        {isDataEntryMode ? (
          <div style={{ maxHeight: "65vh", overflowY: "auto", paddingRight: "4px" }}>
            {isMorphineCalculatorMode ? (
              renderMorphineCalculator()
            ) : dataEntryFields.length > 0 ? (
              <div style={{ display: "flex", flexWrap: "wrap", columnGap: "12px", rowGap: "10px" }}>
                {dataEntryFields.map((field) => {
                  const isHeading = _isHeadingField(field)
                  const basis = _resolveFieldWidthBasis(field)
                  const containerStyle = isHeading
                    ? { flex: "1 0 100%", maxWidth: "100%" }
                    : { flex: \`1 1 \${basis}\`, maxWidth: basis, minWidth: "220px" }
                  return (
                  <div key={field.id} style={containerStyle}>
                    {renderDataEntryField(field)}
                    {field.helpText && !isHeading && (
                      <Text styles={{ root: { fontSize: "12px", color: isDarkMode ? "#a0a0a0" : "#666", marginTop: "2px" } }}>
                        {field.helpText}
                      </Text>
                    )}
                  </div>
                )})}
              </div>
            ) : (
              <Text styles={{ root: { fontSize: "13px", color: isDarkMode ? "#a0a0a0" : "#666" } }}>
                No data-entry fields configured.
              </Text>
            )}
            {showCalculationsInModal && dataEntryCalculations.length > 0 && !isMorphineCalculatorMode && (
              <div style={{
                marginTop: "16px",
                paddingTop: "12px",
                borderTop: \`1px solid \${isDarkMode ? "#404040" : "#d8d8d8"}\`,
                display: "flex",
                flexDirection: "column",
                gap: "8px"
              }}>
                {dataEntryCalculations.map((calculation) => {
                  const value = calculatedExpressions[calculation.id]
                  return (
                    <div
                      key={\`modal-calc-\${calculation.id}\`}
                      style={{
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "baseline",
                        gap: "12px"
                      }}
                    >
                      <Text styles={{ root: { fontSize: "13px", fontWeight: 700, letterSpacing: "0.02em" } }}>
                        {calculation.label.toUpperCase()}:
                      </Text>
                      <Text styles={{ root: { fontSize: "26px", fontWeight: 700, lineHeight: 1 } }}>
                        {value ?? "Incomplete"}
                      </Text>
                    </div>
                  )
                })}
              </div>
            )}
          </div>
        ) : (
          <ScoringModule
            id={id}
            config={config}
            title=""
            showProgress={showProgress}
          />
        )}
        <div style={{ height: "16px" }} />
        <Stack horizontal horizontalAlign="end" tokens={{ childrenGap: 8 }}>
          <PrimaryButton text="Done" onClick={() => setIsOpen(false)} />
          <DefaultButton text="Cancel" onClick={() => setIsOpen(false)} />
        </Stack>
      </Dialog>
    </div>
  )
}
`,
  './UseChangeWatch/index.jsx': `type WatchState = { savedValue: any, renderCount: number }
type WatchResult = [
  hasChanged:boolean,
  setHasChanged:((hasChanged?: boolean, delayCount?:number)=>void)
]
const useChangeWatch = ( watchedValue: any, delayCount:number=3 ):WatchResult => {

  const [ watcher, setWatcher ] = useState({ savedValue: watchedValue, renderCount: delayCount } as WatchState)

  const setChanged = useCallback((isChanged:any=false,resetCount:number=delayCount) => {
    if (isChanged) {
      setWatcher(old => ({ ...old, savedValue: null }))
    } else {
      setWatcher({ savedValue: watchedValue, renderCount: resetCount })
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  },[])

  useEffect(() => {
    if (watcher.renderCount>0) {
      setWatcher(old => ({ ...old, renderCount: watcher.renderCount-1 }))
    }

  },
  [ watchedValue ])

  return [
    watchedValue!==watcher.savedValue && watcher.renderCount<=0,
    setChanged,
  ]
}
`,
};

// Component identities (metadata from Identity.json files)
export const componentIdentities: Record<string, any> = {
  'AliasIdList': {
    "name": "AliasIdList",
    "title": "List of alias identifiers",
    "description": "Produces a simple list of IDs matching a filter predicate",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'Allergies': {
    "name": "Allergies",
    "title": "Selected allergies",
    "description": "ListSelection component for Allergies",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'CommonSchemaDefn': {
    "name": "CommonSchemaDefn",
    "title": "Common definitions for JSON Schema elements",
    "description": "",
    "version": {
      "major": 1,
      "minor": 1,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 17
    }
  },
  'CompactBooleanField': {
    "name": "CompactBooleanField",
    "title": "Compact Boolean Field with Yes/No Buttons",
    "description": "A compact boolean field component with styled Yes/No buttons, custom label support (e.g., Normal/Abnormal), size variants, and card container styling",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'ConditionalGroup': {
    "name": "ConditionalGroup",
    "title": "Conditional Group with Logic Gate System",
    "description": "A logic gate system for conditional field visibility based on controller fields, supporting up to 5 levels of nesting with parent chain visibility checking",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'Conditions': {
    "name": "Conditions",
    "title": "Selected conditions",
    "description": "ListSelection component for Conditions",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'Connections': {
    "name": "Connections",
    "title": "Selected connected resources",
    "description": "ListSelection component for the patient connections (family doctor, etc)",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'EditableTable': {
    "name": "EditableTable",
    "title": "Editable Table with Add/Delete Rows",
    "description": "A table component with progressive disclosure, add/delete row functionality, empty row detection, and configurable column types",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'EducationHistory': {
    "name": "EducationHistory",
    "title": "Selection of educational programs completed",
    "description": "ListSelection component for educations",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'Ethnicity': {
    "name": "Ethnicity",
    "title": "Ethnicity reference set",
    "description": "Ethnicity reference set for Home care and MHSU forms",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'FirstNationsStatus': {
    "name": "FirstNationsStatus",
    "title": "First nations status block",
    "description": "Core first nations information for Home care and MHSU forms. Requires Ethnicity component",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'Goals': {
    "name": "Goals",
    "title": "Selected patient goals",
    "description": "ListSelection component for goals",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'HFC_PT_ASMT_PatientAssessment': {
    "name": "hfc_pt_asmt_patientassessment",
    "title": "HFC Patient Assessment",
    "description": "Section of the HFC Patient assessment webform",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "David Medlyn [Northern Health]",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 28,
      "patch": 10
    }
  },
  'HFC_PT_ASMT_PatientSummary': {
    "name": "hfc_pt_asmt_patientsummary",
    "title": "HFC Patient Summary",
    "description": "Section of the HFC Patient assessment webform",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "David Medlyn [Northern Health]",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 28,
      "patch": 10
    }
  },
  'HFC_PT_ASMT_SnapShot': {
    "name": "hfc_pt_asmt_patientsnapshot",
    "title": "HFC Patient Assessment Snapshot",
    "description": "Section of the HFC Patient assessment webform",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "David Medlyn [Northern Health]",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 28,
      "patch": 10
    }
  },
  'HonosQuestion': {
    "name": "HonosQuestion",
    "title": "Control for a single HONOS question",
    "description": "",
    "version": {
      "major": 1,
      "minor": 1,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 18
    }
  },
  'HotspotMapField': {
    "name": "HotspotMapField",
    "title": "Hotspot Map Field",
    "description": "Generic interactive image/SVG hotspot map with selectable regions and selection counters",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'LongTermMedications': {
    "name": "LongTermMedications",
    "title": "ListSelection for LongTermMedicationOrders",
    "description": "User chooses relevant medication(s)",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'MoisPatientReviewLink': {
    "name": "MoisPatientReviewLink",
    "title": "MOIS Patient Review Link",
    "description": "Displays a hyperlink and a confirmation checkbox to indicate the material was reviewed and provided to the patient",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    },
    "components": []
  },
  'MseAbc': {
    "name": "MseAbc",
    "title": "MSE - ABC: Appearance, Behaviour and Cooperation",
    "description": "Section of the ABC STAMP LICK ER assessment",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'MseEr': {
    "name": "MseEr",
    "title": "MSE - ER: Ending and Reliability",
    "description": "Section of the ABC STAMP LICK ER assessment",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'MseLick': {
    "name": "MseLick",
    "title": "MSE - LICK: Level of Consciusness, Insight and Judgement, Cognitive Functioning and Knowledge Base",
    "description": "Section of the ABC STAMP LICK ER assessment",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'MseStamp': {
    "name": "MseStamp",
    "title": "MSE - STAMP: Speech, Thoughts, Affect, Mood, and Perception",
    "description": "Section of the ABC STAMP LICK ER assessment",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'NewTextArea': {
    "name": "NewTextArea",
    "title": "NewTextArea",
    "description": "A way to make text fields show all data on print",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    },
    "components": []
  },
  'Occupations': {
    "name": "Occupations",
    "title": "Show employment history",
    "description": "User chooses relevant employer(s)",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'PdfRegenerator': {
    "name": "PdfRegenerator",
    "title": "PDF Regenerator",
    "description": "Client-side runtime JSX button that regenerates a filled AcroForm PDF from current form data.",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 18
    }
  },
  'PlannedActions': {
    "name": "PlannedActions",
    "title": "Selected planned actions",
    "description": "ListSelection component for Actions",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'ReferralSource': {
    "name": "ReferralSource",
    "title": "Referral source value set",
    "description": "Referral source value set for Home care and MHSU forms",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Northern Health",
    "author": "Northern Health",
    "publisher": "Northern Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'RelationshipStatus': {
    "name": "RelationshipStatus",
    "title": "Relationship (marital) status from demographics",
    "description": "Read only relationship status",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'SaveOnClose': {
    "name": "SaveOnClose",
    "title": "Save On Close",
    "description": "Automatically saves form data as draft when the browser window/tab is closed",
    "category": "Utility",
    "version": "1.0.0"
  },
  'ScaleField': {
    "name": "ScaleField",
    "title": "Configurable Scale Field",
    "description": "A horizontal scale input with configurable options, labels, and tooltips. Supports HoNOS-style and Likert-style scales.",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 18
    }
  },
  'ScoringModule': {
    "name": "ScoringModule",
    "title": "Scoring Module with Interpretation",
    "description": "A scoring questionnaire component with configurable questions, weighted totals, and interpretation ranges",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'ServiceEpisodes': {
    "name": "ServiceEpisodes",
    "title": "Select service episodes",
    "description": "User chooses relevant service episode(s)",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'ServiceRequests': {
    "name": "ServiceRequests",
    "title": "Select service requests (orders)",
    "description": "User chooses relevant order(s)",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    }
  },
  'SignaturePad': {
    "name": "SignaturePad",
    "title": "Signature Pad",
    "description": "A canvas-based signature capture component. Allows users to draw signatures with configurable pen color, width, and background. Stores signature data as base64 data URL.",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 18
    }
  },
  'SubformScoring': {
    "name": "SubformScoring",
    "title": "Subform Scoring with Modal and Summary",
    "description": "A modal subform component supporting scoring questionnaires and structured data-entry workflows, with configurable inline summary items after completion",
    "version": {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "type": "component",
    "owner": "MOIS Styleguide",
    "author": "MOIS Styleguide",
    "publisher": "MOIS Styleguide",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 26,
      "patch": 12
    },
    "components": [
      "HotspotMapField",
      "ScoringModule"
    ]
  },
  'UseChangeWatch': {
    "name": "UseChangeWatch",
    "title": "Check for user changes",
    "description": "",
    "version": {
      "major": 0,
      "minor": 1,
      "patch": 0
    },
    "type": "component",
    "owner": "Bright Health",
    "author": "Bright Health",
    "publisher": "Bright Health",
    "globalIdentifier": "",
    "requiredFormViewerVersion": {
      "major": 1,
      "minor": 1,
      "patch": 0
    },
    "requiredMoisVersion": {
      "major": 2,
      "minor": 28,
      "patch": 5
    }
  },
};

// List of component names for iteration
export const componentNames = [
  'AliasIdList',
  'Allergies',
  'CommonSchemaDefn',
  'CompactBooleanField',
  'ConditionalGroup',
  'Conditions',
  'Connections',
  'EditableTable',
  'EducationHistory',
  'Ethnicity',
  'FirstNationsStatus',
  'Goals',
  'HFC_PT_ASMT_PatientAssessment',
  'HFC_PT_ASMT_PatientSummary',
  'HFC_PT_ASMT_SnapShot',
  'HonosQuestion',
  'HotspotMapField',
  'LongTermMedications',
  'MoisPatientReviewLink',
  'MseAbc',
  'MseEr',
  'MseLick',
  'MseStamp',
  'NewTextArea',
  'Occupations',
  'PdfRegenerator',
  'PlannedActions',
  'ReferralSource',
  'RelationshipStatus',
  'SaveOnClose',
  'ScaleField',
  'ScoringModule',
  'ServiceEpisodes',
  'ServiceRequests',
  'SignaturePad',
  'SubformScoring',
  'UseChangeWatch',
] as const;

export type ComponentName = typeof componentNames[number];
